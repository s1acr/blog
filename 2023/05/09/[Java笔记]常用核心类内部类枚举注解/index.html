<!DOCTYPE html><html lang="en"><head><!-- hexo injector head_begin start -->
<link rel="stylesheet" href="/css/bilicard.css">
<meta name="baidu-site-verification" content="codeva-pFQ3MHhnDY">
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9317015731056598" crossorigin="anonymous"></script>

<script src="/config.b810d57c68fbb8a39a0a.js"></script>
<!-- hexo injector head_begin end -->
<meta charset="utf-8">
<title>[Java笔记]常用核心类内部类枚举注解 - slacr_'s blog</title>
<base href="/">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link rel="canonical" href="https://s1acr.github.io/2023/05/09/[Java%E7%AC%94%E8%AE%B0]%E5%B8%B8%E7%94%A8%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%86%85%E9%83%A8%E7%B1%BB%E6%9E%9A%E4%B8%BE%E6%B3%A8%E8%A7%A3/">
<link rel="icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/bitbug_favicon.ico">
<link rel="manifest" href="/manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="description" content="Java 笔记  Object  toString() 调用对象的 toString()方法可以返回对象的字符串表示toCast. 该方法在Object类中的定义是返回包名.类名@一个十六进制整数. 如 Father@4f3f5b24. 输出函数传入类的实例默认调用. Java 类库中，有许多类覆盖了 toString()方法，输出时能够得到可理解的结果. equals() 比较两个对象是否相等">
<meta property="og:type" content="website">
<meta property="og:title" content="[Java笔记]常用核心类内部类枚举注解">
<meta property="og:url" content="https://s1acr.github.io/2023/05/09/[Java%E7%AC%94%E8%AE%B0]%E5%B8%B8%E7%94%A8%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%86%85%E9%83%A8%E7%B1%BB%E6%9E%9A%E4%B8%BE%E6%B3%A8%E8%A7%A3/index.html">
<meta property="og:site_name" content="slacr_'s blog">
<meta property="og:description" content="Java 笔记  Object  toString() 调用对象的 toString()方法可以返回对象的字符串表示toCast. 该方法在Object类中的定义是返回包名.类名@一个十六进制整数. 如 Father@4f3f5b24. 输出函数传入类的实例默认调用. Java 类库中，有许多类覆盖了 toString()方法，输出时能够得到可理解的结果. equals() 比较两个对象是否相等">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg">
<meta property="article:published_time" content="2023-05-09T00:00:00.000Z">
<meta property="article:modified_time" content="2023-05-09T00:00:00.000Z">
<meta property="article:author" content="slacr_">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg">
<script type="application/ld+json">[{"@context":"http://schema.org","@type":"WebSite","publisher":{"@type":"Person","name":"slacr_","description":"Crap Programmer, College Student From CN. Idealist and Minimalism, life-long learner. I was lucky to find out what I truly have passion for. 🚬.","image":"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg"},"url":"https://s1acr.github.io","image":"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg","description":"slacr_ blog self blog website record coding githubpages","author":{"@type":"Person","name":"slacr_","description":"Crap Programmer, College Student From CN. Idealist and Minimalism, life-long learner. I was lucky to find out what I truly have passion for. 🚬.","image":"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg"},"inLanguage":{"@type":"Language","alternateName":"en"}},{"@context":"http://schema.org","@type":"Article","articleSection":"Java","url":"https://s1acr.github.io/2023/05/09/[Java%E7%AC%94%E8%AE%B0]%E5%B8%B8%E7%94%A8%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%86%85%E9%83%A8%E7%B1%BB%E6%9E%9A%E4%B8%BE%E6%B3%A8%E8%A7%A3/","headline":"[Java笔记]常用核心类内部类枚举注解","image":"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg","datePublished":"2023-05-09T00:00:00.000Z","dateModified":"2023-05-09T00:00:00.000Z","keywords":"","description":"slacr_ blog self blog website record coding githubpages","publisher":{"@type":"Organization","name":"slacr_'s blog","logo":{"@type":"ImageObject","url":"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg"}},"author":{"@type":"Person","name":"slacr_","description":"Crap Programmer, College Student From CN. Idealist and Minimalism, life-long learner. I was lucky to find out what I truly have passion for. 🚬.","image":"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg"},"inLanguage":{"@type":"Language","alternateName":"en"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://s1acr.github.io/2023/05/09/[Java%E7%AC%94%E8%AE%B0]%E5%B8%B8%E7%94%A8%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%86%85%E9%83%A8%E7%B1%BB%E6%9E%9A%E4%B8%BE%E6%B3%A8%E8%A7%A3/"}}]</script>

<!-- hexo injector head_end start --><style is="theme">html{--inside-accent-color:#2a2b33;--inside-foreground-color:#363636;--inside-border-color:#e0e0e0;--inside-background:#f3f6f7;--inside-sidebar-background:#2a2b33;--inside-card-background:#fff;--inside-font-base:ZCOOL_XiaoWei;--inside-font-logo:Lobster,ZCOOL_XiaoWei;--inside-font-menu:Lobster,ZCOOL_XiaoWei;--inside-font-heading:Baloo_Paaji_2,ZCOOL_XiaoWei;--inside-font-label:Lobster,ZCOOL_XiaoWei;--inside-font-code:ZCOOL_XiaoWei,Inconsolata,monospace;--inside-font-print:ZCOOL_XiaoWei;--inside-content-width:800px;--inside-highlight-00:#1e1e1e;--inside-highlight-01:#323537;--inside-highlight-02:#464b50;--inside-highlight-03:#5f5a60;--inside-highlight-04:#838184;--inside-highlight-05:#a7a7a7;--inside-highlight-06:#c3c3c3;--inside-highlight-07:#ffffff;--inside-highlight-08:#cf6a4c;--inside-highlight-09:#cda869;--inside-highlight-0a:#f9ee98;--inside-highlight-0b:#8f9d6a;--inside-highlight-0c:#afc4db;--inside-highlight-0d:#7587a6;--inside-highlight-0e:#9b859d;--inside-highlight-0f:#9b703f;--inside-card-color:#fff;--inside-accent-color-005:rgba(42,43,51,.05);--inside-accent-color-01:rgba(42,43,51,.1);--inside-accent-color-02:rgba(42,43,51,.2);--inside-accent-color-04:rgba(42,43,51,.4);--inside-accent-color-08:rgba(42,43,51,.8)}</style><script src="/theme.9ecc9ab1.js"></script><link href="https://cdn.jsdelivr.net/gh/s1acr/my_jsDelivr@main/googleFonts/myblog.css" rel="stylesheet"><link href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="//cdn.jsdelivr.net/gh/s1acr/my_jsDelivr@main/blogSelfDesignDist.css" rel="stylesheet">
<script src="/cipher.0329a0a9.js"></script>

<script src="/palette.ead17218.js"></script>
<link href="/styles.91e7dfca63c7c151daa6.css" rel="stylesheet"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><meta name="theme-color" content=""><script type="application/json" is="state">{&q;api/MjAyMy8wNS8wOS9bSmF2YeeslOiusF3luLjnlKjmoLjlv4PnsbvlhoXpg6jnsbvmnprkuL7ms6jop6M.json&q;:{&q;title&q;:&q;[Java笔记]常用核心类内部类枚举注解&q;,&q;date&q;:&q;2023-05-09T00:00:00.000Z&q;,&q;date_formatted&q;:{&q;ll&q;:&q;May 9, 2023&q;,&q;L&q;:&q;05/09/2023&q;,&q;MM-DD&q;:&q;05-09&q;},&q;link&q;:&q;2023/05/09/[Java笔记]常用核心类内部类枚举注解&q;,&q;comments&q;:true,&q;categories&q;:[&q;Java&q;],&q;updated&q;:&q;2023-05-09T00:00:00.000Z&q;,&q;content&q;:&q;&l;blockquote&g;\n&l;p&g;Java 笔记&l;/p&g;\n&l;/blockquote&g;\n&l;h2 id=\&q;object\&q;&g;Object&l;a title=\&q;#object\&q; href=\&q;#object\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;&l;img src=\&q;https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305092218740.png\&q; alt=\&q;\&q; loading=\&q;lazy\&q; class=\&q;φbp\&q;&g;&l;/p&g;\n&l;p&g;&l;code&g;toString()&l;/code&g;&l;br&g;\n调用对象的 toString()方法可以返回对象的字符串表示toCast. 该方法在Object类中的定义是返回包名.类名@一个十六进制整数. 如 Father@4f3f5b24. 输出函数传入类的实例默认调用. Java 类库中，有许多类覆盖了 toString()方法，输出时能够得到可理解的结果.&l;/p&g;\n&l;p&g;&l;code&g;equals()&l;/code&g;&l;br&g;\n比较两个对象是否相等, 比较的是对象的引用. 在Java类库中的许多类也覆盖了该方法，如String类。因此，对String对象使用equals()方法的比较是字符串的内容是否相等。&l;br&g;\n在子类中，使用签名equals(ClassName obj)覆盖 equals()方法是一个常见的错误，应该使用 equals (Object obj) 覆盖 equals()方法.&l;/p&g;\n&l;p&g;&l;code&g;hashCode()&l;/code&g;&l;br&g;\nhashCode()方法返回一个对象的哈希码 (hash code) 值，它是一个整数，主要用来比较对象的大小。在Object类中hashCode()方法的实现是返回对象在计算机内部存储的十进制内存地址.&l;br&g;\nhashCode()方法和 equals()方法必须是兼容的，如果你为一个类覆盖了equals()方法，则也需要覆盖hashCode()方法，以兼容equals()方法&l;br&g;\njava.util.Objects类的 hash()方法的参数是可变参数，该方法计算每个参数的哈希码，并将它们组合起来。这个方法是空指针安全的。&l;br&g;\n如果类包含数组类型的实例变量，比较它们的哈希码时，首先使用静态方法Arrays.hashCode()计算数组的每个元素哈希码组成的哈希码，然后将结果传给 Objects 的hash()方法.&l;/p&g;\n&l;p&g;&l;code&g;clone()&l;/code&g;&l;br&g;\n使用 Object类的 clone()方法可以克隆一个对象，即创建一个对象的副本。要使类的对象能够克隆，类必须实现Cloneable接口.&l;br&g;\n使用 Object类继承的 clone()方法克隆对象只是做了浅拷贝。它简单地从原对象中复制所有实例变量到目标对象中。如果实例变量是基本类型或不变对象(如String), 将没有问题；否则，原对象和克隆对象将共享可变的状态。&l;/p&g;\n&l;p&g;&l;code&g;finalize()&l;/code&g;&l;br&g;\n每个对象都有一个 finalize()方法。在对象被销毁之前，&l;code&g;垃圾回收器允许对象调用该方法进行清理工作，这个过程称为对象终结 (finalization)&l;/code&g;。 格式为 &l;code&g;protected void finalize() throws Throwable&l;/code&g;&l;/p&g;\n&l;h2 id=\&q;math\&q;&g;Math&l;a title=\&q;#math\&q; href=\&q;#math\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;&l;img src=\&q;https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305101332456.png\&q; alt=\&q;\&q; loading=\&q;lazy\&q; class=\&q;φbp\&q;&g;&l;/p&g;\n&l;h2 id=\&q;基本类型包装类\&q;&g;基本类型包装类&l;a title=\&q;#基本类型包装类\&q; href=\&q;#基本类型包装类\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;&l;img src=\&q;https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305101341697.png\&q; alt=\&q;\&q; loading=\&q;lazy\&q; class=\&q;φbp\&q;&g;&l;/p&g;\n&l;h3 id=\&q;character\&q;&g;Character&l;a title=\&q;#character\&q; href=\&q;#character\&q;&g;&l;/a&g;&l;/h3&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Character&l;/span&g; &l;span class=\&q;variable\&q;&g;c_1&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; (&l;span class=\&q;string\&q;&g;&a;#x27;A&a;#x27;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Character&l;/span&g; &l;span class=\&q;variable\&q;&g;c_2&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; (&l;span class=\&q;string\&q;&g;&a;#x27;</head>a;#x27;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Character&l;/span&g; &l;span class=\&q;variable\&q;&g;c_3&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; (&l;span class=\&q;string\&q;&g;&a;#x27;简&a;#x27;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(c_1.compareTo(&l;span class=\&q;string\&q;&g;&a;#x27;D&a;#x27;&l;/span&g;));  &l;span class=\&q;comment\&q;&g;// -3&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(c_2.charValue());       &l;span class=\&q;comment\&q;&g;// </head>l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(c_3.isLetter(&l;span class=\&q;string\&q;&g;&a;#x27;简&a;#x27;&l;/span&g;));  &l;span class=\&q;comment\&q;&g;// true&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;常用方法:&l;/p&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public char charValue() &l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回 Character 对象所包含的 char值。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public int compareTo(Character anotherChar) &l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;比较两个字符对象。如果该字符对象与参数字符对象相等，返回0;若小于参数字符，返回值小于0;若大于参数字符，则返回值大于0。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static boolean isDigit(char ch)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回参数字符是否是数字。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static boolean isLetter(char ch)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回参数字符是否是字母。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static boolean isLowerCase(char ch)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回参数字符是否是小写字母。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static boolean isUpperCase(char ch)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回参数字符是否是大写字母。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static boolean isWhiteSpace(char ch)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回参数字符是否是空白字符。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static char toLowerCase(char ch)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;将参数字符转换为小写字母返回。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static char toUpperCase(char ch)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;将参数字符转换为大写字母返回。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static boolean isJavaIdentifierStart(char ch) &l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回参数字符是否允许作为 Java标识符的开头字符。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static boolean isJavaldentifierPart (char ch) &l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回参数字符是否允许作为 Java标识符的中间字符。&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;h3 id=\&q;boolean\&q;&g;Boolean&l;a title=\&q;#boolean\&q; href=\&q;#boolean\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;常用方法:&l;/p&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public Boolean(boolean value)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;用一个boolean型值创建一个Boolean对象。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public Boolean(String s)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;用一个字符串创建Boolean对象。如果字符串 s不为 null 且其值为 “true”(不区分大小写)就创建一个true值，否则创建一个 false值。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public boolean booleanValue()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回该Boolean 对象所封装的 boolean值。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static boolean parseBoolean(String s)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;将参数s解析为一个 boolean 值。如果参数不为 null 且等于 “true”(不区分大小写),则返回true, 否则返回 false。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static Boolean valueOf(boolean b)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;将参数b 的值转换为 Boolean 对象。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static Boolean valueOf(String s)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;将参数s 的值转换为 Boolean对象。&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;boolean&l;/span&g; &l;span class=\&q;variable\&q;&g;b&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;literal\&q;&g;false&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Boolean&l;/span&g; &l;span class=\&q;variable\&q;&g;b_1&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;Boolean&l;/span&g;(b);               &l;span class=\&q;comment\&q;&g;// false&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Boolean&l;/span&g; &l;span class=\&q;variable\&q;&g;b_2&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;Boolean&l;/span&g;(&l;span class=\&q;string\&q;&g;&a;quot;TruE&a;quot;&l;/span&g;);      &l;span class=\&q;comment\&q;&g;// true , 这两个方法已经不支持, 将要移除&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(b_1);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(b_2);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(b_1.booleanValue());  &l;span class=\&q;comment\&q;&g;// false&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(Boolean.parseBoolean(&l;span class=\&q;string\&q;&g;&a;quot;True&a;quot;&l;/span&g;));     &l;span class=\&q;comment\&q;&g;// true&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(Boolean.valueOf(b).booleanValue());   &l;span class=\&q;comment\&q;&g;// false&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(Boolean.valueOf(&l;span class=\&q;string\&q;&g;&a;quot;OK&a;quot;&l;/span&g;)); &l;span class=\&q;comment\&q;&g;// false&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;数值类对象\&q;&g;数值类对象&l;a title=\&q;#数值类对象\&q; href=\&q;#数值类对象\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;常用方法:&l;/p&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public Integer(int value) &l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;使用 int类型的值创建包装类型 Integer对象。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public Integer(String s) &l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;使用字符串构造Integer对象，如果字符串不能转换成相应的数值，则抛出NumberFormatException异常&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static String toBinaryString(int i)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回整数i用字符串表示的二进制序列。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static String toHexString(int i) &l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回整数i用字符串表示的十六进制序列。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static String toOctalString(int i) &l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回整数 i用字符串表示的八进制序列。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static int highestOneBit(int i) &l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回整数i的二进制补码的最高位1所表示的十进制数，如7(111)的最高位的1表示的值为4。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static int lowestOneBit(int i)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回整数 i的二进制补码的最低位1所表示的十进制数，如10(1010)的最低位的1表示的值为2。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static int reverse(int i) &l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回将整数i的二进制序列反转后的整数值。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static int signum(inti)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回整数i的符号。若 i大于0,返回1;若 i等于0,&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;返回0,若 i小于0则返回-1。&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;p&g;每种包装类型都覆盖了toString()方法和 equals()方法，因此使用 equals()方法比较包装类型的对象时是比较内容或所包装值.每种包装类型的对象中所包装的值是不可改变的，要改变对象中的值必须重新生成新的对象.&l;/p&g;\n&l;p&g;每个数值包装类都定义了 &l;code&g;SIZE、BYTES、MAX_VALUE、MIN_VALUE &l;/code&g;常量。&l;br&g;\nSIZE 表示每种类型的数据所占的位数&l;br&g;\nBYTES 表示数据所占的字节数&l;br&g;\nMAX_VALUE 表示对应基本类型数据的最大值.&l;br&g;\n对于Byte、Short、Integer和Long 来说，MIN_VALUE 表示类型的最小值。对 Float和 Double 来说，MIN_VALUE 最小正值。&l;br&g;\n除了上面的常量外，在 Float 和 Double 类中还分别定义了 POSITIVE_INFINITY、NEGATIVE INFINITY、NaN(not a number), 它们分别表示正、负无穷大和非数值。&l;/p&g;\n&l;h3 id=\&q;自动装箱与自动拆箱\&q;&g;自动装箱与自动拆箱&l;a title=\&q;#自动装箱与自动拆箱\&q; href=\&q;#自动装箱与自动拆箱\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;Java 5 版提供了一种新的功能，称为自动装箱和自动拆箱。自动装箱 (autoboxing) 是指基本类型的数据可以自动转换为包装类的实例，自动拆箱 (unboxing) 是指包装类的实例自动转换为基本类型的数据。&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Integer&l;/span&g; &l;span class=\&q;variable\&q;&g;i&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;300&l;/span&g;;   &l;span class=\&q;comment\&q;&g;// auto boxing&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;i_1&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; i;        &l;span class=\&q;comment\&q;&g;// auto unboxing&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(((Integer)i_1).toString()); &l;span class=\&q;comment\&q;&g;// 强制转换&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;字符串与基本数据类型转化\&q;&g;字符串与基本数据类型转化&l;a title=\&q;#字符串与基本数据类型转化\&q; href=\&q;#字符串与基本数据类型转化\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;&l;code&g;public static Type parse&a;#123;Type&a;#125;(String s)&l;/code&g;&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;String&l;/span&g; &l;span class=\&q;variable\&q;&g;s&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;String&l;/span&g;(&l;span class=\&q;string\&q;&g;&a;quot;123&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(Integer.parseInt(s));  &l;span class=\&q;comment\&q;&g;// 字符串转基本类型&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(Double.parseDouble(s));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;i&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;100&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(String.valueOf(i) &l;span class=\&q;keyword\&q;&g;instanceof&l;/span&g;  String); &l;span class=\&q;comment\&q;&g;// 基本类型转字符串&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(((Integer)i).toString());   &l;span class=\&q;comment\&q;&g;// 或者通过包装类的toString()方法&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h2 id=\&q;biginteger-bigdecimal\&q;&g;BigInteger BigDecimal&l;a title=\&q;#biginteger-bigdecimal\&q; href=\&q;#biginteger-bigdecimal\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;如果在计算中需要非常大的整数或非常高精度的浮点数，可以使用java.math 包中定义的BigInteger类和 BigDecimal类。这两个类都扩展了Number类并实现了Comparable 接口，它们的实例都是不可变的.&l;/p&g;\n&l;p&g;&l;a href=\&q;https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/math/BigInteger.html\&q; target=\&q;_blank\&q;&g;https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/math/BigInteger.html&l;/a&g;&l;/p&g;\n&l;h2 id=\&q;时间日期api\&q;&g;时间日期API&l;a title=\&q;#时间日期api\&q; href=\&q;#时间日期api\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;java.time&l;br&g;\n&l;a href=\&q;https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/time/package-summary.html\&q; target=\&q;_blank\&q;&g;https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/time/package-summary.html&l;/a&g;&l;/p&g;\n&l;h2 id=\&q;内部类\&q;&g;内部类&l;a title=\&q;#内部类\&q; href=\&q;#内部类\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;Java 语言允许在一个类的内部定义另一个类(接口、枚举或注解),这种类称为内部类 (inner class)或嵌套类 (nested class)&l;br&g;\n使用内部类的优点：对只在一处使用的类进行分组；提高封装性；增强代码的可读性和可维护性。&l;br&g;\n有多种类型的内部类，大致可分为&l;code&g;成员内部类、局部内部类、匿名内部类和静态内部类&l;/code&g;。&l;/p&g;\n&l;h3 id=\&q;内部成员类\&q;&g;内部成员类&l;a title=\&q;#内部成员类\&q; href=\&q;#内部成员类\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;成员内部类没有用 static修饰且定义在外层类的类体中&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;OuterClass&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;InnerClass&l;/span&g; &a;#123;   &l;span class=\&q;comment\&q;&g;// 内部类相当于成员, 可以访问外部内所有成员&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;y&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;title function_\&q;&g;add&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g; x + y;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;private&l;/span&g; &l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;x&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;2&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;OuterClass&l;/span&g; &l;span class=\&q;variable\&q;&g;o&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;OuterClass&l;/span&g;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        OuterClass.&l;span class=\&q;type\&q;&g;InnerClass&l;/span&g; &l;span class=\&q;variable\&q;&g;i&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; o.&l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;InnerClass&l;/span&g;();   &l;span class=\&q;comment\&q;&g;// 创建内部类&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        OuterClass.&l;span class=\&q;type\&q;&g;InnerClass&l;/span&g; &l;span class=\&q;variable\&q;&g;ii&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;OuterClass&l;/span&g;().&l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;InnerClass&l;/span&g;();  &l;span class=\&q;comment\&q;&g;// 或者&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(ii.add()); &l;span class=\&q;comment\&q;&g;// 3&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;使用成员内部类时需要注意下面几个问题：&l;/p&g;\n&l;ol&g;\n&l;li&g;成员内部类中不能定义 static变量和 static方法。&l;/li&g;\n&l;li&g;成员内部类也可以使用 abstract和 final修饰，其含义与其他类一样。&l;/li&g;\n&l;li&g;成员内部类还可以使用 private、public、protected或包可访问修饰符。&l;/li&g;\n&l;/ol&g;\n&l;h3 id=\&q;局部内部类\&q;&g;局部内部类&l;a title=\&q;#局部内部类\&q; href=\&q;#局部内部类\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;可以在方法体或语句块内定义类。在方法体或语句块 (包括方法、构造方法、局部块、初始化块或静态初始化块)内部定义的类称为局部内部类 (local inner class)&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;OuterClass&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;private&l;/span&g; &l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;x&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;makeInner&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;type\&q;&g;int&l;/span&g; p)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;String&l;/span&g; &l;span class=\&q;variable\&q;&g;s&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;string\&q;&g;&a;quot;local_variable&a;quot;&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;InnerClass&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;seekOuter&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                System.out.println(x);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                System.out.println(s);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                System.out.println(p);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;       &l;span class=\&q;comment\&q;&g;// 此局部类只在这个函数中有效&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;InnerClass&l;/span&g;().seekOuter();       &l;span class=\&q;comment\&q;&g;// 创建对象调用方法&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;OuterClass&l;/span&g; &l;span class=\&q;variable\&q;&g;o&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;OuterClass&l;/span&g;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        o.makeInner(&l;span class=\&q;number\&q;&g;2&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//1&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//local_variable&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//2&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;匿名内部类\&q;&g;匿名内部类&l;a title=\&q;#匿名内部类\&q; href=\&q;#匿名内部类\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;定义类最终目的是创建一个类的实例，但如果某个类的实例只使用一次，可以将类的定义和实例的创建在一起完成，或者说在定义类的同时就创建一个实例。以这种方式定义的没有名字的类称为匿名内部类 (anonymous inner class)。&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;abstract&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Person&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;type\&q;&g;String&l;/span&g; &l;span class=\&q;variable\&q;&g;name&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;string\&q;&g;&a;quot;slacr&a;quot;&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;abstract&l;/span&g; &l;span class=\&q;keyword\&q;&g;public&l;/span&g; String &l;span class=\&q;title function_\&q;&g;work&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;OuterClass&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;private&l;/span&g; &l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;x&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// 匿名对象继承 Person, 初始化同时定义&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Person&l;/span&g; &l;span class=\&q;variable\&q;&g;hero&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;Person&l;/span&g;()&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;          &l;span class=\&q;meta\&q;&g;@Override&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;           &l;span class=\&q;keyword\&q;&g;public&l;/span&g; String &l;span class=\&q;title function_\&q;&g;work&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;              &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;string\&q;&g;&a;quot;punish evil-doers&a;quot;&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;          &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(&l;span class=\&q;string\&q;&g;&a;quot;Hero &a;quot;&l;/span&g; + hero.name + &l;span class=\&q;string\&q;&g;&a;quot;, I will &a;quot;&l;/span&g; + hero.work());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// Hero slacr, I will punish evil-doers&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;匿名内部类可以继承一个类或实现一个接口, 如果实现一个接口，该类是Object类的直接子类。匿名类继承一个类或&l;br&g;\n实现一个接口不需要使用 extends 或 implements 关键字。匿名内部类不能同时继承一个类和实现一个接口，也不能实现多个接口&l;br&g;\n匿名内部类的一个重要应用是编写 JavaFX 图形界面的事件处理程序。如为按钮对象button 注册事件处理器，就可以使用匿名内部类。&l;/p&g;\n&l;h3 id=\&q;静态内部类\&q;&g;静态内部类&l;a title=\&q;#静态内部类\&q; href=\&q;#静态内部类\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;静态内部类使用 static修饰，静态内部类也称嵌套类 (nested class)&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;OuterClass&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;private&l;/span&g;  &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;x&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;private&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;outer&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(&l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;OuterClass&l;/span&g;().getClass().getSimpleName());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g;  &l;span class=\&q;keyword\&q;&g;static&l;/span&g;  &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;InnerClass&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;private&l;/span&g; &l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;y&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;2&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;test&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            outer();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.println(x);      &l;span class=\&q;comment\&q;&g;// 可以访问外部静态成员方法和变量&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.println(y);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        OuterClass.&l;span class=\&q;type\&q;&g;InnerClass&l;/span&g; &l;span class=\&q;variable\&q;&g;i&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;OuterClass&l;/span&g;.InnerClass();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// 不需要外层实例就可以直接创建一个静态内部实例&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        i.test();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h2 id=\&q;枚举类型\&q;&g;枚举类型&l;a title=\&q;#枚举类型\&q; href=\&q;#枚举类型\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;枚举类型是一种特殊的引用类型，它的声明和使用与类和接口有类似的地方。它可以作为顶层的类型声明，也可以像内部类一样在其他类的内部声明，但不能在方法内部声明枚举。&l;/p&g;\n&l;p&g;任何枚举类型都隐含地继承了java.lang.Enum抽象类，Enum类又是Object类的子类，同时实现了 Comparable 接口和 Serializable接口。每个枚举类型都包含了若干方法，下面是一些常用的&l;/p&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static E[] values()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回一个包含所有枚举常量的数组，这些枚举常量在数组中是按照它们的声明顺序存储的。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static E valueOf(String name)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回指定名字的枚举常量。如果这个名字与任何一个枚举常量的名字都不能精确匹配，将抛出 IlegalArgumentException 异常。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public final int compareTo(Eo)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回当前枚举对象与参数枚举对象的比较结果。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public final Class&a;lt;E&a;gt; getDeclaringClass()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回对应该枚举常量的枚举类型的类对象。两个枚举常量 el、e2, 当且仅当 el.getDeclaringClass() == e2.getDeclaringClass()时，这两个枚举常量类型相同。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public final String name()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回枚举常量名。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public final int ordinal()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回枚举常量的顺序值，该值是基于常量声明的顺序的，第一个常量的顺序值是0,第二个常量的顺序值为1,依次类推。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public String toString()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回枚举常量名。&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Direction&l;/span&g; &l;span class=\&q;variable\&q;&g;left&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; Direction.W;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(left);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; ( Direction d : Direction.values()) &a;#123;    &l;span class=\&q;comment\&q;&g;// values() 是一个包含枚举常量的数组&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.println(d.name() + &l;span class=\&q;string\&q;&g;&a;quot; &a;quot;&l;/span&g; + d.ordinal());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// enum 配合 Switch&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Direction&l;/span&g; &l;span class=\&q;variable\&q;&g;d&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; Direction.values()[(&l;span class=\&q;type\&q;&g;int&l;/span&g;)(Math.random()*&l;span class=\&q;number\&q;&g;4&l;/span&g;)];&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;switch&l;/span&g; (d) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;case&l;/span&g; E -&a;gt; System.out.println(&l;span class=\&q;string\&q;&g;&a;quot;EAST&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;case&l;/span&g; S -&a;gt; System.out.println(&l;span class=\&q;string\&q;&g;&a;quot;SOUTH&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;case&l;/span&g; W -&a;gt; System.out.println(&l;span class=\&q;string\&q;&g;&a;quot;WEST&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;case&l;/span&g; N -&a;gt; System.out.println(&l;span class=\&q;string\&q;&g;&a;quot;NORTH&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;default&l;/span&g; -&a;gt; System.out.println(&l;span class=\&q;string\&q;&g;&a;quot;error&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;enum&l;/span&g; &l;span class=\&q;title class_\&q;&g;Color&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;   R(&l;span class=\&q;string\&q;&g;&a;quot;RED&a;quot;&l;/span&g;, &l;span class=\&q;number\&q;&g;1&l;/span&g;), G(&l;span class=\&q;string\&q;&g;&a;quot;GREEN&a;quot;&l;/span&g;, &l;span class=\&q;number\&q;&g;2&l;/span&g;) , B(&l;span class=\&q;string\&q;&g;&a;quot;BLUE&a;quot;&l;/span&g;, &l;span class=\&q;number\&q;&g;3&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;   &l;span class=\&q;keyword\&q;&g;private&l;/span&g; String name;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;   &l;span class=\&q;keyword\&q;&g;private&l;/span&g; &l;span class=\&q;type\&q;&g;int&l;/span&g; idx;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;   &l;span class=\&q;keyword\&q;&g;private&l;/span&g; &l;span class=\&q;title function_\&q;&g;Color&l;/span&g;&l;span class=\&q;params\&q;&g;(String name, &l;span class=\&q;type\&q;&g;int&l;/span&g; idx)&l;/span&g; &a;#123; &l;span class=\&q;comment\&q;&g;// 构造方法只能 private, 通过枚举具体的类型创建&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;       &l;span class=\&q;built_in\&q;&g;this&l;/span&g;.name = name;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;       &l;span class=\&q;built_in\&q;&g;this&l;/span&g;.idx = idx;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;   &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;   &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; String &l;span class=\&q;title function_\&q;&g;getName&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;type\&q;&g;int&l;/span&g; idx)&l;/span&g; &a;#123;  &l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;       &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (Color c : Color.values())&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;           &l;span class=\&q;keyword\&q;&g;if&l;/span&g;(c.idx ==idx ) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;               &l;span class=\&q;keyword\&q;&g;return&l;/span&g; c.name;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;           &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;       &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;       &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;literal\&q;&g;null&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;   &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;   &l;span class=\&q;meta\&q;&g;@Override&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;   &l;span class=\&q;keyword\&q;&g;public&l;/span&g; String &l;span class=\&q;title function_\&q;&g;toString&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;       &l;span class=\&q;keyword\&q;&g;return&l;/span&g; idx + &l;span class=\&q;string\&q;&g;&a;quot; &a;quot;&l;/span&g; + name;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;   &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Color&l;/span&g; &l;span class=\&q;variable\&q;&g;c&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; Color.G;    &l;span class=\&q;comment\&q;&g;// 自动调用构造&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(c.toString());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h2 id=\&q;注解类型\&q;&g;注解类型&l;a title=\&q;#注解类型\&q; href=\&q;#注解类型\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;注解类型 (annotation type) 是 Java 5 新增的功能。注解以结构化的方式为程序元素提供信息，这些信息能够被外部工具(编译器、解释器等)自动处理.&l;br&g;\n注解有许多用途，其中包括：&l;/p&g;\n&l;ol&g;\n&l;li&g;为编译器提供信息。编译器可以使用注解检测错误或阻止编译警告。&l;/li&g;\n&l;li&g;编译时或部署时处理。软件工具可以处理注解信息生成代码、 XML 文件等。&l;/li&g;\n&l;li&g;运行时处理。有些注解在运行时可以被检查。&l;br&g;\n像使用类一样，要使用注解必须先定义注解类型(也可以使用语言本身提供的注解)&l;/li&g;\n&l;/ol&g;\n&l;p&g;&l;code&g;注解 (annotation)和注解类型 (annotation type)&l;/code&g;。注解类型是一种特殊的接口类型，注解是注解类型的一个实例。就像接口一样，注解类型也有名称和成员。注解中包含的信息采用“键/值”对的形式，可以有零或多个“键/值”对，并且每个键有一个特定类型。没有“键/值”对的注解类型称作&l;code&g;标记注解类(marker annotation type)&l;/code&g;。如果注解只需要一个“键/值”对，则称为&l;code&g;单值注解类型&l;/code&g;。&l;/p&g;\n&l;h3 id=\&q;标准注解\&q;&g;标准注解&l;a title=\&q;#标准注解\&q; href=\&q;#标准注解\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;Java语言规范中定义了3个注解类型，它们是供编译器使用的。这3个注解类型定义在java.lang包中，分别为&l;code&g;@Override、@Deprecated 和 @SuppressWarnings&l;/code&g;。&l;/p&g;\n&l;p&g;&l;code&g;Override&l;/code&g; :&l;br&g;\n是一个标记注解类型, 告诉编译器此方法要覆盖父类方法.&l;/p&g;\n&l;p&g;&l;code&g;Deprecate&l;/code&g;:&l;br&g;\n是一个标记注解类型，可以应用于某个方法或某个类型，指明方法或类型已被弃用。标记已被弃用的方法或类型，是为了警告其代码用户，不应该使用或覆盖该方法，或不该使用或扩展该类型。一个方法或类型被标记弃用通常是因为有了更好的方法或类型。当前的软件版本中保留这个被弃用的方法或类型是为了向后兼容。&l;/p&g;\n&l;p&g;&l;code&g;SuppressWarnings&l;/code&g;:&l;br&g;\n注解指示编译器阻止某些类型的警告，具体的警告类型可以用初始化该注解的字符串来定义。该注解可应用于类型、构造方法、方法、成员变量、参数以及局部变量。它的用法是传递一个 String数组，其中包含需要阻止的警告。&l;/p&g;\n&l;p&g;常用有效参数:&l;/p&g;\n&l;ul&g;\n&l;li&g;&l;code&g;unchecked  &l;/code&g;  未检查的转换警告。&l;/li&g;\n&l;li&g;&l;code&g;deprecation&l;/code&g; 使用了不推荐使用方法的警告。&l;/li&g;\n&l;li&g;&l;code&g;serial     &l;/code&g; 实现 Serializable 接口但没有定义 serialVersionUID 常量的警告。&l;/li&g;\n&l;li&g;&l;code&g;rawtypes   &l;/code&g; 如果使用旧的语法创建泛型类对象时发出的警告。&l;/li&g;\n&l;li&g;&l;code&g;finally    &l;/code&g;  任何 finally子句不能正常完成的警告。&l;/li&g;\n&l;li&g;&l;code&g;fallthrough&l;/code&g;    switch块中某个 case 后没有 break 语句的警告。&l;/li&g;\n&l;/ul&g;\n&l;h3 id=\&q;标准元注解\&q;&g;标准元注解&l;a title=\&q;#标准元注解\&q; href=\&q;#标准元注解\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;元注解 (meta annotation) 是对注解进行标注的注解。在java.lang.annotation包中定义Documented、Inherited、Retention 和 Target 四个元注解类型。&l;/p&g;\n&l;ol&g;\n&l;li&g;&l;code&g;Documented&l;/code&g;&l;br&g;\nDocumented是一种标记注解类型，用于对一个注解类型的声明进行标注，使该注解类型的实例包含在用javadoc 工具产生的文档中。&l;/li&g;\n&l;li&g;&l;code&g;Inherited&l;/code&g;&l;br&g;\n用 Inherited标注的注解类型的任何实例都会被继承。如果 Inherited标注一个类，那么注解将会被这个被标注类的所有子类继承。&l;/li&g;\n&l;li&g;&l;code&g;Retension&l;/code&g;&l;br&g;\nRetension 注解指明被标注的注解保留多长时间。 Retension 注解的值为 RetensionPolicy枚举的一个成员：&l;/li&g;\n&l;/ol&g;\n&l;ul&g;\n&l;li&g;&l;code&g;SOURCE&l;/code&g; 表示注解仅存于源文件中，注解将被编译器丢弃。&l;/li&g;\n&l;li&g;&l;code&g;CLASS&l;/code&g; 表示注解将保存在类文件中，但不被JVM保存的注解，是默认值。&l;/li&g;\n&l;li&g;&l;code&g;RUNTIME&l;/code&g; 表示要被JVM保存的注解，在运行时可以利用反射机制查询&l;/li&g;\n&l;/ul&g;\n&l;ol start=\&q;4\&q;&g;\n&l;li&g;&l;code&g;Target&l;/code&g;&l;br&g;\nTarget注解用来指明哪个(些)程序元素可以利用被标注的注解类型进行标注。 Target的值为java.lang.annotation.ElementType枚举的一个成员：&l;/li&g;\n&l;/ol&g;\n&l;ul&g;\n&l;li&g;&l;code&g;ANNOTATION_TYPE&l;/code&g;  可以对注解类型标注。&l;/li&g;\n&l;li&g;&l;code&g;CONSTRUCTOR&l;/code&g;  可以对构造方法进行标注。&l;/li&g;\n&l;li&g;&l;code&g;FIELD&l;/code&g; 可以对成员的声明进行标注。&l;/li&g;\n&l;li&g;&l;code&g;LOCAL_VARIABLE&l;/code&g;  可以对局部变量进行标注。&l;/li&g;\n&l;li&g;&l;code&g;METHOD&l;/code&g;  可以对方法进行标注。&l;/li&g;\n&l;li&g;&l;code&g;PACKAGE&l;/code&g;  可以对包进行标注。&l;/li&g;\n&l;li&g;&l;code&g;PARAMETER&l;/code&g;  可以对参数声明进行标注。&l;/li&g;\n&l;li&g;&l;code&g;TYPE&l;/code&g;  可以对类型声明进行标注&l;/li&g;\n&l;/ul&g;\n&l;p&g;如Override 注解类型使用了 Target 注解标注，使得 Override 只适用于方法声明.&l;br&g;\nSuppressWarnings 注解类型的声明&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;meta\&q;&g;@Target&l;/span&g; (value=&a;#123;TYPE,FIELD,METHOD,PARAMETER, CONSTRUCTOR,LOCAL_VARIABLE&a;#125;)&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;meta\&q;&g;@Retention(value=SOURCE)&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;meta\&q;&g;@interface&l;/span&g; SuppressWarnings&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;定义注解\&q;&g;定义注解&l;a title=\&q;#定义注解\&q; href=\&q;#定义注解\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;默认情况下，所有的注解类型都扩展了java.lang.annotation.Annotation接口。该接口定义一个返回Class对象的 annotationType()方法 &l;code&g;Class &a;lt;?extends Annotation&a;gt; annotationType()&l;/code&g;, 该接口还定义了equals()方法、hashCode()方法和toString()方法。&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;meta\&q;&g;@Retention(RetentionPolicy.RUNTIME)&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;meta\&q;&g;@Target(ElementType.METHOD)&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;meta\&q;&g;@interface&l;/span&g; MyAnnotation &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    String &l;span class=\&q;title function_\&q;&g;value&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;MyClass1&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;meta\&q;&g;@MyAnnotation(value = &a;quot;Hello, World!&a;quot;)&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;myMethod&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// do something&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &l;span class=\&q;keyword\&q;&g;throws&l;/span&g; NoSuchMethodException &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;MyClass1&l;/span&g; &l;span class=\&q;variable\&q;&g;obj&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;MyClass1&l;/span&g;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Method&l;/span&g; &l;span class=\&q;variable\&q;&g;method&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; obj.getClass().getMethod(&l;span class=\&q;string\&q;&g;&a;quot;myMethod&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;MyAnnotation&l;/span&g; &l;span class=\&q;variable\&q;&g;annotation&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; method.getAnnotation(MyAnnotation.class);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;String&l;/span&g; &l;span class=\&q;variable\&q;&g;value&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; annotation.value();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(value);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;在注解类型中声明的方法称为注解类型的元素，它的声明类似于接口中的方法声明，没有方法体，但有返回类型。元素的类型有一些限制，如只能是基本类型、String、枚举类型、其他注解类型等，并且元素不能声明任何参数。&l;br&g;\n实际上，注解类型的元素就像对象的域一样，所有应用该注解类型的程序元素都要对这些域实例化。这些域的值是在应用注解时由初始化器决定，或由元素的默认值决定。&l;br&g;\n在定义注解时可以使用 default 关键字为元素指定默认值。&l;/p&g;\n&l;p&g;javaxjws 包中定义了一些用来创建 Web 服务的注解类型，在 javax.xml.ws包和 javax.xml.bind.annotation 包中也定义了许多注解类型。注解类型在 Java Web 开发和Java EE 开发中被广泛使用.&l;/p&g;\n&l;p&g;&l;strong&g;参考&l;/strong&g;&l;/p&g;\n&l;ol&g;\n&l;li&g;《Java程序设计(第3版)》 IBSN 9787302485520&l;/li&g;\n&l;li&g;&l;a href=\&q;https://docs.oracle.com/en/java/javase/19/docs/api/index.html\&q; target=\&q;_blank\&q;&g;Java API 文档&l;/a&g;&l;/li&g;\n&l;li&g;&l;a href=\&q;https://blog.csdn.net/qq_52348926/article/details/129478117#:~:text=hashCode%20%28%29%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E8%AE%A1%E7%AE%97%E5%93%88%E5%B8%8C%E7%A0%81%E5%80%BC%EF%BC%8C%E8%80%8Cequals%20%28%29%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E6%80%A7%E3%80%82%20%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%20%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%93%88%E5%B8%8C%E7%A0%81%E5%80%BC%E7%9B%B8%E5%90%8C,%EF%BC%8C%20%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%84%8F%E5%91%B3%E7%9D%80%E5%AE%83%E4%BB%AC%E6%98%AF%E7%9B%B8%E7%AD%89%E7%9A%84%20%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%20%EF%BC%8C%E5%8D%B3%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E8%83%BD%E7%94%9F%E6%88%90%E7%9B%B8%E5%90%8C%E7%9A%84%E5%93%88%E5%B8%8C%E7%A0%81%E5%80%BC%E3%80%82\&q; target=\&q;_blank\&q;&g;Hash值的理解，Java中hashCode()和equals究竟有什么用？&l;/a&g;&l;/li&g;\n&l;/ol&g;\n&q;,&q;prev&q;:{&q;title&q;:&q;[Java笔记]接口&a;Lambda表达式&q;,&q;link&q;:&q;2023/05/10/[Java笔记]接口&a;Lambda表达式&q;},&q;next&q;:{&q;title&q;:&q;[Java笔记]继承&a;多态&q;,&q;link&q;:&q;2023/05/09/[Java笔记]继承&a;多态&q;},&q;plink&q;:&q;https://s1acr.github.io/2023/05/09/[Java笔记]常用核心类内部类枚举注解/&q;,&q;toc&q;:[{&q;id&q;:&q;object&q;,&q;title&q;:&q;Object&q;,&q;index&q;:&q;1&q;},{&q;id&q;:&q;math&q;,&q;title&q;:&q;Math&q;,&q;index&q;:&q;2&q;},{&q;id&q;:&q;基本类型包装类&q;,&q;title&q;:&q;基本类型包装类&q;,&q;index&q;:&q;3&q;,&q;children&q;:[{&q;id&q;:&q;character&q;,&q;title&q;:&q;Character&q;,&q;index&q;:&q;3.1&q;},{&q;id&q;:&q;boolean&q;,&q;title&q;:&q;Boolean&q;,&q;index&q;:&q;3.2&q;},{&q;id&q;:&q;数值类对象&q;,&q;title&q;:&q;数值类对象&q;,&q;index&q;:&q;3.3&q;},{&q;id&q;:&q;自动装箱与自动拆箱&q;,&q;title&q;:&q;自动装箱与自动拆箱&q;,&q;index&q;:&q;3.4&q;},{&q;id&q;:&q;字符串与基本数据类型转化&q;,&q;title&q;:&q;字符串与基本数据类型转化&q;,&q;index&q;:&q;3.5&q;}]},{&q;id&q;:&q;biginteger-bigdecimal&q;,&q;title&q;:&q;BigInteger BigDecimal&q;,&q;index&q;:&q;4&q;},{&q;id&q;:&q;时间日期api&q;,&q;title&q;:&q;时间日期API&q;,&q;index&q;:&q;5&q;},{&q;id&q;:&q;内部类&q;,&q;title&q;:&q;内部类&q;,&q;index&q;:&q;6&q;,&q;children&q;:[{&q;id&q;:&q;内部成员类&q;,&q;title&q;:&q;内部成员类&q;,&q;index&q;:&q;6.1&q;},{&q;id&q;:&q;局部内部类&q;,&q;title&q;:&q;局部内部类&q;,&q;index&q;:&q;6.2&q;},{&q;id&q;:&q;匿名内部类&q;,&q;title&q;:&q;匿名内部类&q;,&q;index&q;:&q;6.3&q;},{&q;id&q;:&q;静态内部类&q;,&q;title&q;:&q;静态内部类&q;,&q;index&q;:&q;6.4&q;}]},{&q;id&q;:&q;枚举类型&q;,&q;title&q;:&q;枚举类型&q;,&q;index&q;:&q;7&q;},{&q;id&q;:&q;注解类型&q;,&q;title&q;:&q;注解类型&q;,&q;index&q;:&q;8&q;,&q;children&q;:[{&q;id&q;:&q;标准注解&q;,&q;title&q;:&q;标准注解&q;,&q;index&q;:&q;8.1&q;},{&q;id&q;:&q;标准元注解&q;,&q;title&q;:&q;标准元注解&q;,&q;index&q;:&q;8.2&q;},{&q;id&q;:&q;定义注解&q;,&q;title&q;:&q;定义注解&q;,&q;index&q;:&q;8.3&q;}]}],&q;reward&q;:true,&q;copyright&q;:{&q;author&q;:&q;slacr_&q;,&q;license&q;:&q;&l;a href=\&q;https://creativecommons.org/licenses/by-nc-sa/4.0/\&q; target=\&q;_blank\&q;&g;&l;img src = \&q;/lib/cc-by-nc-sa.svg\&q;&g;CC BY-NC-ND 4.0&l;/a&g;&q;,&q;published&q;:&q;May 9, 2023&q;,&q;updated&q;:&q;May 9, 2023&q;},&q;reading_time&q;:&q;5144 words in 34 min&q;}}</script></head>
<body lang="en"><!-- hexo injector body_begin start --><is-a class="φh" ng-version="12.1.0"><is-k class="φcu"><div class="φdg"><section class="φdh"><header class="φcv"><i class="φda"></i><!----><div issnippet="" class="φcx"><img src="https://thirdqq.qlogo.cn/g?b=oidb&amp;k=ia9j8LGcEXYic3XyY1h1ibnxg&amp;s=0&amp;rand=1680719837">
</div><!----><!----><a href="" class="φcz">slacr_</a><p class="φcy">Crap Programmer, College Student From CN. Idealist and Minimalism, life-long learner. I was lucky to find out what I truly have passion for. 🚬.</p></header><div class="φdl"><a routerlink="/archives" class="φdm" href="/archives"><span>57</span><span>Archives</span></a><a class="φdm" href="/categories/C"><span>16</span><span>Categories</span></a><!----><a routerlink="/tags" class="φdm" href="/tags"><span>3</span><span>Tags</span></a><!----></div><!----><nav class="φdi"><a class="φdj" href="/">Home</a><!----><!----><!----><a class="φdj" href="/search">Search</a><!----><!----><!----><a class="φdj" href="/link">Link</a><!----><!----><!----><a class="φdj" href="/log">Log</a><!----><!----><!----><!----></nav><!----><div issnippet="" class="φb"><is-palette col="5" theme="#673ab7,#3f51b5,#2196f3,#009688,#4caf50,#ff9800,#ff5722,#795548,#607D8B,#2a2b33"></is-palette></div><div issnippet="" class="φb">
</div><div issnippet="" class="φb">
</div><div issnippet="" class="φb">
</div><!----><!----><!----></section><footer class="φdb φdc"><div class="φde"><!----><a target="_blank" rel="external nofollow noopener" class="φdf" title="email me" href="mailto:diogocdiogocosta3346@gmail.com"><i class="iκ-email"></i></a><!----><!----><!----><a target="_blank" rel="external nofollow noopener" class="φdf" title="Feed" href="/atom.xml"><i class="iκ-feed"></i></a><!----><!----><!----><a target="_blank" rel="external nofollow noopener" class="φdf" title="github" href="https://github.com/s1acr"><i class="iκ-github"></i></a><!----><!----><!----><a target="_blank" rel="external nofollow noopener" class="φdf" title="qqGroup" href="https://qm.qq.com/cgi-bin/qm/qr?k=CwUa3gRbNtBAJRLHVwFiM4KZBiuqBSk9&amp;jump_from=webapi&amp;authKey=FhTodgrqXmM0pc0x/fT1U9yAtc6yJlWqoc5qnT5QepMGdVuCUxRlmY3bGklQd7fW"><i class="iκ-qq"></i></a><!----><!----><!----></div><!----><p class="φe">© 2023 <span id="sunflowerArea"><span id="sunflower">🌻</span> <a id="mySign" href="javascript:;"> Slacr F</a></span></p><!----><!----><p class="φe"><span id="busuanzi_container_site_uv" style="display:none">Total <b><span id="busuanzi_value_site_uv"></span></b> Visitors </span><span id="busuanzi_container_site_pv" style="display:none"><b><span id="busuanzi_value_site_pv"></span></b> Views</span><br> Hosted by <a target="_blank" rel="external nofollow" href="https://pages.github.com/"><b>Github Pages</b></a></p><!----></footer></div></is-k><div class="φj"><div class="φi"><div class="φn"><main class="φm"><router-outlet></router-outlet><is-r class="φet"><header class="φfd φfe" style="background-image:;background-color:;"><div class="φfm"><h1 class="φfp">[Java笔记]常用核心类内部类枚举注解</h1><!----><p class="φff"><span class="φfg φfk">May 9, 2023</span><a class="φfg φfi" href="/categories/Java">Java</a><!----><span class="φfg φfj">5144 words in 34 min</span><!----><!----></p><!----><!----></div></header><article itemscope="" itemtype="http://schema.org/Article" class="φew" data-title="[Java笔记]常用核心类内部类枚举注解"><div itemprop="articleBody" issnippet="" iszoomable="" class="φe"><blockquote>
<p>Java 笔记</p>
</blockquote>
<h2 id="object">Object<a title="#object" href="#object"></a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305092218740.png" alt="" loading="lazy" class="φbp"></p>
<p><code>toString()</code><br>
调用对象的 toString()方法可以返回对象的字符串表示toCast. 该方法在Object类中的定义是返回包名.类名@一个十六进制整数. 如 Father@4f3f5b24. 输出函数传入类的实例默认调用. Java 类库中，有许多类覆盖了 toString()方法，输出时能够得到可理解的结果.</p>
<p><code>equals()</code><br>
比较两个对象是否相等, 比较的是对象的引用. 在Java类库中的许多类也覆盖了该方法，如String类。因此，对String对象使用equals()方法的比较是字符串的内容是否相等。<br>
在子类中，使用签名equals(ClassName obj)覆盖 equals()方法是一个常见的错误，应该使用 equals (Object obj) 覆盖 equals()方法.</p>
<p><code>hashCode()</code><br>
hashCode()方法返回一个对象的哈希码 (hash code) 值，它是一个整数，主要用来比较对象的大小。在Object类中hashCode()方法的实现是返回对象在计算机内部存储的十进制内存地址.<br>
hashCode()方法和 equals()方法必须是兼容的，如果你为一个类覆盖了equals()方法，则也需要覆盖hashCode()方法，以兼容equals()方法<br>
java.util.Objects类的 hash()方法的参数是可变参数，该方法计算每个参数的哈希码，并将它们组合起来。这个方法是空指针安全的。<br>
如果类包含数组类型的实例变量，比较它们的哈希码时，首先使用静态方法Arrays.hashCode()计算数组的每个元素哈希码组成的哈希码，然后将结果传给 Objects 的hash()方法.</p>
<p><code>clone()</code><br>
使用 Object类的 clone()方法可以克隆一个对象，即创建一个对象的副本。要使类的对象能够克隆，类必须实现Cloneable接口.<br>
使用 Object类继承的 clone()方法克隆对象只是做了浅拷贝。它简单地从原对象中复制所有实例变量到目标对象中。如果实例变量是基本类型或不变对象(如String), 将没有问题；否则，原对象和克隆对象将共享可变的状态。</p>
<p><code>finalize()</code><br>
每个对象都有一个 finalize()方法。在对象被销毁之前，<code>垃圾回收器允许对象调用该方法进行清理工作，这个过程称为对象终结 (finalization)</code>。 格式为 <code>protected void finalize() throws Throwable</code></p>
<h2 id="math">Math<a title="#math" href="#math"></a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305101332456.png" alt="" loading="lazy" class="φbp"></p>
<h2 id="基本类型包装类">基本类型包装类<a title="#基本类型包装类" href="#基本类型包装类"></a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305101341697.png" alt="" loading="lazy" class="φbp"></p>
<h3 id="character">Character<a title="#character" href="#character"></a></h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Character</span> <span class="variable">c_1</span> <span class="operator">=</span> (<span class="string">'A'</span>);</span><br><span class="line">        <span class="type">Character</span> <span class="variable">c_2</span> <span class="operator">=</span> (<span class="string">'$'</span>);</span><br><span class="line">        <span class="type">Character</span> <span class="variable">c_3</span> <span class="operator">=</span> (<span class="string">'简'</span>);</span><br><span class="line">        System.out.println(c_1.compareTo(<span class="string">'D'</span>));  <span class="comment">// -3</span></span><br><span class="line">        System.out.println(c_2.charValue());       <span class="comment">// $</span></span><br><span class="line">        System.out.println(c_3.isLetter(<span class="string">'简'</span>));  <span class="comment">// true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>常用方法:</p>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public char charValue() </code></td>
<td style="text-align:left">返回 Character 对象所包含的 char值。</td>
</tr>
<tr>
<td style="text-align:left"><code>public int compareTo(Character anotherChar) </code></td>
<td style="text-align:left">比较两个字符对象。如果该字符对象与参数字符对象相等，返回0;若小于参数字符，返回值小于0;若大于参数字符，则返回值大于0。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static boolean isDigit(char ch)</code></td>
<td style="text-align:left">返回参数字符是否是数字。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static boolean isLetter(char ch)</code></td>
<td style="text-align:left">返回参数字符是否是字母。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static boolean isLowerCase(char ch)</code></td>
<td style="text-align:left">返回参数字符是否是小写字母。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static boolean isUpperCase(char ch)</code></td>
<td style="text-align:left">返回参数字符是否是大写字母。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static boolean isWhiteSpace(char ch)</code></td>
<td style="text-align:left">返回参数字符是否是空白字符。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static char toLowerCase(char ch)</code></td>
<td style="text-align:left">将参数字符转换为小写字母返回。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static char toUpperCase(char ch)</code></td>
<td style="text-align:left">将参数字符转换为大写字母返回。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static boolean isJavaIdentifierStart(char ch) </code></td>
<td style="text-align:left">返回参数字符是否允许作为 Java标识符的开头字符。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static boolean isJavaldentifierPart (char ch) </code></td>
<td style="text-align:left">返回参数字符是否允许作为 Java标识符的中间字符。</td>
</tr>
</tbody>
</table></div></div><h3 id="boolean">Boolean<a title="#boolean" href="#boolean"></a></h3>
<p>常用方法:</p>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public Boolean(boolean value)</code></td>
<td style="text-align:left">用一个boolean型值创建一个Boolean对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>public Boolean(String s)</code></td>
<td style="text-align:left">用一个字符串创建Boolean对象。如果字符串 s不为 null 且其值为 “true”(不区分大小写)就创建一个true值，否则创建一个 false值。</td>
</tr>
<tr>
<td style="text-align:left"><code>public boolean booleanValue()</code></td>
<td style="text-align:left">返回该Boolean 对象所封装的 boolean值。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static boolean parseBoolean(String s)</code></td>
<td style="text-align:left">将参数s解析为一个 boolean 值。如果参数不为 null 且等于 “true”(不区分大小写),则返回true, 否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static Boolean valueOf(boolean b)</code></td>
<td style="text-align:left">将参数b 的值转换为 Boolean 对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static Boolean valueOf(String s)</code></td>
<td style="text-align:left">将参数s 的值转换为 Boolean对象。</td>
</tr>
</tbody>
</table></div></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(b);               <span class="comment">// false</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">"TruE"</span>);      <span class="comment">// true , 这两个方法已经不支持, 将要移除</span></span><br><span class="line">        System.out.println(b_1);</span><br><span class="line">        System.out.println(b_2);</span><br><span class="line">        System.out.println(b_1.booleanValue());  <span class="comment">// false</span></span><br><span class="line">        System.out.println(Boolean.parseBoolean(<span class="string">"True"</span>));     <span class="comment">// true</span></span><br><span class="line">        System.out.println(Boolean.valueOf(b).booleanValue());   <span class="comment">// false</span></span><br><span class="line">        System.out.println(Boolean.valueOf(<span class="string">"OK"</span>)); <span class="comment">// false</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数值类对象">数值类对象<a title="#数值类对象" href="#数值类对象"></a></h3>
<p>常用方法:</p>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public Integer(int value) </code></td>
<td style="text-align:left">使用 int类型的值创建包装类型 Integer对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>public Integer(String s) </code></td>
<td style="text-align:left">使用字符串构造Integer对象，如果字符串不能转换成相应的数值，则抛出NumberFormatException异常</td>
</tr>
<tr>
<td style="text-align:left"><code>public static String toBinaryString(int i)</code></td>
<td style="text-align:left">返回整数i用字符串表示的二进制序列。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static String toHexString(int i) </code></td>
<td style="text-align:left">返回整数i用字符串表示的十六进制序列。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static String toOctalString(int i) </code></td>
<td style="text-align:left">返回整数 i用字符串表示的八进制序列。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static int highestOneBit(int i) </code></td>
<td style="text-align:left">返回整数i的二进制补码的最高位1所表示的十进制数，如7(111)的最高位的1表示的值为4。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static int lowestOneBit(int i)</code></td>
<td style="text-align:left">返回整数 i的二进制补码的最低位1所表示的十进制数，如10(1010)的最低位的1表示的值为2。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static int reverse(int i) </code></td>
<td style="text-align:left">返回将整数i的二进制序列反转后的整数值。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static int signum(inti)</code></td>
<td style="text-align:left">返回整数i的符号。若 i大于0,返回1;若 i等于0,</td>
</tr>
<tr>
<td style="text-align:left">返回0,若 i小于0则返回-1。</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table></div></div><p>每种包装类型都覆盖了toString()方法和 equals()方法，因此使用 equals()方法比较包装类型的对象时是比较内容或所包装值.每种包装类型的对象中所包装的值是不可改变的，要改变对象中的值必须重新生成新的对象.</p>
<p>每个数值包装类都定义了 <code>SIZE、BYTES、MAX_VALUE、MIN_VALUE </code>常量。<br>
SIZE 表示每种类型的数据所占的位数<br>
BYTES 表示数据所占的字节数<br>
MAX_VALUE 表示对应基本类型数据的最大值.<br>
对于Byte、Short、Integer和Long 来说，MIN_VALUE 表示类型的最小值。对 Float和 Double 来说，MIN_VALUE 最小正值。<br>
除了上面的常量外，在 Float 和 Double 类中还分别定义了 POSITIVE_INFINITY、NEGATIVE INFINITY、NaN(not a number), 它们分别表示正、负无穷大和非数值。</p>
<h3 id="自动装箱与自动拆箱">自动装箱与自动拆箱<a title="#自动装箱与自动拆箱" href="#自动装箱与自动拆箱"></a></h3>
<p>Java 5 版提供了一种新的功能，称为自动装箱和自动拆箱。自动装箱 (autoboxing) 是指基本类型的数据可以自动转换为包装类的实例，自动拆箱 (unboxing) 是指包装类的实例自动转换为基本类型的数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">300</span>;   <span class="comment">// auto boxing</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i_1</span> <span class="operator">=</span> i;        <span class="comment">// auto unboxing</span></span><br><span class="line">        System.out.println(((Integer)i_1).toString()); <span class="comment">// 强制转换</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="字符串与基本数据类型转化">字符串与基本数据类型转化<a title="#字符串与基本数据类型转化" href="#字符串与基本数据类型转化"></a></h3>
<p><code>public static Type parse{Type}(String s)</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(Integer.parseInt(s));  <span class="comment">// 字符串转基本类型</span></span><br><span class="line">        System.out.println(Double.parseDouble(s));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(String.valueOf(i) <span class="keyword">instanceof</span>  String); <span class="comment">// 基本类型转字符串</span></span><br><span class="line">        System.out.println(((Integer)i).toString());   <span class="comment">// 或者通过包装类的toString()方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="biginteger-bigdecimal">BigInteger BigDecimal<a title="#biginteger-bigdecimal" href="#biginteger-bigdecimal"></a></h2>
<p>如果在计算中需要非常大的整数或非常高精度的浮点数，可以使用java.math 包中定义的BigInteger类和 BigDecimal类。这两个类都扩展了Number类并实现了Comparable 接口，它们的实例都是不可变的.</p>
<p><a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/math/BigInteger.html" target="_blank">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/math/BigInteger.html</a></p>
<h2 id="时间日期api">时间日期API<a title="#时间日期api" href="#时间日期api"></a></h2>
<p>java.time<br>
<a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/time/package-summary.html" target="_blank">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/time/package-summary.html</a></p>
<h2 id="内部类">内部类<a title="#内部类" href="#内部类"></a></h2>
<p>Java 语言允许在一个类的内部定义另一个类(接口、枚举或注解),这种类称为内部类 (inner class)或嵌套类 (nested class)<br>
使用内部类的优点：对只在一处使用的类进行分组；提高封装性；增强代码的可读性和可维护性。<br>
有多种类型的内部类，大致可分为<code>成员内部类、局部内部类、匿名内部类和静态内部类</code>。</p>
<h3 id="内部成员类">内部成员类<a title="#内部成员类" href="#内部成员类"></a></h3>
<p>成员内部类没有用 static修饰且定义在外层类的类体中</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> {   <span class="comment">// 内部类相当于成员, 可以访问外部内所有成员</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">i</span> <span class="operator">=</span> o.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();   <span class="comment">// 创建内部类</span></span><br><span class="line"></span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>().<span class="keyword">new</span> <span class="title class_">InnerClass</span>();  <span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">        System.out.println(ii.add()); <span class="comment">// 3</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用成员内部类时需要注意下面几个问题：</p>
<ol>
<li>成员内部类中不能定义 static变量和 static方法。</li>
<li>成员内部类也可以使用 abstract和 final修饰，其含义与其他类一样。</li>
<li>成员内部类还可以使用 private、public、protected或包可访问修饰符。</li>
</ol>
<h3 id="局部内部类">局部内部类<a title="#局部内部类" href="#局部内部类"></a></h3>
<p>可以在方法体或语句块内定义类。在方法体或语句块 (包括方法、构造方法、局部块、初始化块或静态初始化块)内部定义的类称为局部内部类 (local inner class)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeInner</span><span class="params">(<span class="type">int</span> p)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">"local_variable"</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerClass</span>{</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seekOuter</span><span class="params">()</span> {</span><br><span class="line">                System.out.println(x);</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                System.out.println(p);</span><br><span class="line">            }</span><br><span class="line">        }       <span class="comment">// 此局部类只在这个函数中有效</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InnerClass</span>().seekOuter();       <span class="comment">// 创建对象调用方法</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        o.makeInner(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        <span class="comment">//local_variable</span></span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="匿名内部类">匿名内部类<a title="#匿名内部类" href="#匿名内部类"></a></h3>
<p>定义类最终目的是创建一个类的实例，但如果某个类的实例只使用一次，可以将类的定义和实例的创建在一起完成，或者说在定义类的同时就创建一个实例。以这种方式定义的没有名字的类称为匿名内部类 (anonymous inner class)。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">"slacr"</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 匿名对象继承 Person, 初始化同时定义</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">hero</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(){</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> String <span class="title function_">work</span><span class="params">()</span> {</span><br><span class="line">              <span class="keyword">return</span> <span class="string">"punish evil-doers"</span>;</span><br><span class="line">          }</span><br><span class="line">        };</span><br><span class="line">        System.out.println(<span class="string">"Hero "</span> + hero.name + <span class="string">", I will "</span> + hero.work());</span><br><span class="line">        <span class="comment">// Hero slacr, I will punish evil-doers</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>匿名内部类可以继承一个类或实现一个接口, 如果实现一个接口，该类是Object类的直接子类。匿名类继承一个类或<br>
实现一个接口不需要使用 extends 或 implements 关键字。匿名内部类不能同时继承一个类和实现一个接口，也不能实现多个接口<br>
匿名内部类的一个重要应用是编写 JavaFX 图形界面的事件处理程序。如为按钮对象button 注册事件处理器，就可以使用匿名内部类。</p>
<h3 id="静态内部类">静态内部类<a title="#静态内部类" href="#静态内部类"></a></h3>
<p>静态内部类使用 static修饰，静态内部类也称嵌套类 (nested class)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> {</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">OuterClass</span>().getClass().getSimpleName());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">class</span> <span class="title class_">InnerClass</span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">            outer();</span><br><span class="line">            System.out.println(x);      <span class="comment">// 可以访问外部静态成员方法和变量</span></span><br><span class="line">            System.out.println(y);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>.InnerClass();</span><br><span class="line">        <span class="comment">// 不需要外层实例就可以直接创建一个静态内部实例</span></span><br><span class="line">        i.test();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="枚举类型">枚举类型<a title="#枚举类型" href="#枚举类型"></a></h2>
<p>枚举类型是一种特殊的引用类型，它的声明和使用与类和接口有类似的地方。它可以作为顶层的类型声明，也可以像内部类一样在其他类的内部声明，但不能在方法内部声明枚举。</p>
<p>任何枚举类型都隐含地继承了java.lang.Enum抽象类，Enum类又是Object类的子类，同时实现了 Comparable 接口和 Serializable接口。每个枚举类型都包含了若干方法，下面是一些常用的</p>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public static E[] values()</code></td>
<td style="text-align:left">返回一个包含所有枚举常量的数组，这些枚举常量在数组中是按照它们的声明顺序存储的。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static E valueOf(String name)</code></td>
<td style="text-align:left">返回指定名字的枚举常量。如果这个名字与任何一个枚举常量的名字都不能精确匹配，将抛出 IlegalArgumentException 异常。</td>
</tr>
<tr>
<td style="text-align:left"><code>public final int compareTo(Eo)</code></td>
<td style="text-align:left">返回当前枚举对象与参数枚举对象的比较结果。</td>
</tr>
<tr>
<td style="text-align:left"><code>public final Class&lt;E&gt; getDeclaringClass()</code></td>
<td style="text-align:left">返回对应该枚举常量的枚举类型的类对象。两个枚举常量 el、e2, 当且仅当 el.getDeclaringClass() == e2.getDeclaringClass()时，这两个枚举常量类型相同。</td>
</tr>
<tr>
<td style="text-align:left"><code>public final String name()</code></td>
<td style="text-align:left">返回枚举常量名。</td>
</tr>
<tr>
<td style="text-align:left"><code>public final int ordinal()</code></td>
<td style="text-align:left">返回枚举常量的顺序值，该值是基于常量声明的顺序的，第一个常量的顺序值是0,第二个常量的顺序值为1,依次类推。</td>
</tr>
<tr>
<td style="text-align:left"><code>public String toString()</code></td>
<td style="text-align:left">返回枚举常量名。</td>
</tr>
</tbody>
</table></div></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Direction</span> <span class="variable">left</span> <span class="operator">=</span> Direction.W;</span><br><span class="line">        System.out.println(left);</span><br><span class="line">        <span class="keyword">for</span> ( Direction d : Direction.values()) {    <span class="comment">// values() 是一个包含枚举常量的数组</span></span><br><span class="line">            System.out.println(d.name() + <span class="string">" "</span> + d.ordinal());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// enum 配合 Switch</span></span><br><span class="line">        <span class="type">Direction</span> <span class="variable">d</span> <span class="operator">=</span> Direction.values()[(<span class="type">int</span>)(Math.random()*<span class="number">4</span>)];</span><br><span class="line">        <span class="keyword">switch</span> (d) {</span><br><span class="line">            <span class="keyword">case</span> E -&gt; System.out.println(<span class="string">"EAST"</span>);</span><br><span class="line">            <span class="keyword">case</span> S -&gt; System.out.println(<span class="string">"SOUTH"</span>);</span><br><span class="line">            <span class="keyword">case</span> W -&gt; System.out.println(<span class="string">"WEST"</span>);</span><br><span class="line">            <span class="keyword">case</span> N -&gt; System.out.println(<span class="string">"NORTH"</span>);</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">"error"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> {</span><br><span class="line">   R(<span class="string">"RED"</span>, <span class="number">1</span>), G(<span class="string">"GREEN"</span>, <span class="number">2</span>) , B(<span class="string">"BLUE"</span>, <span class="number">3</span>);</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> idx;</span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Color</span><span class="params">(String name, <span class="type">int</span> idx)</span> { <span class="comment">// 构造方法只能 private, 通过枚举具体的类型创建</span></span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">       <span class="built_in">this</span>.idx = idx;</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">(<span class="type">int</span> idx)</span> {  </span><br><span class="line">       <span class="keyword">for</span> (Color c : Color.values()){</span><br><span class="line">           <span class="keyword">if</span>(c.idx ==idx ) {</span><br><span class="line">               <span class="keyword">return</span> c.name;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   }</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">       <span class="keyword">return</span> idx + <span class="string">" "</span> + name;</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Color</span> <span class="variable">c</span> <span class="operator">=</span> Color.G;    <span class="comment">// 自动调用构造</span></span><br><span class="line">        System.out.println(c.toString());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="注解类型">注解类型<a title="#注解类型" href="#注解类型"></a></h2>
<p>注解类型 (annotation type) 是 Java 5 新增的功能。注解以结构化的方式为程序元素提供信息，这些信息能够被外部工具(编译器、解释器等)自动处理.<br>
注解有许多用途，其中包括：</p>
<ol>
<li>为编译器提供信息。编译器可以使用注解检测错误或阻止编译警告。</li>
<li>编译时或部署时处理。软件工具可以处理注解信息生成代码、 XML 文件等。</li>
<li>运行时处理。有些注解在运行时可以被检查。<br>
像使用类一样，要使用注解必须先定义注解类型(也可以使用语言本身提供的注解)</li>
</ol>
<p><code>注解 (annotation)和注解类型 (annotation type)</code>。注解类型是一种特殊的接口类型，注解是注解类型的一个实例。就像接口一样，注解类型也有名称和成员。注解中包含的信息采用“键/值”对的形式，可以有零或多个“键/值”对，并且每个键有一个特定类型。没有“键/值”对的注解类型称作<code>标记注解类(marker annotation type)</code>。如果注解只需要一个“键/值”对，则称为<code>单值注解类型</code>。</p>
<h3 id="标准注解">标准注解<a title="#标准注解" href="#标准注解"></a></h3>
<p>Java语言规范中定义了3个注解类型，它们是供编译器使用的。这3个注解类型定义在java.lang包中，分别为<code>@Override、@Deprecated 和 @SuppressWarnings</code>。</p>
<p><code>Override</code> :<br>
是一个标记注解类型, 告诉编译器此方法要覆盖父类方法.</p>
<p><code>Deprecate</code>:<br>
是一个标记注解类型，可以应用于某个方法或某个类型，指明方法或类型已被弃用。标记已被弃用的方法或类型，是为了警告其代码用户，不应该使用或覆盖该方法，或不该使用或扩展该类型。一个方法或类型被标记弃用通常是因为有了更好的方法或类型。当前的软件版本中保留这个被弃用的方法或类型是为了向后兼容。</p>
<p><code>SuppressWarnings</code>:<br>
注解指示编译器阻止某些类型的警告，具体的警告类型可以用初始化该注解的字符串来定义。该注解可应用于类型、构造方法、方法、成员变量、参数以及局部变量。它的用法是传递一个 String数组，其中包含需要阻止的警告。</p>
<p>常用有效参数:</p>
<ul>
<li><code>unchecked  </code>  未检查的转换警告。</li>
<li><code>deprecation</code> 使用了不推荐使用方法的警告。</li>
<li><code>serial     </code> 实现 Serializable 接口但没有定义 serialVersionUID 常量的警告。</li>
<li><code>rawtypes   </code> 如果使用旧的语法创建泛型类对象时发出的警告。</li>
<li><code>finally    </code>  任何 finally子句不能正常完成的警告。</li>
<li><code>fallthrough</code>    switch块中某个 case 后没有 break 语句的警告。</li>
</ul>
<h3 id="标准元注解">标准元注解<a title="#标准元注解" href="#标准元注解"></a></h3>
<p>元注解 (meta annotation) 是对注解进行标注的注解。在java.lang.annotation包中定义Documented、Inherited、Retention 和 Target 四个元注解类型。</p>
<ol>
<li><code>Documented</code><br>
Documented是一种标记注解类型，用于对一个注解类型的声明进行标注，使该注解类型的实例包含在用javadoc 工具产生的文档中。</li>
<li><code>Inherited</code><br>
用 Inherited标注的注解类型的任何实例都会被继承。如果 Inherited标注一个类，那么注解将会被这个被标注类的所有子类继承。</li>
<li><code>Retension</code><br>
Retension 注解指明被标注的注解保留多长时间。 Retension 注解的值为 RetensionPolicy枚举的一个成员：</li>
</ol>
<ul>
<li><code>SOURCE</code> 表示注解仅存于源文件中，注解将被编译器丢弃。</li>
<li><code>CLASS</code> 表示注解将保存在类文件中，但不被JVM保存的注解，是默认值。</li>
<li><code>RUNTIME</code> 表示要被JVM保存的注解，在运行时可以利用反射机制查询</li>
</ul>
<ol start="4">
<li><code>Target</code><br>
Target注解用来指明哪个(些)程序元素可以利用被标注的注解类型进行标注。 Target的值为java.lang.annotation.ElementType枚举的一个成员：</li>
</ol>
<ul>
<li><code>ANNOTATION_TYPE</code>  可以对注解类型标注。</li>
<li><code>CONSTRUCTOR</code>  可以对构造方法进行标注。</li>
<li><code>FIELD</code> 可以对成员的声明进行标注。</li>
<li><code>LOCAL_VARIABLE</code>  可以对局部变量进行标注。</li>
<li><code>METHOD</code>  可以对方法进行标注。</li>
<li><code>PACKAGE</code>  可以对包进行标注。</li>
<li><code>PARAMETER</code>  可以对参数声明进行标注。</li>
<li><code>TYPE</code>  可以对类型声明进行标注</li>
</ul>
<p>如Override 注解类型使用了 Target 注解标注，使得 Override 只适用于方法声明.<br>
SuppressWarnings 注解类型的声明</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span> (value={TYPE,FIELD,METHOD,PARAMETER, CONSTRUCTOR,LOCAL_VARIABLE})</span><br><span class="line"><span class="meta">@Retention(value=SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings</span><br></pre></td></tr></tbody></table></figure>
<h3 id="定义注解">定义注解<a title="#定义注解" href="#定义注解"></a></h3>
<p>默认情况下，所有的注解类型都扩展了java.lang.annotation.Annotation接口。该接口定义一个返回Class对象的 annotationType()方法 <code>Class &lt;?extends Annotation&gt; annotationType()</code>, 该接口还定义了equals()方法、hashCode()方法和toString()方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation {</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">MyClass1</span> {</span><br><span class="line">    <span class="meta">@MyAnnotation(value = "Hello, World!")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException {</span><br><span class="line">        <span class="type">MyClass1</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass1</span>();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> obj.getClass().getMethod(<span class="string">"myMethod"</span>);</span><br><span class="line">        <span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> annotation.value();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>在注解类型中声明的方法称为注解类型的元素，它的声明类似于接口中的方法声明，没有方法体，但有返回类型。元素的类型有一些限制，如只能是基本类型、String、枚举类型、其他注解类型等，并且元素不能声明任何参数。<br>
实际上，注解类型的元素就像对象的域一样，所有应用该注解类型的程序元素都要对这些域实例化。这些域的值是在应用注解时由初始化器决定，或由元素的默认值决定。<br>
在定义注解时可以使用 default 关键字为元素指定默认值。</p>
<p>javaxjws 包中定义了一些用来创建 Web 服务的注解类型，在 javax.xml.ws包和 javax.xml.bind.annotation 包中也定义了许多注解类型。注解类型在 Java Web 开发和Java EE 开发中被广泛使用.</p>
<p><strong>参考</strong></p>
<ol>
<li>《Java程序设计(第3版)》 IBSN 9787302485520</li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/index.html" target="_blank">Java API 文档</a></li>
<li><a href="https://blog.csdn.net/qq_52348926/article/details/129478117#:~:text=hashCode%20%28%29%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E8%AE%A1%E7%AE%97%E5%93%88%E5%B8%8C%E7%A0%81%E5%80%BC%EF%BC%8C%E8%80%8Cequals%20%28%29%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E6%80%A7%E3%80%82%20%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%20%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%93%88%E5%B8%8C%E7%A0%81%E5%80%BC%E7%9B%B8%E5%90%8C,%EF%BC%8C%20%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%84%8F%E5%91%B3%E7%9D%80%E5%AE%83%E4%BB%AC%E6%98%AF%E7%9B%B8%E7%AD%89%E7%9A%84%20%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%20%EF%BC%8C%E5%8D%B3%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E8%83%BD%E7%94%9F%E6%88%90%E7%9B%B8%E5%90%8C%E7%9A%84%E5%93%88%E5%B8%8C%E7%A0%81%E5%80%BC%E3%80%82" target="_blank">Hash值的理解，Java中hashCode()和equals究竟有什么用？</a></li>
</ol>
</div><is-e class="φu"><!----><ul class="φy"><li class="φw"><strong class="φx">Author<span>:</span></strong><p class="φv">slacr_</p></li><li class="φw"><strong class="φx">Copyright<span>:</span></strong><p class="φv"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><img src="/lib/cc-by-nc-sa.svg">CC BY-NC-ND 4.0</a></p></li><li class="φw"><strong class="φx">Published<span>:</span></strong><p class="φv">May 9, 2023</p></li><li class="φw"><strong class="φx">Updated<span>:</span></strong><p class="φv">May 9, 2023</p></li><!----></ul><!----></is-e><!----><is-j class="φcm"><p class="φcr">Buy me a cup of coffee ☕.</p><div class="φco"><div class="φct"><a class="φcs φa iκ-wechat" style="color:;"></a><a class="φcs" style="color:;">支</a><!----></div><div class="φcq"><!----></div></div></is-j><!----><div><div issnippet="" class="φb">


<link href="https://cdn.jsdelivr.net/gh/s1acr/my_jsDelivr@main/clipboard.css" rel="stylesheet">
</div><!----></div><!----></article><footer class="φex"><!----><div class="φey"><a class="φez φfb" href="/2023/05/10/%5BJava%E7%AC%94%E8%AE%B0%5D%E6%8E%A5%E5%8F%A3&amp;Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">[Java笔记]接口&amp;Lambda表达式</a><!----><a class="φez φfa" href="/2023/05/09/%5BJava%E7%AC%94%E8%AE%B0%5D%E7%BB%A7%E6%89%BF&amp;%E5%A4%9A%E6%80%81">[Java笔记]继承&amp;多态</a><!----></div><!----></footer><is-d class="φt"><div issnippet=""><div id="vcomments"></div>

</div><!----></is-d><!----><!----><!----></is-r><!----></main><!----></div></div></div><is-f class="φz"><div class="φbi"><span class="φa iκ-up"></span><span class="φa iκ-down"></span><!----><span class="φa iκ-toc"></span><!----><span class="φa iκ-search"></span><!----></div><div class="φbb φbc"><svg class="φbh"><defs><filter id="dp"><feGaussianBlur in="SourceGraphic" stdDeviation="2"></feGaussianBlur></filter></defs><circle filter="url(#dp)" fill="rgba(0,0,0,.3)" cx="50%" cy="52%" r="44%"></circle><circle cx="50%" cy="50%" r="44%" class="φbd"></circle><circle cx="50%" cy="50%" r="48%" class="φbg" stroke-dasharray="0% 314.15926%"></circle><!----><g class="φbe"><circle r=".2rem" cx="0" cy="-.8rem"></circle><circle r=".2rem"></circle><circle r=".2rem" cx="0" cy=".8rem"></circle></g><!----></svg></div></is-f><is-m class="φdq"><div class="φds φdt"><a class="φdv"><span class="φdx">1 </span><!----><span class="φdy">Object</span></a><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">2 </span><!----><span class="φdy">Math</span></a><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">3 </span><!----><span class="φdy">基本类型包装类</span></a><div class="φds"><a class="φdv"><span class="φdx">3.1 </span><!----><span class="φdy">Character</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">3.2 </span><!----><span class="φdy">Boolean</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">3.3 </span><!----><span class="φdy">数值类对象</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">3.4 </span><!----><span class="φdy">自动装箱与自动拆箱</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">3.5 </span><!----><span class="φdy">字符串与基本数据类型转化</span></a><!----></div><!----><!----><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">4 </span><!----><span class="φdy">BigInteger BigDecimal</span></a><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">5 </span><!----><span class="φdy">时间日期API</span></a><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">6 </span><!----><span class="φdy">内部类</span></a><div class="φds"><a class="φdv"><span class="φdx">6.1 </span><!----><span class="φdy">内部成员类</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">6.2 </span><!----><span class="φdy">局部内部类</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">6.3 </span><!----><span class="φdy">匿名内部类</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">6.4 </span><!----><span class="φdy">静态内部类</span></a><!----></div><!----><!----><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">7 </span><!----><span class="φdy">枚举类型</span></a><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">8 </span><!----><span class="φdy">注解类型</span></a><div class="φds"><a class="φdv"><span class="φdx">8.1 </span><!----><span class="φdy">标准注解</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">8.2 </span><!----><span class="φdy">标准元注解</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">8.3 </span><!----><span class="φdy">定义注解</span></a><!----></div><!----><!----><!----></div><!----></is-m><!----><!----></is-a><!-- hexo injector body_begin end --><!-- hexo injector body_end start --><script src="//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script src="//cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/s1acr/my_jsDelivr@main/blogSelfDesign.js"></script><script src="/runtime.1ed960b0635ea0669f87.js"></script><script src="/polyfills.b7bf56fc45f931a8b83e.js"></script><script src="/main.543c891b4aad158701f3.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"superSample":2,"position":"right","hOffset":0,"vOffset":-20,"bottom":100,"width":150,"height":200},"mobile":{"show":true,"scale":0.5},"react":{"opacity":0.7,"opacityDefault":0.7,"opacityOnHover":0.9},"log":false});</script>

</body></html>