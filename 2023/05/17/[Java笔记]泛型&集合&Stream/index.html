<!DOCTYPE html><html lang="en"><head><!-- hexo injector head_begin start -->
<link rel="stylesheet" href="/css/bilicard.css">
<meta name="baidu-site-verification" content="codeva-pFQ3MHhnDY">
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9317015731056598" crossorigin="anonymous"></script>

<script src="/config.b810d57c68fbb8a39a0a.js"></script>
<!-- hexo injector head_begin end -->
<meta charset="utf-8">
<title>[Java笔记]泛型&amp;集合&amp;Stream - slacr_'s blog</title>
<base href="/">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link rel="canonical" href="https://s1acr.github.io/2023/05/17/[Java%E7%AC%94%E8%AE%B0]%E6%B3%9B%E5%9E%8B&amp;%E9%9B%86%E5%90%88&amp;Stream/">
<link rel="icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/bitbug_favicon.ico">
<link rel="manifest" href="/manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="description" content="Java 笔记  泛型 泛型是Java5引进的新特征，是类和接口的一种扩展机制，主要实现参数化类型(parameterized type)机制。泛型被广泛应用在 Java 集合API 中，在Java集合框架中大多数的类和接口都是泛型类型。使用泛型，程序员可以编写更安全的程序. 泛型类型 泛型 (generics) 是带一个或多个类型参数 (type parameter) 的类或接口。 按照约定，">
<meta property="og:type" content="website">
<meta property="og:title" content="[Java笔记]泛型&amp;集合&amp;Stream">
<meta property="og:url" content="https://s1acr.github.io/2023/05/17/[Java%E7%AC%94%E8%AE%B0]%E6%B3%9B%E5%9E%8B&amp;%E9%9B%86%E5%90%88&amp;Stream/index.html">
<meta property="og:site_name" content="slacr_'s blog">
<meta property="og:description" content="Java 笔记  泛型 泛型是Java5引进的新特征，是类和接口的一种扩展机制，主要实现参数化类型(parameterized type)机制。泛型被广泛应用在 Java 集合API 中，在Java集合框架中大多数的类和接口都是泛型类型。使用泛型，程序员可以编写更安全的程序. 泛型类型 泛型 (generics) 是带一个或多个类型参数 (type parameter) 的类或接口。 按照约定，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg">
<meta property="article:published_time" content="2023-05-17T00:00:00.000Z">
<meta property="article:modified_time" content="2023-05-17T00:00:00.000Z">
<meta property="article:author" content="slacr_">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg">
<script type="application/ld+json">[{"@context":"http://schema.org","@type":"WebSite","publisher":{"@type":"Person","name":"slacr_","description":"Crap Programmer, College Student From CN. Idealist and Minimalism, life-long learner. I was lucky to find out what I truly have passion for. 🚬.","image":"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg"},"url":"https://s1acr.github.io","image":"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg","description":"slacr_ blog self blog website record coding githubpages","author":{"@type":"Person","name":"slacr_","description":"Crap Programmer, College Student From CN. Idealist and Minimalism, life-long learner. I was lucky to find out what I truly have passion for. 🚬.","image":"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg"},"inLanguage":{"@type":"Language","alternateName":"en"}},{"@context":"http://schema.org","@type":"Article","articleSection":"Java","url":"https://s1acr.github.io/2023/05/17/[Java%E7%AC%94%E8%AE%B0]%E6%B3%9B%E5%9E%8B&%E9%9B%86%E5%90%88&Stream/","headline":"[Java笔记]泛型&集合&Stream","image":"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg","datePublished":"2023-05-17T00:00:00.000Z","dateModified":"2023-05-17T00:00:00.000Z","keywords":"","description":"slacr_ blog self blog website record coding githubpages","publisher":{"@type":"Organization","name":"slacr_'s blog","logo":{"@type":"ImageObject","url":"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg"}},"author":{"@type":"Person","name":"slacr_","description":"Crap Programmer, College Student From CN. Idealist and Minimalism, life-long learner. I was lucky to find out what I truly have passion for. 🚬.","image":"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/qqAvatar.jpg"},"inLanguage":{"@type":"Language","alternateName":"en"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://s1acr.github.io/2023/05/17/[Java%E7%AC%94%E8%AE%B0]%E6%B3%9B%E5%9E%8B&%E9%9B%86%E5%90%88&Stream/"}}]</script>

<!-- hexo injector head_end start --><style is="theme">html{--inside-accent-color:#2a2b33;--inside-foreground-color:#363636;--inside-border-color:#e0e0e0;--inside-background:#f3f6f7;--inside-sidebar-background:#2a2b33;--inside-card-background:#fff;--inside-font-base:ZCOOL_XiaoWei;--inside-font-logo:Lobster,ZCOOL_XiaoWei;--inside-font-menu:Lobster,ZCOOL_XiaoWei;--inside-font-heading:Baloo_Paaji_2,ZCOOL_XiaoWei;--inside-font-label:Lobster,ZCOOL_XiaoWei;--inside-font-code:ZCOOL_XiaoWei,Inconsolata,monospace;--inside-font-print:ZCOOL_XiaoWei;--inside-content-width:800px;--inside-highlight-00:#1e1e1e;--inside-highlight-01:#323537;--inside-highlight-02:#464b50;--inside-highlight-03:#5f5a60;--inside-highlight-04:#838184;--inside-highlight-05:#a7a7a7;--inside-highlight-06:#c3c3c3;--inside-highlight-07:#ffffff;--inside-highlight-08:#cf6a4c;--inside-highlight-09:#cda869;--inside-highlight-0a:#f9ee98;--inside-highlight-0b:#8f9d6a;--inside-highlight-0c:#afc4db;--inside-highlight-0d:#7587a6;--inside-highlight-0e:#9b859d;--inside-highlight-0f:#9b703f;--inside-card-color:#fff;--inside-accent-color-005:rgba(42,43,51,.05);--inside-accent-color-01:rgba(42,43,51,.1);--inside-accent-color-02:rgba(42,43,51,.2);--inside-accent-color-04:rgba(42,43,51,.4);--inside-accent-color-08:rgba(42,43,51,.8)}</style><script src="/theme.9ecc9ab1.js"></script><link href="https://cdn.jsdelivr.net/gh/s1acr/my_jsDelivr@main/googleFonts/myblog.css" rel="stylesheet"><link href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="//cdn.jsdelivr.net/gh/s1acr/my_jsDelivr@main/blogSelfDesignDist.css" rel="stylesheet">
<script src="/cipher.0329a0a9.js"></script>

<script src="/palette.ead17218.js"></script>
<link href="/styles.91e7dfca63c7c151daa6.css" rel="stylesheet"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><meta name="theme-color" content=""><script type="application/json" is="state">{&q;api/MjAyMy8wNS8xNy9bSmF2YeeslOiusF3ms5vlnosm6ZuG5ZCIJlN0cmVhbQ.json&q;:{&q;title&q;:&q;[Java笔记]泛型&a;集合&a;Stream&q;,&q;date&q;:&q;2023-05-17T00:00:00.000Z&q;,&q;date_formatted&q;:{&q;ll&q;:&q;May 17, 2023&q;,&q;L&q;:&q;05/17/2023&q;,&q;MM-DD&q;:&q;05-17&q;},&q;link&q;:&q;2023/05/17/[Java笔记]泛型&a;集合&a;Stream&q;,&q;comments&q;:true,&q;categories&q;:[&q;Java&q;],&q;updated&q;:&q;2023-05-17T00:00:00.000Z&q;,&q;content&q;:&q;&l;blockquote&g;\n&l;p&g;Java 笔记&l;/p&g;\n&l;/blockquote&g;\n&l;h2 id=\&q;泛型\&q;&g;泛型&l;a title=\&q;#泛型\&q; href=\&q;#泛型\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;泛型是Java5引进的新特征，是类和接口的一种扩展机制，主要实现&l;code&g;参数化类型(parameterized type)&l;/code&g;机制。泛型被广泛应用在 Java 集合API 中，在Java集合框架中大多数的类和接口都是泛型类型。使用泛型，程序员可以编写更安全的程序.&l;/p&g;\n&l;h3 id=\&q;泛型类型\&q;&g;泛型类型&l;a title=\&q;#泛型类型\&q; href=\&q;#泛型类型\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;泛型 (generics) 是带一个或多个类型参数 (type parameter) 的类或接口。&l;br&g;\n按照约定，类型参数名使用单个大写字母表示。常用的类型参数名有E (表示元素)、K (表示键)、 N (表示数字)、 T (表示类型)、 V (表示值)等&l;br&g;\n泛型参数不能是原始数据类型 primitive type&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;29&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;30&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;31&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;32&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;33&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;34&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;35&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;36&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;37&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;38&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;interface&l;/span&g; &l;span class=\&q;title class_\&q;&g;Entry&l;/span&g;&a;lt;K, V&a;gt; &a;#123;  &l;span class=\&q;comment\&q;&g;// 泛型接口&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; K &l;span class=\&q;title function_\&q;&g;getKey&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; V &l;span class=\&q;title function_\&q;&g;getValue&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Pair&l;/span&g;&a;lt;K, V&a;gt; &l;span class=\&q;keyword\&q;&g;implements&l;/span&g; &l;span class=\&q;title class_\&q;&g;Entry&l;/span&g;&a;lt;K, V&a;gt; &a;#123;   &l;span class=\&q;comment\&q;&g;// 泛型类&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;private&l;/span&g; K key;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;private&l;/span&g; V value;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;title function_\&q;&g;Pair&l;/span&g;&l;span class=\&q;params\&q;&g;(K key, V value)&l;/span&g;&a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;this&l;/span&g;.key = key;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;built_in\&q;&g;this&l;/span&g;.value = value;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;setKey&l;/span&g;&l;span class=\&q;params\&q;&g;(K key)&l;/span&g; &a;#123;&l;span class=\&q;built_in\&q;&g;this&l;/span&g;.key = key;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g;  K &l;span class=\&q;title function_\&q;&g;getKey&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &a;#123;&l;span class=\&q;keyword\&q;&g;return&l;/span&g; key;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;setValue&l;/span&g;&l;span class=\&q;params\&q;&g;(V value)&l;/span&g; &a;#123;&l;span class=\&q;built_in\&q;&g;this&l;/span&g;.value = value;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; V &l;span class=\&q;title function_\&q;&g;getValue&l;/span&g;&l;span class=\&q;params\&q;&g;()&l;/span&g; &a;#123;&l;span class=\&q;keyword\&q;&g;return&l;/span&g; value;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &a;lt;T&a;gt; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;getType&l;/span&g;&l;span class=\&q;params\&q;&g;(T t, K k, V v)&l;/span&g; &a;#123;   &l;span class=\&q;comment\&q;&g;// 泛型方法, 泛型参数表位置在返回值前&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(t.getClass().getName());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(k.getClass().getName());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(v.getClass().getName());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Pair&a;lt;String, Integer&a;gt; p_1 = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;Pair&l;/span&g;&a;lt;&a;gt;(&l;span class=\&q;string\&q;&g;&a;quot;slacr&a;quot;&l;/span&g;, &l;span class=\&q;number\&q;&g;19&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Pair&a;lt;String, Integer&a;gt; p_2 = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;Pair&l;/span&g;&a;lt;&a;gt;(&l;span class=\&q;string\&q;&g;&a;quot;hacker&a;quot;&l;/span&g;, &l;span class=\&q;number\&q;&g;20&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Pair&a;lt;Pair, Pair&a;gt; pp = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;Pair&l;/span&g;&a;lt;&a;gt;(p_1, p_2);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(pp.getKey().getKey());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(pp.getKey().getValue());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        pp.&a;lt;Integer&a;gt;getType(&l;span class=\&q;number\&q;&g;2&l;/span&g;, pp, p_1 );   &l;span class=\&q;comment\&q;&g;// 注意类型位置在方法名前， C++中是在后&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//java.lang.Integer&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//generics.Pair&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//generics.Pair&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;通配符&s;？&s;\&q;&g;通配符’？’&l;a title=\&q;#通配符&s;？&s;\&q; href=\&q;#通配符&s;？&s;\&q;&g;&l;/a&g;&l;/h3&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &a;lt;T&a;gt;&l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;printList&l;/span&g;&l;span class=\&q;params\&q;&g;(List&a;lt;T&a;gt; list)&l;/span&g; &a;#123; &l;span class=\&q;comment\&q;&g;// 通配符的存在相当于让方法参数化便于传入类型的多样，但在类中无法使用参数化的类型&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g;(Object e : list) &a;#123;              &l;span class=\&q;comment\&q;&g;// 这样也能实现一样的效果， 只不过通配符是让编译器识别&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.println(e);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;printList_1&l;/span&g;&l;span class=\&q;params\&q;&g;(List&a;lt;?&a;gt; list)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g;(Object e : list) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.println(e);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        List&a;lt;String&a;gt; list = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;String&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        list.add(&l;span class=\&q;string\&q;&g;&a;quot;slacr&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        list.add(&l;span class=\&q;string\&q;&g;&a;quot;foo&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        list.add(&l;span class=\&q;string\&q;&g;&a;quot;bar&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// Main.&a;lt;String&a;gt;printList(list);&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        printList(list); &l;span class=\&q;comment\&q;&g;// 也可以让编译器自动识别，&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        printList_1(list);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;有界类型参数\&q;&g;有界类型参数&l;a title=\&q;#有界类型参数\&q; href=\&q;#有界类型参数\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;&l;code&g;有界类型参数 (bounded type parameter)&l;/code&g;。 有界类型分为上界和下界，上界用 extends指定，下界用super指定。&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;comment\&q;&g;//public static double getAvg(List&a;lt;? extends Number &a;gt; list)&a;#123;  // extends指定上界为Number, 只能传Number或其子类对象&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &a;lt;U &l;span class=\&q;keyword\&q;&g;extends&l;/span&g; &l;span class=\&q;title class_\&q;&g;Number&l;/span&g; &a;amp; java.io.Serializable&a;gt; &l;span class=\&q;type\&q;&g;double&l;/span&g; &l;span class=\&q;title function_\&q;&g;getAvg&l;/span&g;&l;span class=\&q;params\&q;&g;(List&a;lt;U&a;gt; list)&l;/span&g;&a;#123;   &l;span class=\&q;comment\&q;&g;// 或者这么写, 不用通配符&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;double&l;/span&g; &l;span class=\&q;variable\&q;&g;total&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;0D&l;/span&g;;                                  &l;span class=\&q;comment\&q;&g;// 下界用 super 关键词指定, 实现接口用 &a;amp;&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (Number number : list) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            total += number.doubleValue();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; total/list.size();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        List&a;lt;Integer&a;gt; integerList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        integerList.add(&l;span class=\&q;number\&q;&g;1&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        integerList.add(&l;span class=\&q;number\&q;&g;2&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        integerList.add(&l;span class=\&q;number\&q;&g;3&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(getAvg(integerList));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        List&a;lt;Float&a;gt; floatList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        floatList.add(&l;span class=\&q;number\&q;&g;3F&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        floatList.add(&l;span class=\&q;number\&q;&g;4F&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(getAvg(floatList));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;类型擦除\&q;&g;类型擦除&l;a title=\&q;#类型擦除\&q; href=\&q;#类型擦除\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;当实例化泛型类型时，编译器使用一种叫&l;code&g;类型擦除 (type erasure)&l;/code&g;的技术转换这些类型。在编译时，编译器将清除类和方法中所有与类型参数有关的信息。类型擦除可让使用泛型的Java应用程序与之前不使用泛型类型的 Java类库和应用程序兼容&l;/p&g;\n&l;p&g;例如，&l;code&g;Node&a;lt;Integer&a;gt;被转换成 Node, 它称为源类型 (raw type)&l;/code&g;。源类型是不带任何类型参数的泛型类或接口名。这说明在运行时找不到泛型类使用的是什么类型。&l;/p&g;\n&l;p&g;也就是说泛型类在编译时泛型参数的类型是不可确定的, 只有在实例化对象时才能确定, 因此定义泛型类或方法的时候只能声明存在该参数类型的变量, 而不能直接使用, 像 new T() 或者赋值.&l;/p&g;\n&l;h2 id=\&q;集合框架\&q;&g;集合框架&l;a title=\&q;#集合框架\&q; href=\&q;#集合框架\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;Java 提供了一个集合框架 (Collections Framework), 该框架定义了一组接口和类, 使得处理对象组更容易。&l;/p&g;\n&l;p&g;&l;code&g;集合是指集中存放一组对象的一个对象&l;/code&g;。集合相当于一个容器，提供了保存、获取和操作其他元素的方法。集合能够帮助Java程序员轻松地管理对象。 Java 集合框架由两种类型构成，一个是&l;code&g;Collection&l;/code&g;; 另一个是&l;code&g;Map&l;/code&g;。Collection 对象用于存放一组对象， Map 对象用于存放一组“关键字/值”的对象。 Collection和 Map 是最基本的接口，它们又有子接口.&l;/p&g;\n&l;p&g;&l;img src=\&q;https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305161320016.png\&q; alt=\&q;\&q; loading=\&q;lazy\&q; class=\&q;φbp\&q;&g;&l;/p&g;\n&l;p&g;Collection&l;E&g;接口是所有集合类型的根接口，继承了 Iterable&l;E&g;接口. Collection接口定义了集合操作的常用方法，这些方法可以简单分为&l;code&g;基本操作、批量操作、数组操作和流操作&l;/code&g;。&l;/p&g;\n&l;h3 id=\&q;基本操作\&q;&g;基本操作&l;a title=\&q;#基本操作\&q; href=\&q;#基本操作\&q;&g;&l;/a&g;&l;/h3&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;boolean add(E e)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;boolean remove(Object o)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;删除首次出现元素 o&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;boolean contains(Object o)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回集合中是否包含指定的元素o。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;boolean isEmpty()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;int size()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;Iterator iterator()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回包含所有元素的迭代器对象。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;default void forEach(Consumer&a;lt;? super T&a;gt;action)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;从父接口继承的方法，在集合的每个元素上执行指定的操作。&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;h3 id=\&q;批量操作\&q;&g;批量操作&l;a title=\&q;#批量操作\&q; href=\&q;#批量操作\&q;&g;&l;/a&g;&l;/h3&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;boolean addAll(Collection&a;lt;? extends E&a;gt; c)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;将集合 c 中的所有元素添加到当前集合中。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;boolean removeAll(Collection&a;lt;?&a;gt;c)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;从当前集合中删除c 中的所有元素。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;default boolean removeif(Predicate&a;lt;? super E&a;gt; filter)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;从当前集合中删除满足谓词的所有元素。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;boolean containsAll(Collection&a;lt;?&a;gt;c)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回当前集合是否包含c 中的所有元素。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;boolean retainAll(Collection&a;lt;?&a;gt;c)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;在当前集合中只保留指定集合 c 中的元素，其他元素删除。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;void clear()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;h3 id=\&q;数组操作\&q;&g;数组操作&l;a title=\&q;#数组操作\&q; href=\&q;#数组操作\&q;&g;&l;/a&g;&l;/h3&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;Object[] toArray()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回包含集合中所有元素的对象数组。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;&a;lt;T&a;gt;T[] toArray(T[] a)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回包含集合中所有元素的数组，返回数组的元素类型是指定的数组类型&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;p&g;Object[] a = c.toArray(); 将Collection对象转换为Object数组.&l;/p&g;\n&l;h3 id=\&q;流(stream)操作\&q;&g;流(Stream)操作&l;a title=\&q;#流(stream)操作\&q; href=\&q;#流(stream)操作\&q;&g;&l;/a&g;&l;/h3&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public default Stream&a;lt;E&a;gt; stream()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;以当前集合作为源返回一个顺序 Stream对象。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public default Stream&a;lt;E&a;gt; paralellStream()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;以当前集合作为源返回一个并行 Stream对象。&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;h2 id=\&q;list-接口及实现类\&q;&g;List 接口及实现类&l;a title=\&q;#list-接口及实现类\&q; href=\&q;#list-接口及实现类\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;List接口是 Collection的子接口，实现一种线性表的数据结构.&l;/p&g;\n&l;p&g;&l;img src=\&q;https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305161332445.png\&q; alt=\&q;\&q; loading=\&q;lazy\&q; class=\&q;φbp\&q;&g;&l;/p&g;\n&l;p&g;List 接口除继承 Collection的方法外，还定义了一些自己的方法。&l;/p&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;E get(int index)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;E set(int index,E element)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;void add(int index, E element)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;E remove(int index)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;abstract boolean addAll(int index, Collection&a;lt;? extends E&a;gt; c)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;在指定下标处插入集合c 中的全部元素。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;int indexOf(Object o)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;查找指定对象第一次出现的位置。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;int lastIndexOf(Object o)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;List&a;lt;E&a;gt;subList(int from,int to)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;default void replaceAll(UnaryOperator&a;lt;E&a;gt; operator)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;将操作符应用于元素，并使用其结果替代每个元素。&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// List 接口不能直接实例化, 但能通过子类上转型来实现&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        List&a;lt;Character&a;gt; characterList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;(&l;span class=\&q;number\&q;&g;10&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (&l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;i&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;; i &a;lt; &l;span class=\&q;number\&q;&g;10&l;/span&g;; i++) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            characterList.add((&l;span class=\&q;type\&q;&g;char&l;/span&g;)(&l;span class=\&q;string\&q;&g;&a;#x27;A&a;#x27;&l;/span&g;+i));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.println(characterList.get(i));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;arraylist类\&q;&g;ArrayList类&l;a title=\&q;#arraylist类\&q; href=\&q;#arraylist类\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;ArrayList是最常用的线性表实现类，通过数组实现的集合对象。 ArrayList类实际上实现了一个&l;code&g;变长的对象数组&l;/code&g;，其元素可以动态地增加和删除。它的定位访问时间是常量时间。&l;/p&g;\n&l;p&g;ArrayList() 创建一个空的数组线性表对象，默认初始容量是10。&l;br&g;\nArrayList(Collection c) 用集合c 中的元素创建一个数组线性表对象.&l;br&g;\nArrayList(int initialCapacity)&l;/p&g;\n &l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g; &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ArrayList&a;lt;String&a;gt; stringArrayList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.add(&l;span class=\&q;string\&q;&g;&a;quot;how &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.add(&l;span class=\&q;string\&q;&g;&a;quot;are &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.add(&l;span class=\&q;string\&q;&g;&a;quot;you &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (String s : stringArrayList) &a;#123;  &l;span class=\&q;comment\&q;&g;// 增强的 for 循环, 不仅仅可以用来遍历数组, 还可以用来遍历 集合 , 实现了collection 接口的实例&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.print(s);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.forEach((s) -&a;gt; System.out.print(s));  &l;span class=\&q;comment\&q;&g;// 使用 forEach 方法, 跟 js 太像了&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.forEach(System.out::print);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h4 id=\&q;使用迭代器\&q;&g;使用迭代器&l;a title=\&q;#使用迭代器\&q; href=\&q;#使用迭代器\&q;&g;&l;/a&g;&l;/h4&g;\n&l;p&g;迭代器是一个可以遍历集合中每个元素的对象。调用集合对象的 &l;code&g;iterator()&l;/code&g; 方法可以得到 Iterator对象&l;/p&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;boolean hasNext()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回迭代器中是否还有对象。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;E next()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回迭代器中下一个对象。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;void remove()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;删除迭代器中的当前对象&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ArrayList&a;lt;String&a;gt; stringArrayList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.add(&l;span class=\&q;string\&q;&g;&a;quot;how &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.add(&l;span class=\&q;string\&q;&g;&a;quot;are &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.add(&l;span class=\&q;string\&q;&g;&a;quot;you &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Iterator&a;lt;String&a;gt; stringIterator = stringArrayList.iterator();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringIterator.next();   &l;span class=\&q;comment\&q;&g;// 一开始是首元素前， 移动到第一个元素位置&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringIterator.remove();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g; (stringIterator.hasNext()) &a;#123;      &l;span class=\&q;comment\&q;&g;// 使用迭代器遍历&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.printf(stringIterator.next()); &l;span class=\&q;comment\&q;&g;// next() 返回容器中对象后自增&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h4 id=\&q;双向迭代器\&q;&g;双向迭代器&l;a title=\&q;#双向迭代器\&q; href=\&q;#双向迭代器\&q;&g;&l;/a&g;&l;/h4&g;\n&l;p&g;List还提供了listIterator() 方法返回ListIterator对象。它可以从前后两个方向遍历线性表中元素，在迭代中修改元素以及获得元素的当前位置。ListIterator是Iterator的子接口，不但继承了Iterator接口中的方法，还定义了自己的方法。&l;/p&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;E next()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回下一个元素。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;boolean hasPrevious()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回是否还有前一个元素。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;E previous()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回前一个元素。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;int nextIndex()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回下一个元素的索引。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;int previousIndex()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回前一个元素的索引。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;void remove()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;删除当前元素。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;void set(E o)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;修改当前元素。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;void add(E o)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;在当前位置插入一个元素&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;p&g;使用迭代器可以修改线性表中的元素，但不能同时使用两个迭代器修改一个线性表中的元素，否则将抛出异常。&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ArrayList&a;lt;String&a;gt; stringArrayList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.add(&l;span class=\&q;string\&q;&g;&a;quot;how &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.add(&l;span class=\&q;string\&q;&g;&a;quot;are &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.add(&l;span class=\&q;string\&q;&g;&a;quot;you &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ListIterator&a;lt;String&a;gt; stringListIterator = stringArrayList.listIterator();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g; (stringListIterator.hasNext()) stringListIterator.next();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g; (stringListIterator.hasPrevious()) System.out.println(stringListIterator.previous()); &l;span class=\&q;comment\&q;&g;// 逆向遍历&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h4 id=\&q;数组转list对象\&q;&g;数组转List对象&l;a title=\&q;#数组转list对象\&q; href=\&q;#数组转list对象\&q;&g;&l;/a&g;&l;/h4&g;\n&l;p&g;java.util.Arrays 类提供了一个 asList()方法，实现将数组转换成 List对象的功能.&l;/p&g;\n&l;p&g;&l;code&g;public static &a;lt;T&a;gt; List&a;lt;T&a;gt; asList(T ...a)&l;/code&g;&l;/p&g;\n&l;p&g;该方法提供了一个从多个元素创建 List 对象的途径，它的功能与 &l;code&g;Collection 接口的 toArray()&l;/code&g;方法相反.&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ArrayList&a;lt;String&a;gt; stringArrayList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.add(&l;span class=\&q;string\&q;&g;&a;quot;how &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.add(&l;span class=\&q;string\&q;&g;&a;quot;are &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringArrayList.add(&l;span class=\&q;string\&q;&g;&a;quot;you &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        String[] strings = stringArrayList.toArray(&l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;String&l;/span&g;[&l;span class=\&q;number\&q;&g;0&l;/span&g;]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (String string : strings) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.print(string + &l;span class=\&q;string\&q;&g;&a;quot; &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        List&a;lt;String&a;gt; stringList =  Arrays.asList(strings);  &l;span class=\&q;comment\&q;&g;// asList()底层其实就是 调用ArrayList(... a) 构造&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringList.forEach(System.out::print);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        List&a;lt;String&a;gt; stringList1 = Arrays.asList(&l;span class=\&q;string\&q;&g;&a;quot;seize&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;the&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;moment&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringList1.forEach(s-&a;gt;&a;#123;System.out.print(s + &l;span class=\&q;string\&q;&g;&a;quot; &a;quot;&l;/span&g;);&a;#125;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;vector-和-stack\&q;&g;Vector 和 Stack&l;a title=\&q;#vector-和-stack\&q; href=\&q;#vector-和-stack\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;Vector类和Stack类是Java早期版本提供的两个集合类，分别实现&l;code&g;向量和对象栈&l;/code&g;。Vector类和 Stack类的方法都是&l;code&g;同步的&l;/code&g;，适合在&l;code&g;多线程&l;/code&g;的环境中使用.&l;/p&g;\n&l;h2 id=\&q;set接口及其实现类\&q;&g;Set接口及其实现类&l;a title=\&q;#set接口及其实现类\&q; href=\&q;#set接口及其实现类\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;Set 接口是 Collection的子接口，Set 接口对象类似于数学上的集合概念，其中&l;code&g;不允许有重复的元素&l;/code&g;。 Set 接口没有定义新的方法，只包含从Collection接口继承的方法。&l;br&g;\nSet 接口的常用实现类有 &l;code&g;HashSet 类、 TreeSet 类和 LinkedHashSet类&l;/code&g; 。&l;/p&g;\n&l;p&g;&l;img src=\&q;https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305161456356.png\&q; alt=\&q;\&q; loading=\&q;lazy\&q; class=\&q;φbp\&q;&g;&l;/p&g;\n&l;h3 id=\&q;hashset-类\&q;&g;HashSet 类&l;a title=\&q;#hashset-类\&q; href=\&q;#hashset-类\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;HashSet类用散列方法存储元素，具有最好的存取性能，但元素没有顺序。&l;br&g;\nHashing 散列算法最重要的就是 hash函数, 通过实际值与生成哈希值的单射完成高效存取.&l;/p&g;\n&l;p&g;&l;code&g;HashSet()&l;/code&g;  创建一个空的散列集合，该集合的默认初始容量是16, 默认装填因子(loadfactor) 是0.75。装填因子决定何时对散列表进行再散列。例如，如果装填因子为0.75(默认值), 而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说，装填因子为75%是比较合理的。&l;/p&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;HashSet(Collection c)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;用指定的集合c 的元素创建一个散列集合。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;HashSet(int initialCapacity)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;创建一个散列集合，并指定集合的初始容量。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;HashSet(int initialCapacity, float loadFactor)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;创建一个散列集合，并指定的集合初始容量和装填因子&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Set&a;lt;String&a;gt; words =&l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;HashSet&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        words.add(&l;span class=\&q;string\&q;&g;&a;quot;one&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        words.add(&l;span class=\&q;string\&q;&g;&a;quot;two&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        words.add(&l;span class=\&q;string\&q;&g;&a;quot;three&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        words.add(&l;span class=\&q;string\&q;&g;&a;quot;one&a;quot;&l;/span&g;);       &l;span class=\&q;comment\&q;&g;// 重复元素无效&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (String word : words) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.println(word);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;用-set-对象实现集合运算\&q;&g;用 Set 对象实现集合运算&l;a title=\&q;#用-set-对象实现集合运算\&q; href=\&q;#用-set-对象实现集合运算\&q;&g;&l;/a&g;&l;/h3&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;sl.addAll(s2)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;实现集合sl 与 s2 的并运算。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;sl.retainAll(s2)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;实现集合 s1与 s2 的交运算。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;sl.removeAll(s2)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;实现集合 s1 与 s2 的差运算。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;sl.containAll(s2)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;如果 s2是 s1 的子集，该方法返回 true。&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;h3 id=\&q;treeset-类\&q;&g;TreeSet 类&l;a title=\&q;#treeset-类\&q; href=\&q;#treeset-类\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;TreeSet实现一种树集合，使用&l;code&g;红-黑树&l;/code&g;为元素排序，添加到 TreeSet 中的元素必须是可比较的，即元素的类必须实现 &l;code&g;Comparable&a;lt;T&a;gt;&l;/code&g; 接口。它的操作要比 HashSet 慢。&l;/p&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;TreeSet(Collection c)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;用指定集合c 中的元素创建一个新的树集合，集合中的元素按自然顺序排序。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;TreeSet(Comparator c)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;创建一个空的树集合，元素的排序规则按给定的比较器c 的规则排序。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;TreeSet(SortedSet s)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;用 SortedSet 对象 s 中的元素创建一个树集合，排序规则与 s 的排序规则相同。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g; &l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;E first()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回有序集合中的第一个元素。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;E last()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回有序集合中最后一个元素。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;SortedSet&a;lt;E&a;gt; subSet(E fromElement, E toElement)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回有序集合中的一个子有序集合，它的元素从 fromElement 开始到 toElement结束(不包括最后元素)。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;SortedSet&a;lt;E&a;gt; headSet(E toElement)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回有序集合中小于指定元素 toElement 的一个子有序集合。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;SortedSet&a;lt;E&a;gt; tailSet(E fromElement)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回有序集合中大于等于 fromElement 元素的子有序集合。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;Comparator&a;lt;? super E&a;gt; comparator()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回与该有序集合相关的比较器，如果集合使用自然顺序则返回 null&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        String[] strings = &a;#123;&l;span class=\&q;string\&q;&g;&a;quot;Swift&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;TypeScript&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Scala&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Lisp&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;VBScript&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Basic&a;quot;&l;/span&g;&a;#125;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeSet&a;lt;String&a;gt; stringSet = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;TreeSet&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (&l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;i&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;; i &a;lt; strings.length; i++) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            stringSet.add(strings[i]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(stringSet);  &l;span class=\&q;comment\&q;&g;// 按自然顺序排列 // [Basic, Lisp, Scala, Swift, TypeScript, VBScript]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        SortedSet&a;lt;String&a;gt; sortedSet = stringSet.subSet(&l;span class=\&q;string\&q;&g;&a;quot;Lisp&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Swift&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(sortedSet);  &l;span class=\&q;comment\&q;&g;// [Lisp, Scala]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h4 id=\&q;对象顺序\&q;&g;对象顺序&l;a title=\&q;#对象顺序\&q; href=\&q;#对象顺序\&q;&g;&l;/a&g;&l;/h4&g;\n&l;p&g;创建 TreeSet 类对象时如果没有指定比较器对象，集合中的元素按自然顺序排列。所谓自然顺序(natural order)是指集合对象实现了 &l;code&g;Comparable 接口的 compareTo()方法&l;/code&g;，对象则根据该方法排序。如果试图对没有实现 Comparable 接口的集合元素排序，将抛出ClassCastException 异常。另一种排序方法是创建 TreeSet 对象时指定一个比较器对象，这样，元素将按比较器的规则排序。如果需要指定新的比较规则，可以定义一个类实现Comparator 接口，然后为集合提供一个新的比较器.&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        String[] strings = &a;#123;&l;span class=\&q;string\&q;&g;&a;quot;Swift&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;TypeScript&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Scala&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Lisp&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;VBScript&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Basic&a;quot;&l;/span&g;&a;#125;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// TreeSet&a;lt;String&a;gt; stringSet = new TreeSet&a;lt;&a;gt;(Comparator.reverseOrder());   &l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// 传个Comparator 比较器对象使Set红黑树按指定顺序进入&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeSet&a;lt;String&a;gt; stringSet = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;TreeSet&l;/span&g;&a;lt;&a;gt;((String s1, String s2) -&a;gt; s2.compareTo(s1));  &l;span class=\&q;comment\&q;&g;// 或者Lambda表达式&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (&l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;i&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;; i &a;lt; strings.length; i++) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            stringSet.add(strings[i]);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(stringSet);   &l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// [VBScript, TypeScript, Swift, Scala, Lisp, Basic]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h2 id=\&q;queue-接口及其实现类\&q;&g;Queue 接口及其实现类&l;a title=\&q;#queue-接口及其实现类\&q; href=\&q;#queue-接口及其实现类\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;Queue接口是Collection的子接口，是以先进先出 (first in first out,FIFO)的方式排列其元素，一般称为队列。&l;/p&g;\n&l;p&g;Deque 接口对象实现双端队列，ArrayDeque 和 LinkedList 是它的两个实现类。&l;br&g;\nPriorityQueue 实现的是一种优先队列，优先队列中元素的顺序是根据元素的值排列的.&l;/p&g;\n&l;p&g;&l;img src=\&q;https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305162100313.png\&q; alt=\&q;\&q; loading=\&q;lazy\&q; class=\&q;φbp\&q;&g;&l;/p&g;\n&l;h3 id=\&q;queue-接口和-deque-接口\&q;&g;Queue 接口和 Deque 接口&l;a title=\&q;#queue-接口和-deque-接口\&q; href=\&q;#queue-接口和-deque-接口\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;Queue 接口除了提供 Collection的操作外, 还提供了插入、删除和检查操作。&l;/p&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;boolean add(E e)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;boolean offer(E e)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;将指定的元素 e 插入到队列中。 失败add抛出异常, offer返回false&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g; &l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;E remove()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回队列头元素，同时将其删除。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;E poll()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回队列头元素，同时将其删除。 失败remove抛出异常, poll返回null&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g; &l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;E element()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回队列头元素，但不将其删除。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;E peek() &l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回队列头元素，但不将其删除。 失败element抛出异常, peek返回null&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;p&g;Queue 接口的每种操作都有两种形式：一个是在操作失败时抛出异常；另一个是在操作失败时返回一个特定的值(根据操作的不同，可能返回 null或 false)&l;/p&g;\n&l;p&g;Deque 接口实现双端队列，支持从两端插入和删除元素，同时实现了 Stack 和 Queue 的功能。&l;/p&g;\n&l;p&g;&l;img src=\&q;https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305162112698.png\&q; alt=\&q;\&q; loading=\&q;lazy\&q; class=\&q;φbp\&q;&g;&l;/p&g;\n&l;p&g;第一个方法在操作失败时抛出异常；第二个方法操作失败返回一个特殊值。除表中定义的基本方法外, Deque 接口还定义了 removeFirstOccurence() 和 removeLastOccurence()方法，分别用于删除第一次出现的元素，删除最后出现的元素.&l;/p&g;\n&l;h3 id=\&q;arraydeque-类和-linkedlist-类\&q;&g;ArrayDeque 类和 LinkedList 类&l;a title=\&q;#arraydeque-类和-linkedlist-类\&q; href=\&q;#arraydeque-类和-linkedlist-类\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;Deque 的常用实现类包括 &l;code&g;ArrayDeque类和LinkedList&l;/code&g;类，前者是&l;code&g;可变数组&l;/code&g;的实现；后者是&l;code&g;线性表&l;/code&g;的实现。LinkedList类比 ArayDeque类更灵活，实现了线性表的所有操作，其中可以存储null元素，但ArrayDeque 对象不能存储null.&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ArrayDeque&a;lt;String&a;gt; arrayDeque = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayDeque&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        arrayDeque.add(&l;span class=\&q;string\&q;&g;&a;quot;till &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        arrayDeque.offerFirst(&l;span class=\&q;string\&q;&g;&a;quot;it &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        arrayDeque.addFirst(&l;span class=\&q;string\&q;&g;&a;quot;fake &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        arrayDeque.offerLast(&l;span class=\&q;string\&q;&g;&a;quot;you &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        arrayDeque.add(&l;span class=\&q;string\&q;&g;&a;quot;make &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        arrayDeque.addLast(&l;span class=\&q;string\&q;&g;&a;quot;it. &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        arrayDeque.forEach(System.out::print);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        arrayDeque.forEach(&l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;Consumer&l;/span&g;&a;lt;String&a;gt;() &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;meta\&q;&g;@Override&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;accept&l;/span&g;&l;span class=\&q;params\&q;&g;(String s)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                System.out.print(s);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        arrayDeque.forEach(x -&a;gt; System.out.print(x));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Iterator&a;lt;String&a;gt; stringIterator = arrayDeque.iterator();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g;(stringIterator.hasNext()) System.out.print(stringIterator.next());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (String s : arrayDeque) &a;#123; System.out.print(s);&a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// 几种遍历练习练习&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;LinkedList允许null元素, 如果需要经常在线性表的头部添加元素或在内部删除元素，就应该使用LinkedList。这些操作在LinkedList中是常量时间，在ArrayList中是线性时间。而对定位访问LinkedList是线性时间，ArrayList是常量时间。&l;br&g;\n就是链表和顺序表的区别.&l;br&g;\n&l;code&g;LinkedList 同时实现了List 接口和Queue 接口&l;/code&g;.&l;/p&g;\n&l;p&g;&l;code&g;LinkedList()&l;/code&g;&l;br&g;\n&l;code&g;LinkedList(Collection c)&l;/code&g;&l;br&g;\n&l;code&g;addFirst()、getFirst()、removeFirst()、addLast()、getLast() removeLast()&l;/code&g;…&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &l;span class=\&q;keyword\&q;&g;throws&l;/span&g; InterruptedException &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Queue&a;lt;String&a;gt; stringQueue = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;LinkedList&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;final&l;/span&g; &l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;count&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;10&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringQueue.add(&l;span class=\&q;string\&q;&g;&a;quot;loading...&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;String&l;/span&g; &l;span class=\&q;variable\&q;&g;bar&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;string\&q;&g;&a;quot;██████████████████████████████&a;quot;&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (&l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;i&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;3&l;/span&g;; i &a;lt; bar.length() + &l;span class=\&q;number\&q;&g;1&l;/span&g;; i+= &l;span class=\&q;number\&q;&g;3&l;/span&g;) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            stringQueue.add(bar.substring(&l;span class=\&q;number\&q;&g;0&l;/span&g;,i) + &l;span class=\&q;string\&q;&g;&a;quot;  &a;quot;&l;/span&g; + i/&l;span class=\&q;number\&q;&g;3&l;/span&g;*&l;span class=\&q;number\&q;&g;10&l;/span&g; + &l;span class=\&q;string\&q;&g;&a;quot;%&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stringQueue.add(&l;span class=\&q;string\&q;&g;&a;quot;done!&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g; (!stringQueue.isEmpty()) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.println(stringQueue.remove());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            Thread.sleep(&l;span class=\&q;number\&q;&g;1000&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;img src=\&q;https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305162207311.png\&q; alt=\&q;\&q; loading=\&q;lazy\&q; class=\&q;φbp\&q;&g;&l;/p&g;\n&l;h2 id=\&q;集合转换\&q;&g;集合转换&l;a title=\&q;#集合转换\&q; href=\&q;#集合转换\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;集合实现类的构造方法可以接收一个Collection对象, 转换成该类型的集合. 所以许多集合类型之间可以相互转换.&l;/p&g;\n&l;p&g;&l;code&g;public ArrayList(Collection c)&l;/code&g;&l;br&g;\n&l;code&g;public HashSet(Collection c)&l;/code&g;&l;br&g;\n&l;code&g;public LinkedList(Collection c)&l;/code&g;&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        HashSet&a;lt;Integer&a;gt; integerHashSet = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;HashSet&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        integerHashSet.add(&l;span class=\&q;number\&q;&g;1&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        integerHashSet.add(&l;span class=\&q;number\&q;&g;2&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        LinkedList&a;lt;Integer&a;gt; integerLinkedList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;LinkedList&l;/span&g;&a;lt;&a;gt;(integerHashSet);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        integerLinkedList.add(&l;span class=\&q;number\&q;&g;3&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        integerLinkedList.add(&l;span class=\&q;number\&q;&g;4&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(integerLinkedList);  &l;span class=\&q;comment\&q;&g;// [1, 2, 3, 4]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h2 id=\&q;map-接口及其实现类\&q;&g;Map 接口及其实现类&l;a title=\&q;#map-接口及其实现类\&q; href=\&q;#map-接口及其实现类\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;Map 是用来存储“键/值”对的对象。在 Map 中存储的&l;code&g;关键字和值都必须是对象&l;/code&g;，并要求&l;code&g;关键字唯一&l;/code&g;的，而值可以重复.&l;br&g;\nMap接口常用的实现类有 HashMap类、TreeMap类、Hashtable类和 LinkedHashMap类。&l;/p&g;\n&l;p&g;&l;img src=\&q;https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305162222926.png\&q; alt=\&q;\&q; loading=\&q;lazy\&q; class=\&q;φbp\&q;&g;&l;/p&g;\n&l;h3 id=\&q;基本操作-1\&q;&g;基本操作&l;a title=\&q;#基本操作-1\&q; href=\&q;#基本操作-1\&q;&g;&l;/a&g;&l;/h3&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public V put(K key, V value)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;向映射对象中添加一个“键/值”对。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public V get(Object key)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回指定键的值。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public V remove(Object key)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public boolean containsKey(Object key)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public boolean containsValue(Object value)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;default V replace(K key,V value)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;若指定的“键/值”对存在于映射中，用指定的“键/值&a;quot;对替换之。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;default void forEach(BiConsumer&a;lt;? super K,? super V)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;对映射中的每项执行一次动作，直到所有项处理完或发生异常。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public int size()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public boolean isEmpty()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;h3 id=\&q;批量操作-1\&q;&g;批量操作&l;a title=\&q;#批量操作-1\&q; href=\&q;#批量操作-1\&q;&g;&l;/a&g;&l;/h3&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public void putAll(Map&a;lt;? extends K,? extends V&a;gt; map)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;将参数 map 中的所有“键/值&a;quot;对添加到映射中。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public void clear()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public Set&a;lt;K&a;gt;keySet()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回由键组成的 Set对象。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public Collection&a;lt;V&a;gt;values()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回由值组成的 Collection对象。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public Set&a;lt;Map.Entry&a;lt;K,V&a;gt;&a;gt;entrySet()&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回包含 Map.Entry&a;lt;K,V&a;gt;的一个 Set对象&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;h3 id=\&q;map-接口实现类\&q;&g;Map 接口实现类&l;a title=\&q;#map-接口实现类\&q; href=\&q;#map-接口实现类\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;常用实现类有&l;code&g;HashMap、TreeMap和 Hashtable&l;/code&g;类&l;/p&g;\n&l;h4 id=\&q;hashmap-类\&q;&g;HashMap 类&l;a title=\&q;#hashmap-类\&q; href=\&q;#hashmap-类\&q;&g;&l;/a&g;&l;/h4&g;\n&l;p&g;HashMap类以散列方法存放“键/值”对&l;/p&g;\n&l;p&g;&l;code&g;HashMap()&l;/code&g; 创建一个空的映射对象，使用默认的装填因子(0.75)。&l;br&g;\n&l;code&g;HashMap(int initialCapacity)&l;/code&g; 用指定初始容量和默认装填因子创建一个映射对象。&l;br&g;\n&l;code&g;HashMap(Map m)&l;/code&g;&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ArrayList&a;lt;String&a;gt;  nameList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;(Arrays.asList(&l;span class=\&q;string\&q;&g;&a;quot;slacr&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;John&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Amy&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Tim&a;quot;&l;/span&g;));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ArrayList&a;lt;Integer&a;gt; scoreList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;(Arrays.asList(&l;span class=\&q;number\&q;&g;60&l;/span&g;, &l;span class=\&q;number\&q;&g;53&l;/span&g;, &l;span class=\&q;number\&q;&g;88&l;/span&g;, &l;span class=\&q;number\&q;&g;99&l;/span&g;));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// Java的方法感觉比C++更好理解, 命名知其义, 注解也很全. 并且IDEA比VS智能多了&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Map&a;lt;String, Integer&a;gt; map = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;HashMap&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (&l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;i&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;; i &a;lt; nameList.size(); i++) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            map.put(nameList.get(i), scoreList.get(i));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        map.forEach((k, v) -&a;gt; &a;#123; System.out.printf(&l;span class=\&q;string\&q;&g;&a;quot;%-10s%d\\n&a;quot;&l;/span&g;, k, v);&a;#125;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//slacr     60&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//John      53&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//Tim       99&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//Amy       88&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h4 id=\&q;treemap-类\&q;&g;TreeMap 类&l;a title=\&q;#treemap-类\&q; href=\&q;#treemap-类\&q;&g;&l;/a&g;&l;/h4&g;\n&l;p&g;&l;code&g;TreeMap 类实现了SortedMap 接口&l;/code&g;，保证Map 中的“键/值”对按关键字升序排序。&l;/p&g;\n&l;p&g;&l;code&g;TreeMap()&l;/code&g;&l;br&g;\n&l;code&g;TreeMap(Comparator c)&l;/code&g;&l;br&g;\n&l;code&g;TreeMap(Map m)&l;/code&g;&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ArrayList&a;lt;String&a;gt;  nameList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;(Arrays.asList(&l;span class=\&q;string\&q;&g;&a;quot;slacr&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;John&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Amy&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Tim&a;quot;&l;/span&g;));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ArrayList&a;lt;Integer&a;gt; scoreList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;(Arrays.asList(&l;span class=\&q;number\&q;&g;60&l;/span&g;, &l;span class=\&q;number\&q;&g;53&l;/span&g;, &l;span class=\&q;number\&q;&g;88&l;/span&g;, &l;span class=\&q;number\&q;&g;99&l;/span&g;));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        TreeMap&a;lt;String, Integer&a;gt; map = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;TreeMap&l;/span&g;&a;lt;&a;gt;(&l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;Comparator&l;/span&g;&a;lt;String&a;gt;() &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;meta\&q;&g;@Override&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;title function_\&q;&g;compare&l;/span&g;&l;span class=\&q;params\&q;&g;(String o1, String o2)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                &l;span class=\&q;keyword\&q;&g;return&l;/span&g; scoreList.get(nameList.indexOf(o2)) - scoreList.get(nameList.indexOf(o1));    &l;span class=\&q;comment\&q;&g;// map先放入的后输出&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;);     &l;span class=\&q;comment\&q;&g;// 按成绩高低排序&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (&l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;i&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;; i &a;lt; nameList.size(); i++) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            map.put(nameList.get(i), scoreList.get(i));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        map.forEach(&l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;BiConsumer&l;/span&g;&a;lt;String, Integer&a;gt;() &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;i&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;accept&l;/span&g;&l;span class=\&q;params\&q;&g;(String k, Integer v)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                System.out.printf(&l;span class=\&q;string\&q;&g;&a;quot;No.%-5d%-10s%d\\n&a;quot;&l;/span&g;,i, k, v);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                i++;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//No.1    Tim       99&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//No.2    Amy       88&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//No.3    slacr     60&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//No.4    John      53&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h4 id=\&q;hashtable-类和-enumeration-接口\&q;&g;Hashtable 类和 Enumeration 接口&l;a title=\&q;#hashtable-类和-enumeration-接口\&q; href=\&q;#hashtable-类和-enumeration-接口\&q;&g;&l;/a&g;&l;/h4&g;\n&l;p&g;Hashtable类是 Java 早期版本提供的一个存放“键/值”对的实现类，实现了一种散列表，也属于集合框架。Hashtable类的方法都是同步的，因此它是线程安全的。&l;br&g;\n任何非null对象都可以作为散列表的关键字和值。但是要求作为关键字的对象必须实现 &l;code&g;hashCode()方法和equals()&l;/code&g;方法，以使对象的比较成为可能。&l;br&g;\nHashtable类的 keys()方法和elements()方法的返回类型都是 &l;code&g;Enumeration&l;/code&g; 接口类型的对象，通过该接口中hasMoreElements()方法和nextElement()方法可以对枚举对象元素迭代&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;29&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;30&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;31&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;32&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;33&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;34&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;35&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;36&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;37&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Hashtable&a;lt;Integer, String&a;gt; hashtable = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;Hashtable&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        hashtable.put(&l;span class=\&q;number\&q;&g;1&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;王二&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        hashtable.put(&l;span class=\&q;number\&q;&g;2&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;陈清扬&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        hashtable.put(&l;span class=\&q;number\&q;&g;3&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;罗小四&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        hashtable.put(&l;span class=\&q;number\&q;&g;4&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;军代表&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        hashtable.put(&l;span class=\&q;number\&q;&g;5&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;敦敦伟大友谊&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;String&l;/span&g; &l;span class=\&q;variable\&q;&g;s&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; hashtable.get(&l;span class=\&q;number\&q;&g;5&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(s);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Enumeration&a;lt;String&a;gt; words = hashtable.elements();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;while&l;/span&g; (words.hasMoreElements()) System.out.println(words.nextElement());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//敦敦伟大友谊   map 先入后出&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//敦敦伟大友谊&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//军代表&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//罗小四&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//陈清扬&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//王二&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// map一些遍历&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        hashtable.forEach((k, v) -&a;gt; System.out.println(k + &l;span class=\&q;string\&q;&g;&a;quot;  &a;quot;&l;/span&g; + v));    &l;span class=\&q;comment\&q;&g;// 遍历键值对&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g;(Integer k : hashtable.keySet()) System.out.print(k + &l;span class=\&q;string\&q;&g;&a;quot;  &a;quot;&l;/span&g;);  &l;span class=\&q;comment\&q;&g;// keySet()返回key的set对象, 遍历键&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        hashtable.keySet().forEach(i-&a;gt; System.out.print(i+&l;span class=\&q;string\&q;&g;&a;quot;  &a;quot;&l;/span&g;));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (Iterator&a;lt;Integer&a;gt; it = hashtable.keySet().iterator(); it.hasNext(); )&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.print(it.next()+&l;span class=\&q;string\&q;&g;&a;quot;  &a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        hashtable.values().forEach(System.out::println);   &l;span class=\&q;comment\&q;&g;// values() 返回 Collection 对象&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        hashtable.entrySet().forEach((Map.Entry&a;lt;Integer, String&a;gt; entry) -&a;gt; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            System.out.println(entry.getKey() + &l;span class=\&q;string\&q;&g;&a;quot;  &a;quot;&l;/span&g; + entry.getValue());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// entrySet() 返回  Set&a;lt;Map.Entry&a;lt;K,V&a;gt;&a;gt;, 可以再用相当于将Map中每一个Entry条目再组合成一个Set, 可以按Set容器遍历&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h2 id=\&q;collections-类\&q;&g;Collections 类&l;a title=\&q;#collections-类\&q; href=\&q;#collections-类\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;&l;code&g;Collections类是java.util包中定义的工具类&l;/code&g;，这个类提供了若干static方法实现集合对象的操作。这些操作大多对List操作，主要包括排序、重排、查找、求极值以及常规操作等。&l;/p&g;\n&l;div class=\&q;φbq\&q;&g;&l;div class=\&q;φbs\&q;&g;&l;table&g;&l;thead&g;\n&l;tr&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;th style=\&q;padding:0\&q;&g;&l;/th&g;\n&l;/tr&g;\n&l;/thead&g;\n&l;tbody&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;strong&g;排序&l;/strong&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static&a;lt;T&a;gt;void sort(List&a;lt;T&a;gt;list)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static&a;lt;T&a;gt; void sort(List&a;lt;T&a;gt;list, Comparator&a;lt;? super T&a;gt;c)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;strong&g;查找&l;/strong&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static&a;lt;T&a;gt; int binarySearch(List&a;lt;T&a;gt; list, T key)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;List需要sorted 如果 List包含要查找的元素，方法返回元素的下标，否则返回值为(-插入点-1)&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static &a;lt;T&a;gt;int binarySearch(List&a;lt;T&a;gt; list, T key, Comparator c)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;strong&g;打乱元素次序&l;/strong&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static void shuffle(List&a;lt;?&a;gt; list)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;使用默认的随机数打乱 List中元素的次序。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static void shuffle(List&a;lt;?&a;gt; list, Random rnd)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;使用指定的Random 对象，打乱List 中元素的次序&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;strong&g;求极值&l;/strong&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static  &a;lt;T&a;gt;T max(Collection&a;lt;? extends T&a;gt;coll)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static &a;lt;T&a;gt;T max(Collection&a;lt;? extends T&a;gt; coll, Comparator&a;lt;? super T&a;gt; comp)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static &a;lt;T&a;gt;T min(Collection&a;lt;? extends T&a;gt;coll)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static &a;lt;T&a;gt;T min(Collection&a;lt;? extends T&a;gt;coll, Comparator&a;lt;? super T&a;gt;comp)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;strong&g;其他常用&l;/strong&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static void reverse(List&a;lt;?&a;gt;list)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static void fill(List&a;lt;? super T&a;gt;list,T obj)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;用指定的值覆盖List中原来的每个值，该方法主要用于对 List进行重新初始化。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static void copy(List&a;lt;? super T&a;gt; dest,List&a;lt;? extends T&a;gt; src)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static void swap(List&a;lt;?&a;gt;list, int i, int j)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static void rotate(List&a;lt;?&a;gt; list, int distance)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;旋转列表，将 i 位置的元素移动到(i+distance)%list.size() 的位置。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static &a;lt;T&a;gt; boolean addAll(Collection&a;lt;? super T&a;gt;c, T ...elements)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;该方法用于将指定的元素添加到集合 c 中，可以指定单个元素或数组。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static int frequency(Collection&a;lt;?&a;gt;c, Object o)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;返回指定的元素o 在集合c 中出现的次数。&l;/td&g;\n&l;/tr&g;\n&l;tr&g;\n&l;td style=\&q;text-align:left\&q;&g;&l;code&g;public static boolean disjoint(Collection&a;lt;?&a;gt;cl, Collection&a;lt;?&a;gt;c2)&l;/code&g;&l;/td&g;\n&l;td style=\&q;text-align:left\&q;&g;判断两个集合是否不相交。如果两个集合不包含相同的元素，该方法返回 true。&l;/td&g;\n&l;/tr&g;\n&l;/tbody&g;\n&l;/table&g;&l;/div&g;&l;/div&g;&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ArrayList&a;lt;Integer&a;gt; integerArrayList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;(Arrays.asList(&l;span class=\&q;number\&q;&g;2&l;/span&g;,&l;span class=\&q;number\&q;&g;3&l;/span&g;,&l;span class=\&q;number\&q;&g;1&l;/span&g;,&l;span class=\&q;number\&q;&g;5&l;/span&g;,&l;span class=\&q;number\&q;&g;4&l;/span&g;,&l;span class=\&q;number\&q;&g;7&l;/span&g;,&l;span class=\&q;number\&q;&g;6&l;/span&g;));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Collections.sort(integerArrayList, Comparator.reverseOrder());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(integerArrayList);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Collections.shuffle(integerArrayList);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(integerArrayList);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Collections.reverse(integerArrayList);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(integerArrayList);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//[7, 6, 5, 4, 3, 2, 1]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//[5, 1, 7, 2, 4, 6, 3]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//[3, 6, 4, 2, 7, 1, 5]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Map&a;lt;String, Integer&a;gt; map = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;HashMap&l;/span&g;&a;lt;&a;gt;();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;for&l;/span&g; (&l;span class=\&q;type\&q;&g;int&l;/span&g; &l;span class=\&q;variable\&q;&g;i&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;number\&q;&g;0&l;/span&g;; i &a;lt; &l;span class=\&q;number\&q;&g;4&l;/span&g;; i++) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            map.put(&l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;(Arrays.asList(&l;span class=\&q;string\&q;&g;&a;quot;slacr&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;John&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Amy&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Tim&a;quot;&l;/span&g;)).get(i),&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;                    &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;(Arrays.asList(&l;span class=\&q;number\&q;&g;60&l;/span&g;, &l;span class=\&q;number\&q;&g;53&l;/span&g;, &l;span class=\&q;number\&q;&g;88&l;/span&g;, &l;span class=\&q;number\&q;&g;99&l;/span&g;)).get(i));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(Collections.max(map.entrySet(), (entry1, entry2) -&a;gt; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g; entry1.getValue() - entry2.getValue();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//Tim=99&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h2 id=\&q;stream-api\&q;&g;Stream API&l;a title=\&q;#stream-api\&q; href=\&q;#stream-api\&q;&g;&l;/a&g;&l;/h2&g;\n&l;p&g;流 (stream) 就像一个管道，将数据从源传输到目的地。流可分为顺序流和并行流。&l;br&g;\n流初看起来像集合，但流并不是存储对象的数据结构，仅&l;code&g;用来移动数据&l;/code&g;，因此不能像集合一样向流中添加元素&l;br&g;\n使用流的主要原因是它支持顺序和并行的聚集操作。例如，可以很容易地过滤、排序或转换流中的元素&l;br&g;\nStream接口是最常用的类型。 Stream 对象可用来传输任何类型的对象。还有一些特殊的 Stream,如 IntStream、LongStream、DoubleStream等。上述的 Stream 都派生自 BaseStream。&l;/p&g;\n&l;p&g;&l;img src=\&q;https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305171150522.png\&q; alt=\&q;\&q; loading=\&q;lazy\&q; class=\&q;φbp\&q;&g;&l;/p&g;\n&l;p&g;Stream 的有些方法执行中间操作，有些方法执行终止操作。中间操作是将一个流转换成另一个流，sorted、filter和 map 方法执行中间操作。终止操作产生一个最终结果， count、forEach 方法执行终止操作。流操作是延迟的，在源上的计算只有当终止操作开始时才执行.&l;/p&g;\n&l;h3 id=\&q;创建与获得流\&q;&g;创建与获得流&l;a title=\&q;#创建与获得流\&q; href=\&q;#创建与获得流\&q;&g;&l;/a&g;&l;/h3&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// Stream.of() 静态方法创建一个顺序流&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;Integer&a;gt; stream = Stream.of(&l;span class=\&q;number\&q;&g;1&l;/span&g;, &l;span class=\&q;number\&q;&g;2&l;/span&g;, &l;span class=\&q;number\&q;&g;3&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        String[] strings = &a;#123;&l;span class=\&q;string\&q;&g;&a;quot;Victor&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Deque&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Set&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;Map&a;quot;&l;/span&g;&a;#125;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;String&a;gt; stringStream = Arrays.stream(strings);  &l;span class=\&q;comment\&q;&g;// Arrays stream()将数组转换为流对象&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//default java.util.stream.Stream&a;lt;E&a;gt; stream();&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//default java.util.stream.Stream&a;lt;E&a;gt; parallelStream(); Collection接口中返回流对象&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//  public static&a;lt;T&a;gt; Stream&a;lt;T&a;gt; generate(Supplier&a;lt;? extends T&a;gt; s)&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;Double&a;gt; randoms = Stream.generate(Math::random);   &l;span class=\&q;comment\&q;&g;// 无限流&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// public static&a;lt;T&a;gt; Stream&a;lt;T&a;gt; iterate(final T seed, final UnaryOperator&a;lt;T&a;gt; f)&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;BigInteger&a;gt; integerStream = Stream.iterate(BigInteger.ZERO, n-&a;gt;n.add(BigInteger.ONE));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;连接与限制流\&q;&g;连接与限制流&l;a title=\&q;#连接与限制流\&q; href=\&q;#连接与限制流\&q;&g;&l;/a&g;&l;/h3&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;Integer&a;gt; s1 = Stream.of(&l;span class=\&q;number\&q;&g;1&l;/span&g;, &l;span class=\&q;number\&q;&g;2&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;Integer&a;gt; s2 = Stream.of(&l;span class=\&q;number\&q;&g;4&l;/span&g;, &l;span class=\&q;number\&q;&g;3&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;Integer&a;gt; s3 = Stream.of(&l;span class=\&q;number\&q;&g;6&l;/span&g;, &l;span class=\&q;number\&q;&g;5&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// public static &a;lt;T&a;gt; Stream&a;lt;T&a;gt; concat(Stream&a;lt;? extends T&a;gt; a, Stream&a;lt;? extends T&a;gt; b)&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// Stream.concat(Stream.concat(s1, s2), s3).sorted().forEach(System.out::print); // 123456&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// Stream&a;lt;T&a;gt; sorted(Comparator&a;lt;? super T&a;gt; comparator);&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream.concat(Stream.concat(s1, s2), s3).sorted(Comparator.reverseOrder()).forEach(System.out::print); &l;span class=\&q;comment\&q;&g;// 654321&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;Double&a;gt; randoms = Stream.generate(() -&a;gt; Double.valueOf(String.format(&l;span class=\&q;string\&q;&g;&a;quot;%.2f&a;quot;&l;/span&g;, Math.random()))).limit(&l;span class=\&q;number\&q;&g;10&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// limit() 限制流长度, 截断流&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        randoms.forEach(System.out::println);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;过滤流\&q;&g;过滤流&l;a title=\&q;#过滤流\&q; href=\&q;#过滤流\&q;&g;&l;/a&g;&l;/h3&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &l;span class=\&q;keyword\&q;&g;throws&l;/span&g; IOException &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;Integer&a;gt; stream = Stream.of(&l;span class=\&q;number\&q;&g;1&l;/span&g;, &l;span class=\&q;number\&q;&g;2&l;/span&g;, &l;span class=\&q;number\&q;&g;3&l;/span&g;, &l;span class=\&q;number\&q;&g;4&l;/span&g;, &l;span class=\&q;number\&q;&g;5&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stream = stream.filter(i -&a;gt; i&a;gt;&l;span class=\&q;number\&q;&g;3&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        stream.forEach(System.out::println); &l;span class=\&q;comment\&q;&g;// 4 5&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Path&l;/span&g; &l;span class=\&q;variable\&q;&g;parent&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; Paths.get(&l;span class=\&q;string\&q;&g;&a;quot;..&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;Path&a;gt; list = Files.walk(parent);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        list.filter((Path p) -&a;gt; p.toString().endsWith(&l;span class=\&q;string\&q;&g;&a;quot;.java&a;quot;&l;/span&g;)).forEach(System.out::println);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;流转换\&q;&g;流转换&l;a title=\&q;#流转换\&q; href=\&q;#流转换\&q;&g;&l;/a&g;&l;/h3&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;Character&a;gt; characterStream = Stream.of(&l;span class=\&q;string\&q;&g;&a;#x27;A&a;#x27;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;#x27;B&a;#x27;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;#x27;C&a;#x27;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//   &a;lt;R&a;gt; Stream&a;lt;R&a;gt; map(Function&a;lt;? super T, ? extends R&a;gt; mapper);&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;Integer&a;gt; integerStream = characterStream.map((character -&a;gt; &a;#123;&l;span class=\&q;keyword\&q;&g;return&l;/span&g; Integer.valueOf(character);&a;#125;));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        integerStream.forEach(System.out::println);  &l;span class=\&q;comment\&q;&g;// 65 66 67&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;流规约\&q;&g;流规约&l;a title=\&q;#流规约\&q; href=\&q;#流规约\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;经常需要从流中获得一个结果，如返回流中元素的数量。此时，可以使用流的 count()方法实现。这样的方法称为规约方法 (reduction),规约是终止操作。Stream接口提供了几个简单的规约方法，除count()方法外，还有max()和min()方法，它们分别返回流中的最大值和最小值。需要注意的是，这两个方法返回一个Optional&l;T&g;类型的值，它可能会封装返回值，也可能表示没有返回(当流为空时).&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;Character&a;gt; characterStream = Stream.of(&l;span class=\&q;string\&q;&g;&a;#x27;A&a;#x27;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;#x27;B&a;#x27;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;#x27;C&a;#x27;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//   &a;lt;R&a;gt; Stream&a;lt;R&a;gt; map(Function&a;lt;? super T, ? extends R&a;gt; mapper);&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;Integer&a;gt; integerStream = characterStream.map((character -&a;gt; &a;#123;&l;span class=\&q;keyword\&q;&g;return&l;/span&g; Integer.valueOf(character);&a;#125;));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// integerStream.forEach(System.out::println);  // 65 66 67&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//   Optional&a;lt;T&a;gt; max(Comparator&a;lt;? super T&a;gt; comparator);&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// System.out.println(integerStream.max(Comparator.reverseOrder())); Optional[65]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(integerStream.max(Comparator.reverseOrder()).get()); &l;span class=\&q;comment\&q;&g;// 65&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;收集结果\&q;&g;收集结果&l;a title=\&q;#收集结果\&q; href=\&q;#收集结果\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;当处理完流后，可能需要查看结果或将结果收集到其他容器中。可以使用 iterator()方法，该方法可以生成一个能够用来访问元素的传统迭代器。&l;br&g;\n调用toArray()方法获得一个含有流中所有元素的数组。因为&l;code&g;不可能在运行时创建一个泛型数组，所以表达式 stream.toArray()返回一个 Object[]类型数组&l;/code&g;。如果想获得相应类型数组，可以将类型传递给数组的构造方法&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;22&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;23&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;24&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;25&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;26&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;27&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;28&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;29&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;30&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;31&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;String&a;gt; stringStream = Stream.of(&l;span class=\&q;string\&q;&g;&a;quot;gone&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;with&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;the&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;wind&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;// &a;lt;A&a;gt; A[] toArray(IntFunction&a;lt;A[]&a;gt; generator);&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        String[] res = stringStream.toArray(String[]::&l;span class=\&q;keyword\&q;&g;new&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        ArrayList&a;lt;String&a;gt; arrayList = &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;ArrayList&l;/span&g;&a;lt;&a;gt;(List.of(res));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(arrayList);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;String&a;gt; stringStream1 = Stream.of(&l;span class=\&q;string\&q;&g;&a;quot;gone&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;with&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;the&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;wind&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;LinkedList&l;/span&g; &l;span class=\&q;variable\&q;&g;linkedList&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; &l;span class=\&q;keyword\&q;&g;new&l;/span&g; &l;span class=\&q;title class_\&q;&g;LinkedList&l;/span&g;&a;lt;&a;gt;(stringStream1.toList());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(linkedList);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;String&a;gt; stringStream2 = Stream.of(&l;span class=\&q;string\&q;&g;&a;quot;gone&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;with&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;the&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;wind&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        List&a;lt;String&a;gt; list = stringStream2.collect(Collectors.toList());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(list);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;String&a;gt; stringStream3 = Stream.of(&l;span class=\&q;string\&q;&g;&a;quot;gone&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;with&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;the&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;wind&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Set&a;lt;String&a;gt; set = stringStream3.collect(Collectors.toSet());&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(set);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        Stream&a;lt;String&a;gt; stringStream4 = Stream.of(&l;span class=\&q;string\&q;&g;&a;quot;gone&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;with&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;the&a;quot;&l;/span&g;, &l;span class=\&q;string\&q;&g;&a;quot;wind&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;TreeSet&l;/span&g; &l;span class=\&q;variable\&q;&g;treeSet&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; stringStream4.collect(Collectors.toCollection(TreeSet::&l;span class=\&q;keyword\&q;&g;new&l;/span&g;));&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(treeSet);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//[gone, with, the, wind]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//[gone, with, the, wind]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//[gone, with, the, wind]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//[the, with, gone, wind]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;comment\&q;&g;//[gone, the, wind, with]&l;/span&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;h3 id=\&q;基本类型流\&q;&g;基本类型流&l;a title=\&q;#基本类型流\&q; href=\&q;#基本类型流\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;对于基本类型，可以使用其包装类创建流，如 Stream&l;Integer&g;。为了直接将基本类型值存储到流中而不需要进行包装，Stream类库提供了&l;code&g;IntStream、LongStream DoubleStream&l;/code&g;类型，对 short、char、byte、boolean类型使用 IntStream类型，对 float使用DoubleStream类型&l;/p&g;\n&l;p&g;当拥有一个对象流时，可以使用 mapToInt()、mapToLong()或mapToDouble() 方法将其转换成基本类型流.&l;br&g;\n&l;code&g;Stream&a;lt;String&a;gt; words = Stream.of(&a;quot;this&a;quot;,&a;quot;is&a;quot;,&a;quot;a&a;quot;,&a;quot;java&a;quot;,&a;quot;string&a;quot;);&l;/code&g;&l;br&g;\n&l;code&g;IntStream lengths = words.mapToInt(String::length);&l;/code&g;&l;/p&g;\n&l;p&g;要将一个基本类型流转换成一个对象流，可以使用 boxed()方法。&l;br&g;\n&l;code&g;Stream&a;lt;Integer&a;gt; integers = IntStream.range(0,100).boxed();&l;/code&g;&l;br&g;\n基本类型流还定义了许多方法&l;/p&g;\n&l;p&g;Random 类中提供了 ints()、longs()、doubles() 方法，它们返回包含随机数的基本类型流.&l;/p&g;\n&l;h3 id=\&q;并行流\&q;&g;并行流&l;a title=\&q;#并行流\&q; href=\&q;#并行流\&q;&g;&l;/a&g;&l;/h3&g;\n&l;p&g;可以并行执行多个线程, 流使得并行计算变得容易。&l;/p&g;\n&l;figure class=\&q;highlight java\&q;&g;&l;table&g;&l;tr&g;&l;td class=\&q;gutter\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;1&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;2&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;3&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;4&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;5&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;6&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;7&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;8&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;9&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;10&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;11&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;12&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;13&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;14&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;15&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;16&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;17&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;18&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;19&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;20&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;21&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;td class=\&q;code\&q;&g;&l;pre&g;&l;span class=\&q;line\&q;&g;&l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;class&l;/span&g; &l;span class=\&q;title class_\&q;&g;Main&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;type\&q;&g;long&l;/span&g; &l;span class=\&q;title function_\&q;&g;fibonacci&l;/span&g;&l;span class=\&q;params\&q;&g;(&l;span class=\&q;type\&q;&g;long&l;/span&g; n)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;if&l;/span&g;( n == &l;span class=\&q;number\&q;&g;1&l;/span&g; || n == &l;span class=\&q;number\&q;&g;2&l;/span&g;) &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;            &l;span class=\&q;keyword\&q;&g;return&l;/span&g; &l;span class=\&q;number\&q;&g;1&l;/span&g;;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;keyword\&q;&g;return&l;/span&g; fibonacci(n-&l;span class=\&q;number\&q;&g;1&l;/span&g;) + fibonacci(n-&l;span class=\&q;number\&q;&g;2&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &l;span class=\&q;keyword\&q;&g;public&l;/span&g; &l;span class=\&q;keyword\&q;&g;static&l;/span&g; &l;span class=\&q;keyword\&q;&g;void&l;/span&g; &l;span class=\&q;title function_\&q;&g;main&l;/span&g;&l;span class=\&q;params\&q;&g;(String[] args)&l;/span&g; &a;#123;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        List&a;lt;Integer&a;gt; nums = Arrays.asList(&l;span class=\&q;number\&q;&g;10&l;/span&g;, &l;span class=\&q;number\&q;&g;20&l;/span&g;, &l;span class=\&q;number\&q;&g;30&l;/span&g; ,&l;span class=\&q;number\&q;&g;40&l;/span&g;, &l;span class=\&q;number\&q;&g;41&l;/span&g;, &l;span class=\&q;number\&q;&g;42&l;/span&g;, &l;span class=\&q;number\&q;&g;43&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Instant&l;/span&g; &l;span class=\&q;variable\&q;&g;start&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; Instant.now();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        nums.parallelStream().map(i-&a;gt;fibonacci(i)).forEach(System.out::println);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        &l;span class=\&q;type\&q;&g;Instant&l;/span&g; &l;span class=\&q;variable\&q;&g;end&l;/span&g; &l;span class=\&q;operator\&q;&g;=&l;/span&g; Instant.now();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(&l;span class=\&q;string\&q;&g;&a;quot;parallelStream period:  &a;quot;&l;/span&g; + Duration.between(start, end).toMillis() + &l;span class=\&q;string\&q;&g;&a;quot;ms&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        start = Instant.now();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        nums.stream().map(i-&a;gt;fibonacci(i)).forEach(System.out::println);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        end = Instant.now();&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;        System.out.println(&l;span class=\&q;string\&q;&g;&a;quot;sequentialStream period:  &a;quot;&l;/span&g; + Duration.between(start, end).toMillis() + &l;span class=\&q;string\&q;&g;&a;quot;ms&a;quot;&l;/span&g;);&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;    &a;#125;&l;/span&g;&l;br&g;&l;span class=\&q;line\&q;&g;&a;#125;&l;/span&g;&l;br&g;&l;/pre&g;&l;/td&g;&l;/tr&g;&l;/table&g;&l;/figure&g;\n&l;p&g;&l;img src=\&q;https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305171337039.png\&q; alt=\&q;\&q; loading=\&q;lazy\&q; class=\&q;φbp\&q;&g;&l;/p&g;\n&l;p&g;从结果可以看到，使用并行流计算时间要比使用顺序流短。使用并行流时，输出也可能不是按顺序输出的。&l;br&g;\n然而，使用并行流并不是总能使程序运行得更快。对某些特定任务，在决定使用并行流之前应该测试并行流是否比顺序流更快。&l;/p&g;\n&l;h2 id=\&q;知识点\&q;&g;知识点&l;a title=\&q;#知识点\&q; href=\&q;#知识点\&q;&g;&l;/a&g;&l;/h2&g;\n&l;ol&g;\n&l;li&g;接口或者更普遍的抽象类, 不能直接实例化对象是应为其中的抽象方法需要实现, 有两种方法可以创建抽象类的对象, 第一种最常见的使用非抽象的子类上转型, 第二种用new初始化的时候给出匿名实现类(相当于给出抽象方法的实现).&l;/li&g;\n&l;/ol&g;\n&l;p&g;&l;strong&g;参考&l;/strong&g;&l;/p&g;\n&l;ol&g;\n&l;li&g;《Java程序设计(第3版)》 IBSN 9787302485520&l;/li&g;\n&l;li&g;&l;a href=\&q;https://docs.oracle.com/en/java/javase/19/docs/api/index.html\&q; target=\&q;_blank\&q;&g;Java API 文档&l;/a&g;&l;/li&g;\n&l;/ol&g;\n&q;,&q;prev&q;:{&q;title&q;:&q;[IDEA]开启断言&q;,&q;link&q;:&q;2023/05/17/[IDEA]开启断言&q;},&q;next&q;:{&q;title&q;:&q;[Notion]搭建个人电子图书馆&q;,&q;link&q;:&q;2023/05/13/[Notion]搭建个人电子图书馆&q;},&q;plink&q;:&q;https://s1acr.github.io/2023/05/17/[Java笔记]泛型&a;集合&a;Stream/&q;,&q;toc&q;:[{&q;id&q;:&q;泛型&q;,&q;title&q;:&q;泛型&q;,&q;index&q;:&q;1&q;,&q;children&q;:[{&q;id&q;:&q;泛型类型&q;,&q;title&q;:&q;泛型类型&q;,&q;index&q;:&q;1.1&q;},{&q;id&q;:&q;通配符&s;？&s;&q;,&q;title&q;:&q;通配符’？’&q;,&q;index&q;:&q;1.2&q;},{&q;id&q;:&q;有界类型参数&q;,&q;title&q;:&q;有界类型参数&q;,&q;index&q;:&q;1.3&q;},{&q;id&q;:&q;类型擦除&q;,&q;title&q;:&q;类型擦除&q;,&q;index&q;:&q;1.4&q;}]},{&q;id&q;:&q;集合框架&q;,&q;title&q;:&q;集合框架&q;,&q;index&q;:&q;2&q;,&q;children&q;:[{&q;id&q;:&q;基本操作&q;,&q;title&q;:&q;基本操作&q;,&q;index&q;:&q;2.1&q;},{&q;id&q;:&q;批量操作&q;,&q;title&q;:&q;批量操作&q;,&q;index&q;:&q;2.2&q;},{&q;id&q;:&q;数组操作&q;,&q;title&q;:&q;数组操作&q;,&q;index&q;:&q;2.3&q;},{&q;id&q;:&q;流(stream)操作&q;,&q;title&q;:&q;流(Stream)操作&q;,&q;index&q;:&q;2.4&q;}]},{&q;id&q;:&q;list-接口及实现类&q;,&q;title&q;:&q;List 接口及实现类&q;,&q;index&q;:&q;3&q;,&q;children&q;:[{&q;id&q;:&q;arraylist类&q;,&q;title&q;:&q;ArrayList类&q;,&q;index&q;:&q;3.1&q;,&q;children&q;:[{&q;id&q;:&q;使用迭代器&q;,&q;title&q;:&q;使用迭代器&q;,&q;index&q;:&q;3.1.1&q;},{&q;id&q;:&q;双向迭代器&q;,&q;title&q;:&q;双向迭代器&q;,&q;index&q;:&q;3.1.2&q;},{&q;id&q;:&q;数组转list对象&q;,&q;title&q;:&q;数组转List对象&q;,&q;index&q;:&q;3.1.3&q;}]},{&q;id&q;:&q;vector-和-stack&q;,&q;title&q;:&q;Vector 和 Stack&q;,&q;index&q;:&q;3.2&q;}]},{&q;id&q;:&q;set接口及其实现类&q;,&q;title&q;:&q;Set接口及其实现类&q;,&q;index&q;:&q;4&q;,&q;children&q;:[{&q;id&q;:&q;hashset-类&q;,&q;title&q;:&q;HashSet 类&q;,&q;index&q;:&q;4.1&q;},{&q;id&q;:&q;用-set-对象实现集合运算&q;,&q;title&q;:&q;用 Set 对象实现集合运算&q;,&q;index&q;:&q;4.2&q;},{&q;id&q;:&q;treeset-类&q;,&q;title&q;:&q;TreeSet 类&q;,&q;index&q;:&q;4.3&q;,&q;children&q;:[{&q;id&q;:&q;对象顺序&q;,&q;title&q;:&q;对象顺序&q;,&q;index&q;:&q;4.3.1&q;}]}]},{&q;id&q;:&q;queue-接口及其实现类&q;,&q;title&q;:&q;Queue 接口及其实现类&q;,&q;index&q;:&q;5&q;,&q;children&q;:[{&q;id&q;:&q;queue-接口和-deque-接口&q;,&q;title&q;:&q;Queue 接口和 Deque 接口&q;,&q;index&q;:&q;5.1&q;},{&q;id&q;:&q;arraydeque-类和-linkedlist-类&q;,&q;title&q;:&q;ArrayDeque 类和 LinkedList 类&q;,&q;index&q;:&q;5.2&q;}]},{&q;id&q;:&q;集合转换&q;,&q;title&q;:&q;集合转换&q;,&q;index&q;:&q;6&q;},{&q;id&q;:&q;map-接口及其实现类&q;,&q;title&q;:&q;Map 接口及其实现类&q;,&q;index&q;:&q;7&q;,&q;children&q;:[{&q;id&q;:&q;基本操作-1&q;,&q;title&q;:&q;基本操作&q;,&q;index&q;:&q;7.1&q;},{&q;id&q;:&q;批量操作-1&q;,&q;title&q;:&q;批量操作&q;,&q;index&q;:&q;7.2&q;},{&q;id&q;:&q;map-接口实现类&q;,&q;title&q;:&q;Map 接口实现类&q;,&q;index&q;:&q;7.3&q;,&q;children&q;:[{&q;id&q;:&q;hashmap-类&q;,&q;title&q;:&q;HashMap 类&q;,&q;index&q;:&q;7.3.1&q;},{&q;id&q;:&q;treemap-类&q;,&q;title&q;:&q;TreeMap 类&q;,&q;index&q;:&q;7.3.2&q;},{&q;id&q;:&q;hashtable-类和-enumeration-接口&q;,&q;title&q;:&q;Hashtable 类和 Enumeration 接口&q;,&q;index&q;:&q;7.3.3&q;}]}]},{&q;id&q;:&q;collections-类&q;,&q;title&q;:&q;Collections 类&q;,&q;index&q;:&q;8&q;},{&q;id&q;:&q;stream-api&q;,&q;title&q;:&q;Stream API&q;,&q;index&q;:&q;9&q;,&q;children&q;:[{&q;id&q;:&q;创建与获得流&q;,&q;title&q;:&q;创建与获得流&q;,&q;index&q;:&q;9.1&q;},{&q;id&q;:&q;连接与限制流&q;,&q;title&q;:&q;连接与限制流&q;,&q;index&q;:&q;9.2&q;},{&q;id&q;:&q;过滤流&q;,&q;title&q;:&q;过滤流&q;,&q;index&q;:&q;9.3&q;},{&q;id&q;:&q;流转换&q;,&q;title&q;:&q;流转换&q;,&q;index&q;:&q;9.4&q;},{&q;id&q;:&q;流规约&q;,&q;title&q;:&q;流规约&q;,&q;index&q;:&q;9.5&q;},{&q;id&q;:&q;收集结果&q;,&q;title&q;:&q;收集结果&q;,&q;index&q;:&q;9.6&q;},{&q;id&q;:&q;基本类型流&q;,&q;title&q;:&q;基本类型流&q;,&q;index&q;:&q;9.7&q;},{&q;id&q;:&q;并行流&q;,&q;title&q;:&q;并行流&q;,&q;index&q;:&q;9.8&q;}]},{&q;id&q;:&q;知识点&q;,&q;title&q;:&q;知识点&q;,&q;index&q;:&q;10&q;}],&q;reward&q;:true,&q;copyright&q;:{&q;author&q;:&q;slacr_&q;,&q;license&q;:&q;&l;a href=\&q;https://creativecommons.org/licenses/by-nc-sa/4.0/\&q; target=\&q;_blank\&q;&g;&l;img src = \&q;/lib/cc-by-nc-sa.svg\&q;&g;CC BY-NC-ND 4.0&l;/a&g;&q;,&q;published&q;:&q;May 17, 2023&q;,&q;updated&q;:&q;May 17, 2023&q;},&q;reading_time&q;:&q;8212 words in 55 min&q;}}</script></head>
<body lang="en"><!-- hexo injector body_begin start --><is-a class="φh" ng-version="12.1.0"><is-k class="φcu"><div class="φdg"><section class="φdh"><header class="φcv"><i class="φda"></i><!----><div issnippet="" class="φcx"><img src="https://thirdqq.qlogo.cn/g?b=oidb&amp;k=ia9j8LGcEXYic3XyY1h1ibnxg&amp;s=0&amp;rand=1680719837">
</div><!----><!----><a href="" class="φcz">slacr_</a><p class="φcy">Crap Programmer, College Student From CN. Idealist and Minimalism, life-long learner. I was lucky to find out what I truly have passion for. 🚬.</p></header><div class="φdl"><a routerlink="/archives" class="φdm" href="/archives"><span>57</span><span>Archives</span></a><a class="φdm" href="/categories/C"><span>16</span><span>Categories</span></a><!----><a routerlink="/tags" class="φdm" href="/tags"><span>3</span><span>Tags</span></a><!----></div><!----><nav class="φdi"><a class="φdj" href="/">Home</a><!----><!----><!----><a class="φdj" href="/search">Search</a><!----><!----><!----><a class="φdj" href="/link">Link</a><!----><!----><!----><a class="φdj" href="/log">Log</a><!----><!----><!----><!----></nav><!----><div issnippet="" class="φb"><is-palette col="5" theme="#673ab7,#3f51b5,#2196f3,#009688,#4caf50,#ff9800,#ff5722,#795548,#607D8B,#2a2b33"></is-palette></div><div issnippet="" class="φb">
</div><div issnippet="" class="φb">
</div><div issnippet="" class="φb">
</div><!----><!----><!----></section><footer class="φdb φdc"><div class="φde"><!----><a target="_blank" rel="external nofollow noopener" class="φdf" title="email me" href="mailto:diogocdiogocosta3346@gmail.com"><i class="iκ-email"></i></a><!----><!----><!----><a target="_blank" rel="external nofollow noopener" class="φdf" title="Feed" href="/atom.xml"><i class="iκ-feed"></i></a><!----><!----><!----><a target="_blank" rel="external nofollow noopener" class="φdf" title="github" href="https://github.com/s1acr"><i class="iκ-github"></i></a><!----><!----><!----><a target="_blank" rel="external nofollow noopener" class="φdf" title="qqGroup" href="https://qm.qq.com/cgi-bin/qm/qr?k=CwUa3gRbNtBAJRLHVwFiM4KZBiuqBSk9&amp;jump_from=webapi&amp;authKey=FhTodgrqXmM0pc0x/fT1U9yAtc6yJlWqoc5qnT5QepMGdVuCUxRlmY3bGklQd7fW"><i class="iκ-qq"></i></a><!----><!----><!----></div><!----><p class="φe">© 2023 <span id="sunflowerArea"><span id="sunflower">🌻</span> <a id="mySign" href="javascript:;"> Slacr F</a></span></p><!----><!----><p class="φe"><span id="busuanzi_container_site_uv" style="display:none">Total <b><span id="busuanzi_value_site_uv"></span></b> Visitors </span><span id="busuanzi_container_site_pv" style="display:none"><b><span id="busuanzi_value_site_pv"></span></b> Views</span><br> Hosted by <a target="_blank" rel="external nofollow" href="https://pages.github.com/"><b>Github Pages</b></a></p><!----></footer></div></is-k><div class="φj"><div class="φi"><div class="φn"><main class="φm"><router-outlet></router-outlet><is-r class="φet"><header class="φfd φfe" style="background-image:;background-color:;"><div class="φfm"><h1 class="φfp">[Java笔记]泛型&amp;集合&amp;Stream</h1><!----><p class="φff"><span class="φfg φfk">May 17, 2023</span><a class="φfg φfi" href="/categories/Java">Java</a><!----><span class="φfg φfj">8212 words in 55 min</span><!----><!----></p><!----><!----></div></header><article itemscope="" itemtype="http://schema.org/Article" class="φew" data-title="[Java笔记]泛型&amp;集合&amp;Stream"><div itemprop="articleBody" issnippet="" iszoomable="" class="φe"><blockquote>
<p>Java 笔记</p>
</blockquote>
<h2 id="泛型">泛型<a title="#泛型" href="#泛型"></a></h2>
<p>泛型是Java5引进的新特征，是类和接口的一种扩展机制，主要实现<code>参数化类型(parameterized type)</code>机制。泛型被广泛应用在 Java 集合API 中，在Java集合框架中大多数的类和接口都是泛型类型。使用泛型，程序员可以编写更安全的程序.</p>
<h3 id="泛型类型">泛型类型<a title="#泛型类型" href="#泛型类型"></a></h3>
<p>泛型 (generics) 是带一个或多个类型参数 (type parameter) 的类或接口。<br>
按照约定，类型参数名使用单个大写字母表示。常用的类型参数名有E (表示元素)、K (表示键)、 N (表示数字)、 T (表示类型)、 V (表示值)等<br>
泛型参数不能是原始数据类型 primitive type</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Entry</span>&lt;K, V&gt; {  <span class="comment">// 泛型接口</span></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Entry</span>&lt;K, V&gt; {   <span class="comment">// 泛型类</span></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(K key, V value)</span>{</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span> {<span class="built_in">this</span>.key = key;}</span><br><span class="line">    <span class="keyword">public</span>  K <span class="title function_">getKey</span><span class="params">()</span> {<span class="keyword">return</span> key;}</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span> {<span class="built_in">this</span>.value = value;}</span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> {<span class="keyword">return</span> value;}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">getType</span><span class="params">(T t, K k, V v)</span> {   <span class="comment">// 泛型方法, 泛型参数表位置在返回值前</span></span><br><span class="line">        System.out.println(t.getClass().getName());</span><br><span class="line">        System.out.println(k.getClass().getName());</span><br><span class="line">        System.out.println(v.getClass().getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Pair&lt;String, Integer&gt; p_1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">"slacr"</span>, <span class="number">19</span>);</span><br><span class="line">        Pair&lt;String, Integer&gt; p_2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">"hacker"</span>, <span class="number">20</span>);</span><br><span class="line">        Pair&lt;Pair, Pair&gt; pp = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(p_1, p_2);</span><br><span class="line">        System.out.println(pp.getKey().getKey());</span><br><span class="line">        System.out.println(pp.getKey().getValue());</span><br><span class="line"></span><br><span class="line">        pp.&lt;Integer&gt;getType(<span class="number">2</span>, pp, p_1 );   <span class="comment">// 注意类型位置在方法名前， C++中是在后</span></span><br><span class="line">        <span class="comment">//java.lang.Integer</span></span><br><span class="line">        <span class="comment">//generics.Pair</span></span><br><span class="line">        <span class="comment">//generics.Pair</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="通配符'？'">通配符’？’<a title="#通配符'？'" href="#通配符'？'"></a></h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;<span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;T&gt; list)</span> { <span class="comment">// 通配符的存在相当于让方法参数化便于传入类型的多样，但在类中无法使用参数化的类型</span></span><br><span class="line">        <span class="keyword">for</span>(Object e : list) {              <span class="comment">// 这样也能实现一样的效果， 只不过通配符是让编译器识别</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList_1</span><span class="params">(List&lt;?&gt; list)</span> {</span><br><span class="line">        <span class="keyword">for</span>(Object e : list) {</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"slacr"</span>);</span><br><span class="line">        list.add(<span class="string">"foo"</span>);</span><br><span class="line">        list.add(<span class="string">"bar"</span>);</span><br><span class="line">        <span class="comment">// Main.&lt;String&gt;printList(list);</span></span><br><span class="line">        printList(list); <span class="comment">// 也可以让编译器自动识别，</span></span><br><span class="line">        printList_1(list);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="有界类型参数">有界类型参数<a title="#有界类型参数" href="#有界类型参数"></a></h3>
<p><code>有界类型参数 (bounded type parameter)</code>。 有界类型分为上界和下界，上界用 extends指定，下界用super指定。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="comment">//public static double getAvg(List&lt;? extends Number &gt; list){  // extends指定上界为Number, 只能传Number或其子类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;U <span class="keyword">extends</span> <span class="title class_">Number</span> &amp; java.io.Serializable&gt; <span class="type">double</span> <span class="title function_">getAvg</span><span class="params">(List&lt;U&gt; list)</span>{   <span class="comment">// 或者这么写, 不用通配符</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0D</span>;                                  <span class="comment">// 下界用 super 关键词指定, 实现接口用 &amp;</span></span><br><span class="line">        <span class="keyword">for</span> (Number number : list) {</span><br><span class="line">            total += number.doubleValue();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> total/list.size();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        integerList.add(<span class="number">1</span>);</span><br><span class="line">        integerList.add(<span class="number">2</span>);</span><br><span class="line">        integerList.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(getAvg(integerList));</span><br><span class="line"></span><br><span class="line">        List&lt;Float&gt; floatList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        floatList.add(<span class="number">3F</span>);</span><br><span class="line">        floatList.add(<span class="number">4F</span>);</span><br><span class="line">        System.out.println(getAvg(floatList));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="类型擦除">类型擦除<a title="#类型擦除" href="#类型擦除"></a></h3>
<p>当实例化泛型类型时，编译器使用一种叫<code>类型擦除 (type erasure)</code>的技术转换这些类型。在编译时，编译器将清除类和方法中所有与类型参数有关的信息。类型擦除可让使用泛型的Java应用程序与之前不使用泛型类型的 Java类库和应用程序兼容</p>
<p>例如，<code>Node&lt;Integer&gt;被转换成 Node, 它称为源类型 (raw type)</code>。源类型是不带任何类型参数的泛型类或接口名。这说明在运行时找不到泛型类使用的是什么类型。</p>
<p>也就是说泛型类在编译时泛型参数的类型是不可确定的, 只有在实例化对象时才能确定, 因此定义泛型类或方法的时候只能声明存在该参数类型的变量, 而不能直接使用, 像 new T() 或者赋值.</p>
<h2 id="集合框架">集合框架<a title="#集合框架" href="#集合框架"></a></h2>
<p>Java 提供了一个集合框架 (Collections Framework), 该框架定义了一组接口和类, 使得处理对象组更容易。</p>
<p><code>集合是指集中存放一组对象的一个对象</code>。集合相当于一个容器，提供了保存、获取和操作其他元素的方法。集合能够帮助Java程序员轻松地管理对象。 Java 集合框架由两种类型构成，一个是<code>Collection</code>; 另一个是<code>Map</code>。Collection 对象用于存放一组对象， Map 对象用于存放一组“关键字/值”的对象。 Collection和 Map 是最基本的接口，它们又有子接口.</p>
<p><img src="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305161320016.png" alt="" loading="lazy" class="φbp"></p>
<p>Collection<e>接口是所有集合类型的根接口，继承了 Iterable<e>接口. Collection接口定义了集合操作的常用方法，这些方法可以简单分为<code>基本操作、批量操作、数组操作和流操作</code>。</e></e></p>
<h3 id="基本操作">基本操作<a title="#基本操作" href="#基本操作"></a></h3>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>boolean add(E e)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>boolean remove(Object o)</code></td>
<td style="text-align:left">删除首次出现元素 o</td>
</tr>
<tr>
<td style="text-align:left"><code>boolean contains(Object o)</code></td>
<td style="text-align:left">返回集合中是否包含指定的元素o。</td>
</tr>
<tr>
<td style="text-align:left"><code>boolean isEmpty()</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>int size()</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>Iterator iterator()</code></td>
<td style="text-align:left">返回包含所有元素的迭代器对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>default void forEach(Consumer&lt;? super T&gt;action)</code></td>
<td style="text-align:left">从父接口继承的方法，在集合的每个元素上执行指定的操作。</td>
</tr>
</tbody>
</table></div></div><h3 id="批量操作">批量操作<a title="#批量操作" href="#批量操作"></a></h3>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td>
<td style="text-align:left">将集合 c 中的所有元素添加到当前集合中。</td>
</tr>
<tr>
<td style="text-align:left"><code>boolean removeAll(Collection&lt;?&gt;c)</code></td>
<td style="text-align:left">从当前集合中删除c 中的所有元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>default boolean removeif(Predicate&lt;? super E&gt; filter)</code></td>
<td style="text-align:left">从当前集合中删除满足谓词的所有元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>boolean containsAll(Collection&lt;?&gt;c)</code></td>
<td style="text-align:left">返回当前集合是否包含c 中的所有元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>boolean retainAll(Collection&lt;?&gt;c)</code></td>
<td style="text-align:left">在当前集合中只保留指定集合 c 中的元素，其他元素删除。</td>
</tr>
<tr>
<td style="text-align:left"><code>void clear()</code></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table></div></div><h3 id="数组操作">数组操作<a title="#数组操作" href="#数组操作"></a></h3>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Object[] toArray()</code></td>
<td style="text-align:left">返回包含集合中所有元素的对象数组。</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;T&gt;T[] toArray(T[] a)</code></td>
<td style="text-align:left">返回包含集合中所有元素的数组，返回数组的元素类型是指定的数组类型</td>
</tr>
</tbody>
</table></div></div><p>Object[] a = c.toArray(); 将Collection对象转换为Object数组.</p>
<h3 id="流(stream)操作">流(Stream)操作<a title="#流(stream)操作" href="#流(stream)操作"></a></h3>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public default Stream&lt;E&gt; stream()</code></td>
<td style="text-align:left">以当前集合作为源返回一个顺序 Stream对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>public default Stream&lt;E&gt; paralellStream()</code></td>
<td style="text-align:left">以当前集合作为源返回一个并行 Stream对象。</td>
</tr>
</tbody>
</table></div></div><h2 id="list-接口及实现类">List 接口及实现类<a title="#list-接口及实现类" href="#list-接口及实现类"></a></h2>
<p>List接口是 Collection的子接口，实现一种线性表的数据结构.</p>
<p><img src="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305161332445.png" alt="" loading="lazy" class="φbp"></p>
<p>List 接口除继承 Collection的方法外，还定义了一些自己的方法。</p>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>E get(int index)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>E set(int index,E element)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>void add(int index, E element)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>E remove(int index)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>abstract boolean addAll(int index, Collection&lt;? extends E&gt; c)</code></td>
<td style="text-align:left">在指定下标处插入集合c 中的全部元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>int indexOf(Object o)</code></td>
<td style="text-align:left">查找指定对象第一次出现的位置。</td>
</tr>
<tr>
<td style="text-align:left"><code>int lastIndexOf(Object o)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>List&lt;E&gt;subList(int from,int to)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>default void replaceAll(UnaryOperator&lt;E&gt; operator)</code></td>
<td style="text-align:left">将操作符应用于元素，并使用其结果替代每个元素。</td>
</tr>
</tbody>
</table></div></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// List 接口不能直接实例化, 但能通过子类上转型来实现</span></span><br><span class="line">        List&lt;Character&gt; characterList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            characterList.add((<span class="type">char</span>)(<span class="string">'A'</span>+i));</span><br><span class="line">            System.out.println(characterList.get(i));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="arraylist类">ArrayList类<a title="#arraylist类" href="#arraylist类"></a></h3>
<p>ArrayList是最常用的线性表实现类，通过数组实现的集合对象。 ArrayList类实际上实现了一个<code>变长的对象数组</code>，其元素可以动态地增加和删除。它的定位访问时间是常量时间。</p>
<p>ArrayList() 创建一个空的数组线性表对象，默认初始容量是10。<br>
ArrayList(Collection c) 用集合c 中的元素创建一个数组线性表对象.<br>
ArrayList(int initialCapacity)</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayList&lt;String&gt; stringArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        stringArrayList.add(<span class="string">"how "</span>);</span><br><span class="line">        stringArrayList.add(<span class="string">"are "</span>);</span><br><span class="line">        stringArrayList.add(<span class="string">"you "</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : stringArrayList) {  <span class="comment">// 增强的 for 循环, 不仅仅可以用来遍历数组, 还可以用来遍历 集合 , 实现了collection 接口的实例</span></span><br><span class="line">            System.out.print(s);</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">        stringArrayList.forEach((s) -&gt; System.out.print(s));  <span class="comment">// 使用 forEach 方法, 跟 js 太像了</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        stringArrayList.forEach(System.out::print);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="使用迭代器">使用迭代器<a title="#使用迭代器" href="#使用迭代器"></a></h4>
<p>迭代器是一个可以遍历集合中每个元素的对象。调用集合对象的 <code>iterator()</code> 方法可以得到 Iterator对象</p>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>boolean hasNext()</code></td>
<td style="text-align:left">返回迭代器中是否还有对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>E next()</code></td>
<td style="text-align:left">返回迭代器中下一个对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>void remove()</code></td>
<td style="text-align:left">删除迭代器中的当前对象</td>
</tr>
</tbody>
</table></div></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayList&lt;String&gt; stringArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        stringArrayList.add(<span class="string">"how "</span>);</span><br><span class="line">        stringArrayList.add(<span class="string">"are "</span>);</span><br><span class="line">        stringArrayList.add(<span class="string">"you "</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; stringIterator = stringArrayList.iterator();</span><br><span class="line">        stringIterator.next();   <span class="comment">// 一开始是首元素前， 移动到第一个元素位置</span></span><br><span class="line">        stringIterator.remove();</span><br><span class="line">        <span class="keyword">while</span> (stringIterator.hasNext()) {      <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">            System.out.printf(stringIterator.next()); <span class="comment">// next() 返回容器中对象后自增</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="双向迭代器">双向迭代器<a title="#双向迭代器" href="#双向迭代器"></a></h4>
<p>List还提供了listIterator() 方法返回ListIterator对象。它可以从前后两个方向遍历线性表中元素，在迭代中修改元素以及获得元素的当前位置。ListIterator是Iterator的子接口，不但继承了Iterator接口中的方法，还定义了自己的方法。</p>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>E next()</code></td>
<td style="text-align:left">返回下一个元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>boolean hasPrevious()</code></td>
<td style="text-align:left">返回是否还有前一个元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>E previous()</code></td>
<td style="text-align:left">返回前一个元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>int nextIndex()</code></td>
<td style="text-align:left">返回下一个元素的索引。</td>
</tr>
<tr>
<td style="text-align:left"><code>int previousIndex()</code></td>
<td style="text-align:left">返回前一个元素的索引。</td>
</tr>
<tr>
<td style="text-align:left"><code>void remove()</code></td>
<td style="text-align:left">删除当前元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>void set(E o)</code></td>
<td style="text-align:left">修改当前元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>void add(E o)</code></td>
<td style="text-align:left">在当前位置插入一个元素</td>
</tr>
</tbody>
</table></div></div><p>使用迭代器可以修改线性表中的元素，但不能同时使用两个迭代器修改一个线性表中的元素，否则将抛出异常。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayList&lt;String&gt; stringArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        stringArrayList.add(<span class="string">"how "</span>);</span><br><span class="line">        stringArrayList.add(<span class="string">"are "</span>);</span><br><span class="line">        stringArrayList.add(<span class="string">"you "</span>);</span><br><span class="line"></span><br><span class="line">        ListIterator&lt;String&gt; stringListIterator = stringArrayList.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (stringListIterator.hasNext()) stringListIterator.next();</span><br><span class="line">        <span class="keyword">while</span> (stringListIterator.hasPrevious()) System.out.println(stringListIterator.previous()); <span class="comment">// 逆向遍历</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="数组转list对象">数组转List对象<a title="#数组转list对象" href="#数组转list对象"></a></h4>
<p>java.util.Arrays 类提供了一个 asList()方法，实现将数组转换成 List对象的功能.</p>
<p><code>public static &lt;T&gt; List&lt;T&gt; asList(T ...a)</code></p>
<p>该方法提供了一个从多个元素创建 List 对象的途径，它的功能与 <code>Collection 接口的 toArray()</code>方法相反.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayList&lt;String&gt; stringArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        stringArrayList.add(<span class="string">"how "</span>);</span><br><span class="line">        stringArrayList.add(<span class="string">"are "</span>);</span><br><span class="line">        stringArrayList.add(<span class="string">"you "</span>);</span><br><span class="line"></span><br><span class="line">        String[] strings = stringArrayList.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (String string : strings) {</span><br><span class="line">            System.out.print(string + <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">        List&lt;String&gt; stringList =  Arrays.asList(strings);  <span class="comment">// asList()底层其实就是 调用ArrayList(... a) 构造</span></span><br><span class="line">        stringList.forEach(System.out::print);</span><br><span class="line">        List&lt;String&gt; stringList1 = Arrays.asList(<span class="string">"seize"</span>, <span class="string">"the"</span>, <span class="string">"moment"</span>);</span><br><span class="line">        stringList1.forEach(s-&gt;{System.out.print(s + <span class="string">" "</span>);});</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="vector-和-stack">Vector 和 Stack<a title="#vector-和-stack" href="#vector-和-stack"></a></h3>
<p>Vector类和Stack类是Java早期版本提供的两个集合类，分别实现<code>向量和对象栈</code>。Vector类和 Stack类的方法都是<code>同步的</code>，适合在<code>多线程</code>的环境中使用.</p>
<h2 id="set接口及其实现类">Set接口及其实现类<a title="#set接口及其实现类" href="#set接口及其实现类"></a></h2>
<p>Set 接口是 Collection的子接口，Set 接口对象类似于数学上的集合概念，其中<code>不允许有重复的元素</code>。 Set 接口没有定义新的方法，只包含从Collection接口继承的方法。<br>
Set 接口的常用实现类有 <code>HashSet 类、 TreeSet 类和 LinkedHashSet类</code> 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305161456356.png" alt="" loading="lazy" class="φbp"></p>
<h3 id="hashset-类">HashSet 类<a title="#hashset-类" href="#hashset-类"></a></h3>
<p>HashSet类用散列方法存储元素，具有最好的存取性能，但元素没有顺序。<br>
Hashing 散列算法最重要的就是 hash函数, 通过实际值与生成哈希值的单射完成高效存取.</p>
<p><code>HashSet()</code>  创建一个空的散列集合，该集合的默认初始容量是16, 默认装填因子(loadfactor) 是0.75。装填因子决定何时对散列表进行再散列。例如，如果装填因子为0.75(默认值), 而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说，装填因子为75%是比较合理的。</p>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>HashSet(Collection c)</code></td>
<td style="text-align:left">用指定的集合c 的元素创建一个散列集合。</td>
</tr>
<tr>
<td style="text-align:left"><code>HashSet(int initialCapacity)</code></td>
<td style="text-align:left">创建一个散列集合，并指定集合的初始容量。</td>
</tr>
<tr>
<td style="text-align:left"><code>HashSet(int initialCapacity, float loadFactor)</code></td>
<td style="text-align:left">创建一个散列集合，并指定的集合初始容量和装填因子</td>
</tr>
</tbody>
</table></div></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Set&lt;String&gt; words =<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        words.add(<span class="string">"one"</span>);</span><br><span class="line">        words.add(<span class="string">"two"</span>);</span><br><span class="line">        words.add(<span class="string">"three"</span>);</span><br><span class="line">        words.add(<span class="string">"one"</span>);       <span class="comment">// 重复元素无效</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) {</span><br><span class="line">            System.out.println(word);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="用-set-对象实现集合运算">用 Set 对象实现集合运算<a title="#用-set-对象实现集合运算" href="#用-set-对象实现集合运算"></a></h3>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>sl.addAll(s2)</code></td>
<td style="text-align:left">实现集合sl 与 s2 的并运算。</td>
</tr>
<tr>
<td style="text-align:left"><code>sl.retainAll(s2)</code></td>
<td style="text-align:left">实现集合 s1与 s2 的交运算。</td>
</tr>
<tr>
<td style="text-align:left"><code>sl.removeAll(s2)</code></td>
<td style="text-align:left">实现集合 s1 与 s2 的差运算。</td>
</tr>
<tr>
<td style="text-align:left"><code>sl.containAll(s2)</code></td>
<td style="text-align:left">如果 s2是 s1 的子集，该方法返回 true。</td>
</tr>
</tbody>
</table></div></div><h3 id="treeset-类">TreeSet 类<a title="#treeset-类" href="#treeset-类"></a></h3>
<p>TreeSet实现一种树集合，使用<code>红-黑树</code>为元素排序，添加到 TreeSet 中的元素必须是可比较的，即元素的类必须实现 <code>Comparable&lt;T&gt;</code> 接口。它的操作要比 HashSet 慢。</p>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>TreeSet(Collection c)</code></td>
<td style="text-align:left">用指定集合c 中的元素创建一个新的树集合，集合中的元素按自然顺序排序。</td>
</tr>
<tr>
<td style="text-align:left"><code>TreeSet(Comparator c)</code></td>
<td style="text-align:left">创建一个空的树集合，元素的排序规则按给定的比较器c 的规则排序。</td>
</tr>
<tr>
<td style="text-align:left"><code>TreeSet(SortedSet s)</code></td>
<td style="text-align:left">用 SortedSet 对象 s 中的元素创建一个树集合，排序规则与 s 的排序规则相同。</td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>E first()</code></td>
<td style="text-align:left">返回有序集合中的第一个元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>E last()</code></td>
<td style="text-align:left">返回有序集合中最后一个元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>SortedSet&lt;E&gt; subSet(E fromElement, E toElement)</code></td>
<td style="text-align:left">返回有序集合中的一个子有序集合，它的元素从 fromElement 开始到 toElement结束(不包括最后元素)。</td>
</tr>
<tr>
<td style="text-align:left"><code>SortedSet&lt;E&gt; headSet(E toElement)</code></td>
<td style="text-align:left">返回有序集合中小于指定元素 toElement 的一个子有序集合。</td>
</tr>
<tr>
<td style="text-align:left"><code>SortedSet&lt;E&gt; tailSet(E fromElement)</code></td>
<td style="text-align:left">返回有序集合中大于等于 fromElement 元素的子有序集合。</td>
</tr>
<tr>
<td style="text-align:left"><code>Comparator&lt;? super E&gt; comparator()</code></td>
<td style="text-align:left">返回与该有序集合相关的比较器，如果集合使用自然顺序则返回 null</td>
</tr>
</tbody>
</table></div></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        String[] strings = {<span class="string">"Swift"</span>, <span class="string">"TypeScript"</span>, <span class="string">"Scala"</span>, <span class="string">"Lisp"</span>, <span class="string">"VBScript"</span>, <span class="string">"Basic"</span>};</span><br><span class="line">        TreeSet&lt;String&gt; stringSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strings.length; i++) {</span><br><span class="line">            stringSet.add(strings[i]);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(stringSet);  <span class="comment">// 按自然顺序排列 // [Basic, Lisp, Scala, Swift, TypeScript, VBScript]</span></span><br><span class="line">        SortedSet&lt;String&gt; sortedSet = stringSet.subSet(<span class="string">"Lisp"</span>, <span class="string">"Swift"</span>);</span><br><span class="line">        System.out.println(sortedSet);  <span class="comment">// [Lisp, Scala]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="对象顺序">对象顺序<a title="#对象顺序" href="#对象顺序"></a></h4>
<p>创建 TreeSet 类对象时如果没有指定比较器对象，集合中的元素按自然顺序排列。所谓自然顺序(natural order)是指集合对象实现了 <code>Comparable 接口的 compareTo()方法</code>，对象则根据该方法排序。如果试图对没有实现 Comparable 接口的集合元素排序，将抛出ClassCastException 异常。另一种排序方法是创建 TreeSet 对象时指定一个比较器对象，这样，元素将按比较器的规则排序。如果需要指定新的比较规则，可以定义一个类实现Comparator 接口，然后为集合提供一个新的比较器.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        String[] strings = {<span class="string">"Swift"</span>, <span class="string">"TypeScript"</span>, <span class="string">"Scala"</span>, <span class="string">"Lisp"</span>, <span class="string">"VBScript"</span>, <span class="string">"Basic"</span>};</span><br><span class="line">        <span class="comment">// TreeSet&lt;String&gt; stringSet = new TreeSet&lt;&gt;(Comparator.reverseOrder());   </span></span><br><span class="line">        <span class="comment">// 传个Comparator 比较器对象使Set红黑树按指定顺序进入</span></span><br><span class="line">        TreeSet&lt;String&gt; stringSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((String s1, String s2) -&gt; s2.compareTo(s1));  <span class="comment">// 或者Lambda表达式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strings.length; i++) {</span><br><span class="line">            stringSet.add(strings[i]);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(stringSet);   </span><br><span class="line">        <span class="comment">// [VBScript, TypeScript, Swift, Scala, Lisp, Basic]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="queue-接口及其实现类">Queue 接口及其实现类<a title="#queue-接口及其实现类" href="#queue-接口及其实现类"></a></h2>
<p>Queue接口是Collection的子接口，是以先进先出 (first in first out,FIFO)的方式排列其元素，一般称为队列。</p>
<p>Deque 接口对象实现双端队列，ArrayDeque 和 LinkedList 是它的两个实现类。<br>
PriorityQueue 实现的是一种优先队列，优先队列中元素的顺序是根据元素的值排列的.</p>
<p><img src="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305162100313.png" alt="" loading="lazy" class="φbp"></p>
<h3 id="queue-接口和-deque-接口">Queue 接口和 Deque 接口<a title="#queue-接口和-deque-接口" href="#queue-接口和-deque-接口"></a></h3>
<p>Queue 接口除了提供 Collection的操作外, 还提供了插入、删除和检查操作。</p>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>boolean add(E e)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>boolean offer(E e)</code></td>
<td style="text-align:left">将指定的元素 e 插入到队列中。 失败add抛出异常, offer返回false</td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>E remove()</code></td>
<td style="text-align:left">返回队列头元素，同时将其删除。</td>
</tr>
<tr>
<td style="text-align:left"><code>E poll()</code></td>
<td style="text-align:left">返回队列头元素，同时将其删除。 失败remove抛出异常, poll返回null</td>
</tr>
<tr>
<td style="text-align:left">&nbsp;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>E element()</code></td>
<td style="text-align:left">返回队列头元素，但不将其删除。</td>
</tr>
<tr>
<td style="text-align:left"><code>E peek() </code></td>
<td style="text-align:left">返回队列头元素，但不将其删除。 失败element抛出异常, peek返回null</td>
</tr>
</tbody>
</table></div></div><p>Queue 接口的每种操作都有两种形式：一个是在操作失败时抛出异常；另一个是在操作失败时返回一个特定的值(根据操作的不同，可能返回 null或 false)</p>
<p>Deque 接口实现双端队列，支持从两端插入和删除元素，同时实现了 Stack 和 Queue 的功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305162112698.png" alt="" loading="lazy" class="φbp"></p>
<p>第一个方法在操作失败时抛出异常；第二个方法操作失败返回一个特殊值。除表中定义的基本方法外, Deque 接口还定义了 removeFirstOccurence() 和 removeLastOccurence()方法，分别用于删除第一次出现的元素，删除最后出现的元素.</p>
<h3 id="arraydeque-类和-linkedlist-类">ArrayDeque 类和 LinkedList 类<a title="#arraydeque-类和-linkedlist-类" href="#arraydeque-类和-linkedlist-类"></a></h3>
<p>Deque 的常用实现类包括 <code>ArrayDeque类和LinkedList</code>类，前者是<code>可变数组</code>的实现；后者是<code>线性表</code>的实现。LinkedList类比 ArayDeque类更灵活，实现了线性表的所有操作，其中可以存储null元素，但ArrayDeque 对象不能存储null.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayDeque&lt;String&gt; arrayDeque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        arrayDeque.add(<span class="string">"till "</span>);</span><br><span class="line">        arrayDeque.offerFirst(<span class="string">"it "</span>);</span><br><span class="line">        arrayDeque.addFirst(<span class="string">"fake "</span>);</span><br><span class="line">        arrayDeque.offerLast(<span class="string">"you "</span>);</span><br><span class="line">        arrayDeque.add(<span class="string">"make "</span>);</span><br><span class="line">        arrayDeque.addLast(<span class="string">"it. "</span>);</span><br><span class="line">        </span><br><span class="line">        arrayDeque.forEach(System.out::print);</span><br><span class="line">        arrayDeque.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> {</span><br><span class="line">                System.out.print(s);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        arrayDeque.forEach(x -&gt; System.out.print(x));</span><br><span class="line">        Iterator&lt;String&gt; stringIterator = arrayDeque.iterator();</span><br><span class="line">        <span class="keyword">while</span>(stringIterator.hasNext()) System.out.print(stringIterator.next());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : arrayDeque) { System.out.print(s);}</span><br><span class="line">        <span class="comment">// 几种遍历练习练习</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>LinkedList允许null元素, 如果需要经常在线性表的头部添加元素或在内部删除元素，就应该使用LinkedList。这些操作在LinkedList中是常量时间，在ArrayList中是线性时间。而对定位访问LinkedList是线性时间，ArrayList是常量时间。<br>
就是链表和顺序表的区别.<br>
<code>LinkedList 同时实现了List 接口和Queue 接口</code>.</p>
<p><code>LinkedList()</code><br>
<code>LinkedList(Collection c)</code><br>
<code>addFirst()、getFirst()、removeFirst()、addLast()、getLast() removeLast()</code>…</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        Queue&lt;String&gt; stringQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        stringQueue.add(<span class="string">"loading..."</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="string">"██████████████████████████████"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; bar.length() + <span class="number">1</span>; i+= <span class="number">3</span>) {</span><br><span class="line">            stringQueue.add(bar.substring(<span class="number">0</span>,i) + <span class="string">"  "</span> + i/<span class="number">3</span>*<span class="number">10</span> + <span class="string">"%"</span>);</span><br><span class="line">        }</span><br><span class="line">        stringQueue.add(<span class="string">"done!"</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stringQueue.isEmpty()) {</span><br><span class="line">            System.out.println(stringQueue.remove());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305162207311.png" alt="" loading="lazy" class="φbp"></p>
<h2 id="集合转换">集合转换<a title="#集合转换" href="#集合转换"></a></h2>
<p>集合实现类的构造方法可以接收一个Collection对象, 转换成该类型的集合. 所以许多集合类型之间可以相互转换.</p>
<p><code>public ArrayList(Collection c)</code><br>
<code>public HashSet(Collection c)</code><br>
<code>public LinkedList(Collection c)</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        HashSet&lt;Integer&gt; integerHashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        integerHashSet.add(<span class="number">1</span>);</span><br><span class="line">        integerHashSet.add(<span class="number">2</span>);</span><br><span class="line">        LinkedList&lt;Integer&gt; integerLinkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(integerHashSet);</span><br><span class="line">        integerLinkedList.add(<span class="number">3</span>);</span><br><span class="line">        integerLinkedList.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(integerLinkedList);  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="map-接口及其实现类">Map 接口及其实现类<a title="#map-接口及其实现类" href="#map-接口及其实现类"></a></h2>
<p>Map 是用来存储“键/值”对的对象。在 Map 中存储的<code>关键字和值都必须是对象</code>，并要求<code>关键字唯一</code>的，而值可以重复.<br>
Map接口常用的实现类有 HashMap类、TreeMap类、Hashtable类和 LinkedHashMap类。</p>
<p><img src="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305162222926.png" alt="" loading="lazy" class="φbp"></p>
<h3 id="基本操作-1">基本操作<a title="#基本操作-1" href="#基本操作-1"></a></h3>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public V put(K key, V value)</code></td>
<td style="text-align:left">向映射对象中添加一个“键/值”对。</td>
</tr>
<tr>
<td style="text-align:left"><code>public V get(Object key)</code></td>
<td style="text-align:left">返回指定键的值。</td>
</tr>
<tr>
<td style="text-align:left"><code>public V remove(Object key)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public boolean containsKey(Object key)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public boolean containsValue(Object value)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>default V replace(K key,V value)</code></td>
<td style="text-align:left">若指定的“键/值”对存在于映射中，用指定的“键/值"对替换之。</td>
</tr>
<tr>
<td style="text-align:left"><code>default void forEach(BiConsumer&lt;? super K,? super V)</code></td>
<td style="text-align:left">对映射中的每项执行一次动作，直到所有项处理完或发生异常。</td>
</tr>
<tr>
<td style="text-align:left"><code>public int size()</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public boolean isEmpty()</code></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table></div></div><h3 id="批量操作-1">批量操作<a title="#批量操作-1" href="#批量操作-1"></a></h3>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>public void putAll(Map&lt;? extends K,? extends V&gt; map)</code></td>
<td style="text-align:left">将参数 map 中的所有“键/值"对添加到映射中。</td>
</tr>
<tr>
<td style="text-align:left"><code>public void clear()</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public Set&lt;K&gt;keySet()</code></td>
<td style="text-align:left">返回由键组成的 Set对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>public Collection&lt;V&gt;values()</code></td>
<td style="text-align:left">返回由值组成的 Collection对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet()</code></td>
<td style="text-align:left">返回包含 Map.Entry&lt;K,V&gt;的一个 Set对象</td>
</tr>
</tbody>
</table></div></div><h3 id="map-接口实现类">Map 接口实现类<a title="#map-接口实现类" href="#map-接口实现类"></a></h3>
<p>常用实现类有<code>HashMap、TreeMap和 Hashtable</code>类</p>
<h4 id="hashmap-类">HashMap 类<a title="#hashmap-类" href="#hashmap-类"></a></h4>
<p>HashMap类以散列方法存放“键/值”对</p>
<p><code>HashMap()</code> 创建一个空的映射对象，使用默认的装填因子(0.75)。<br>
<code>HashMap(int initialCapacity)</code> 用指定初始容量和默认装填因子创建一个映射对象。<br>
<code>HashMap(Map m)</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayList&lt;String&gt;  nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">"slacr"</span>, <span class="string">"John"</span>, <span class="string">"Amy"</span>, <span class="string">"Tim"</span>));</span><br><span class="line">        ArrayList&lt;Integer&gt; scoreList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">60</span>, <span class="number">53</span>, <span class="number">88</span>, <span class="number">99</span>));</span><br><span class="line">        <span class="comment">// Java的方法感觉比C++更好理解, 命名知其义, 注解也很全. 并且IDEA比VS智能多了</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nameList.size(); i++) {</span><br><span class="line">            map.put(nameList.get(i), scoreList.get(i));</span><br><span class="line">        }</span><br><span class="line">        map.forEach((k, v) -&gt; { System.out.printf(<span class="string">"%-10s%d\n"</span>, k, v);});</span><br><span class="line">        <span class="comment">//slacr     60</span></span><br><span class="line">        <span class="comment">//John      53</span></span><br><span class="line">        <span class="comment">//Tim       99</span></span><br><span class="line">        <span class="comment">//Amy       88</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="treemap-类">TreeMap 类<a title="#treemap-类" href="#treemap-类"></a></h4>
<p><code>TreeMap 类实现了SortedMap 接口</code>，保证Map 中的“键/值”对按关键字升序排序。</p>
<p><code>TreeMap()</code><br>
<code>TreeMap(Comparator c)</code><br>
<code>TreeMap(Map m)</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayList&lt;String&gt;  nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">"slacr"</span>, <span class="string">"John"</span>, <span class="string">"Amy"</span>, <span class="string">"Tim"</span>));</span><br><span class="line">        ArrayList&lt;Integer&gt; scoreList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">60</span>, <span class="number">53</span>, <span class="number">88</span>, <span class="number">99</span>));</span><br><span class="line">        TreeMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> {</span><br><span class="line">                <span class="keyword">return</span> scoreList.get(nameList.indexOf(o2)) - scoreList.get(nameList.indexOf(o1));    <span class="comment">// map先放入的后输出</span></span><br><span class="line">            }</span><br><span class="line">        });     <span class="comment">// 按成绩高低排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nameList.size(); i++) {</span><br><span class="line">            map.put(nameList.get(i), scoreList.get(i));</span><br><span class="line">        }</span><br><span class="line">        map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Integer&gt;() {</span><br><span class="line">            <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String k, Integer v)</span> {</span><br><span class="line">                System.out.printf(<span class="string">"No.%-5d%-10s%d\n"</span>,i, k, v);</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">//No.1    Tim       99</span></span><br><span class="line">        <span class="comment">//No.2    Amy       88</span></span><br><span class="line">        <span class="comment">//No.3    slacr     60</span></span><br><span class="line">        <span class="comment">//No.4    John      53</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="hashtable-类和-enumeration-接口">Hashtable 类和 Enumeration 接口<a title="#hashtable-类和-enumeration-接口" href="#hashtable-类和-enumeration-接口"></a></h4>
<p>Hashtable类是 Java 早期版本提供的一个存放“键/值”对的实现类，实现了一种散列表，也属于集合框架。Hashtable类的方法都是同步的，因此它是线程安全的。<br>
任何非null对象都可以作为散列表的关键字和值。但是要求作为关键字的对象必须实现 <code>hashCode()方法和equals()</code>方法，以使对象的比较成为可能。<br>
Hashtable类的 keys()方法和elements()方法的返回类型都是 <code>Enumeration</code> 接口类型的对象，通过该接口中hasMoreElements()方法和nextElement()方法可以对枚举对象元素迭代</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Hashtable&lt;Integer, String&gt; hashtable = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">        hashtable.put(<span class="number">1</span>, <span class="string">"王二"</span>);</span><br><span class="line">        hashtable.put(<span class="number">2</span>, <span class="string">"陈清扬"</span>);</span><br><span class="line">        hashtable.put(<span class="number">3</span>, <span class="string">"罗小四"</span>);</span><br><span class="line">        hashtable.put(<span class="number">4</span>, <span class="string">"军代表"</span>);</span><br><span class="line">        hashtable.put(<span class="number">5</span>, <span class="string">"敦敦伟大友谊"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> hashtable.get(<span class="number">5</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;String&gt; words = hashtable.elements();</span><br><span class="line">        <span class="keyword">while</span> (words.hasMoreElements()) System.out.println(words.nextElement());</span><br><span class="line">        <span class="comment">//敦敦伟大友谊   map 先入后出</span></span><br><span class="line">        <span class="comment">//敦敦伟大友谊</span></span><br><span class="line">        <span class="comment">//军代表</span></span><br><span class="line">        <span class="comment">//罗小四</span></span><br><span class="line">        <span class="comment">//陈清扬</span></span><br><span class="line">        <span class="comment">//王二</span></span><br><span class="line">        <span class="comment">// map一些遍历</span></span><br><span class="line">        hashtable.forEach((k, v) -&gt; System.out.println(k + <span class="string">"  "</span> + v));    <span class="comment">// 遍历键值对</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Integer k : hashtable.keySet()) System.out.print(k + <span class="string">"  "</span>);  <span class="comment">// keySet()返回key的set对象, 遍历键</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        hashtable.keySet().forEach(i-&gt; System.out.print(i+<span class="string">"  "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Integer&gt; it = hashtable.keySet().iterator(); it.hasNext(); )</span><br><span class="line">            System.out.print(it.next()+<span class="string">"  "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        hashtable.values().forEach(System.out::println);   <span class="comment">// values() 返回 Collection 对象</span></span><br><span class="line"></span><br><span class="line">        hashtable.entrySet().forEach((Map.Entry&lt;Integer, String&gt; entry) -&gt; {</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">"  "</span> + entry.getValue());</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">// entrySet() 返回  Set&lt;Map.Entry&lt;K,V&gt;&gt;, 可以再用相当于将Map中每一个Entry条目再组合成一个Set, 可以按Set容器遍历</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="collections-类">Collections 类<a title="#collections-类" href="#collections-类"></a></h2>
<p><code>Collections类是java.util包中定义的工具类</code>，这个类提供了若干static方法实现集合对象的操作。这些操作大多对List操作，主要包括排序、重排、查找、求极值以及常规操作等。</p>
<div class="φbq"><div class="φbs"><table><thead>
<tr>
<th style="padding:0"></th>
<th style="padding:0"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>排序</strong></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public static&lt;T&gt;void sort(List&lt;T&gt;list)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public static&lt;T&gt; void sort(List&lt;T&gt;list, Comparator&lt;? super T&gt;c)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>查找</strong></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public static&lt;T&gt; int binarySearch(List&lt;T&gt; list, T key)</code></td>
<td style="text-align:left">List需要sorted 如果 List包含要查找的元素，方法返回元素的下标，否则返回值为(-插入点-1)</td>
</tr>
<tr>
<td style="text-align:left"><code>public static &lt;T&gt;int binarySearch(List&lt;T&gt; list, T key, Comparator c)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>打乱元素次序</strong></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public static void shuffle(List&lt;?&gt; list)</code></td>
<td style="text-align:left">使用默认的随机数打乱 List中元素的次序。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static void shuffle(List&lt;?&gt; list, Random rnd)</code></td>
<td style="text-align:left">使用指定的Random 对象，打乱List 中元素的次序</td>
</tr>
<tr>
<td style="text-align:left"><strong>求极值</strong></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public static  &lt;T&gt;T max(Collection&lt;? extends T&gt;coll)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public static &lt;T&gt;T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public static &lt;T&gt;T min(Collection&lt;? extends T&gt;coll)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public static &lt;T&gt;T min(Collection&lt;? extends T&gt;coll, Comparator&lt;? super T&gt;comp)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>其他常用</strong></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public static void reverse(List&lt;?&gt;list)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public static void fill(List&lt;? super T&gt;list,T obj)</code></td>
<td style="text-align:left">用指定的值覆盖List中原来的每个值，该方法主要用于对 List进行重新初始化。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public static void swap(List&lt;?&gt;list, int i, int j)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>public static void rotate(List&lt;?&gt; list, int distance)</code></td>
<td style="text-align:left">旋转列表，将 i 位置的元素移动到(i+distance)%list.size() 的位置。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt;c, T ...elements)</code></td>
<td style="text-align:left">该方法用于将指定的元素添加到集合 c 中，可以指定单个元素或数组。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static int frequency(Collection&lt;?&gt;c, Object o)</code></td>
<td style="text-align:left">返回指定的元素o 在集合c 中出现的次数。</td>
</tr>
<tr>
<td style="text-align:left"><code>public static boolean disjoint(Collection&lt;?&gt;cl, Collection&lt;?&gt;c2)</code></td>
<td style="text-align:left">判断两个集合是否不相交。如果两个集合不包含相同的元素，该方法返回 true。</td>
</tr>
</tbody>
</table></div></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ArrayList&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>));</span><br><span class="line">        Collections.sort(integerArrayList, Comparator.reverseOrder());</span><br><span class="line">        System.out.println(integerArrayList);</span><br><span class="line">        Collections.shuffle(integerArrayList);</span><br><span class="line">        System.out.println(integerArrayList);</span><br><span class="line">        Collections.reverse(integerArrayList);</span><br><span class="line">        System.out.println(integerArrayList);</span><br><span class="line">        <span class="comment">//[7, 6, 5, 4, 3, 2, 1]</span></span><br><span class="line">        <span class="comment">//[5, 1, 7, 2, 4, 6, 3]</span></span><br><span class="line">        <span class="comment">//[3, 6, 4, 2, 7, 1, 5]</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">"slacr"</span>, <span class="string">"John"</span>, <span class="string">"Amy"</span>, <span class="string">"Tim"</span>)).get(i),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">60</span>, <span class="number">53</span>, <span class="number">88</span>, <span class="number">99</span>)).get(i));</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Collections.max(map.entrySet(), (entry1, entry2) -&gt; {</span><br><span class="line">            <span class="keyword">return</span> entry1.getValue() - entry2.getValue();</span><br><span class="line">        }));</span><br><span class="line">        <span class="comment">//Tim=99</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="stream-api">Stream API<a title="#stream-api" href="#stream-api"></a></h2>
<p>流 (stream) 就像一个管道，将数据从源传输到目的地。流可分为顺序流和并行流。<br>
流初看起来像集合，但流并不是存储对象的数据结构，仅<code>用来移动数据</code>，因此不能像集合一样向流中添加元素<br>
使用流的主要原因是它支持顺序和并行的聚集操作。例如，可以很容易地过滤、排序或转换流中的元素<br>
Stream接口是最常用的类型。 Stream 对象可用来传输任何类型的对象。还有一些特殊的 Stream,如 IntStream、LongStream、DoubleStream等。上述的 Stream 都派生自 BaseStream。</p>
<p><img src="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305171150522.png" alt="" loading="lazy" class="φbp"></p>
<p>Stream 的有些方法执行中间操作，有些方法执行终止操作。中间操作是将一个流转换成另一个流，sorted、filter和 map 方法执行中间操作。终止操作产生一个最终结果， count、forEach 方法执行终止操作。流操作是延迟的，在源上的计算只有当终止操作开始时才执行.</p>
<h3 id="创建与获得流">创建与获得流<a title="#创建与获得流" href="#创建与获得流"></a></h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// Stream.of() 静态方法创建一个顺序流</span></span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        String[] strings = {<span class="string">"Victor"</span>, <span class="string">"Deque"</span>, <span class="string">"Set"</span>, <span class="string">"Map"</span>};</span><br><span class="line">        Stream&lt;String&gt; stringStream = Arrays.stream(strings);  <span class="comment">// Arrays stream()将数组转换为流对象</span></span><br><span class="line">        <span class="comment">//default java.util.stream.Stream&lt;E&gt; stream();</span></span><br><span class="line">        <span class="comment">//default java.util.stream.Stream&lt;E&gt; parallelStream(); Collection接口中返回流对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;? extends T&gt; s)</span></span><br><span class="line">        Stream&lt;Double&gt; randoms = Stream.generate(Math::random);   <span class="comment">// 无限流</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">        Stream&lt;BigInteger&gt; integerStream = Stream.iterate(BigInteger.ZERO, n-&gt;n.add(BigInteger.ONE));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="连接与限制流">连接与限制流<a title="#连接与限制流" href="#连接与限制流"></a></h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Stream&lt;Integer&gt; s1 = Stream.of(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Stream&lt;Integer&gt; s2 = Stream.of(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">        Stream&lt;Integer&gt; s3 = Stream.of(<span class="number">6</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br><span class="line">        <span class="comment">// Stream.concat(Stream.concat(s1, s2), s3).sorted().forEach(System.out::print); // 123456</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);</span></span><br><span class="line">        Stream.concat(Stream.concat(s1, s2), s3).sorted(Comparator.reverseOrder()).forEach(System.out::print); <span class="comment">// 654321</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        Stream&lt;Double&gt; randoms = Stream.generate(() -&gt; Double.valueOf(String.format(<span class="string">"%.2f"</span>, Math.random()))).limit(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// limit() 限制流长度, 截断流</span></span><br><span class="line">        randoms.forEach(System.out::println);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="过滤流">过滤流<a title="#过滤流" href="#过滤流"></a></h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        stream = stream.filter(i -&gt; i&gt;<span class="number">3</span>);</span><br><span class="line">        stream.forEach(System.out::println); <span class="comment">// 4 5</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Path</span> <span class="variable">parent</span> <span class="operator">=</span> Paths.get(<span class="string">".."</span>);</span><br><span class="line">        Stream&lt;Path&gt; list = Files.walk(parent);</span><br><span class="line">        list.filter((Path p) -&gt; p.toString().endsWith(<span class="string">".java"</span>)).forEach(System.out::println);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="流转换">流转换<a title="#流转换" href="#流转换"></a></h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Stream&lt;Character&gt; characterStream = Stream.of(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">        <span class="comment">//   &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span></span><br><span class="line">        Stream&lt;Integer&gt; integerStream = characterStream.map((character -&gt; {<span class="keyword">return</span> Integer.valueOf(character);}));</span><br><span class="line">        integerStream.forEach(System.out::println);  <span class="comment">// 65 66 67</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="流规约">流规约<a title="#流规约" href="#流规约"></a></h3>
<p>经常需要从流中获得一个结果，如返回流中元素的数量。此时，可以使用流的 count()方法实现。这样的方法称为规约方法 (reduction),规约是终止操作。Stream接口提供了几个简单的规约方法，除count()方法外，还有max()和min()方法，它们分别返回流中的最大值和最小值。需要注意的是，这两个方法返回一个Optional<t>类型的值，它可能会封装返回值，也可能表示没有返回(当流为空时).</t></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Stream&lt;Character&gt; characterStream = Stream.of(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">        <span class="comment">//   &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span></span><br><span class="line">        Stream&lt;Integer&gt; integerStream = characterStream.map((character -&gt; {<span class="keyword">return</span> Integer.valueOf(character);}));</span><br><span class="line">        <span class="comment">// integerStream.forEach(System.out::println);  // 65 66 67</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//   Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);</span></span><br><span class="line">        <span class="comment">// System.out.println(integerStream.max(Comparator.reverseOrder())); Optional[65]</span></span><br><span class="line">        System.out.println(integerStream.max(Comparator.reverseOrder()).get()); <span class="comment">// 65</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="收集结果">收集结果<a title="#收集结果" href="#收集结果"></a></h3>
<p>当处理完流后，可能需要查看结果或将结果收集到其他容器中。可以使用 iterator()方法，该方法可以生成一个能够用来访问元素的传统迭代器。<br>
调用toArray()方法获得一个含有流中所有元素的数组。因为<code>不可能在运行时创建一个泛型数组，所以表达式 stream.toArray()返回一个 Object[]类型数组</code>。如果想获得相应类型数组，可以将类型传递给数组的构造方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Stream&lt;String&gt; stringStream = Stream.of(<span class="string">"gone"</span>, <span class="string">"with"</span>, <span class="string">"the"</span>, <span class="string">"wind"</span>);</span><br><span class="line">        <span class="comment">// &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span></span><br><span class="line">        String[] res = stringStream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(res));</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream1 = Stream.of(<span class="string">"gone"</span>, <span class="string">"with"</span>, <span class="string">"the"</span>, <span class="string">"wind"</span>);</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(stringStream1.toList());</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream2 = Stream.of(<span class="string">"gone"</span>, <span class="string">"with"</span>, <span class="string">"the"</span>, <span class="string">"wind"</span>);</span><br><span class="line">        List&lt;String&gt; list = stringStream2.collect(Collectors.toList());</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream3 = Stream.of(<span class="string">"gone"</span>, <span class="string">"with"</span>, <span class="string">"the"</span>, <span class="string">"wind"</span>);</span><br><span class="line">        Set&lt;String&gt; set = stringStream3.collect(Collectors.toSet());</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream4 = Stream.of(<span class="string">"gone"</span>, <span class="string">"with"</span>, <span class="string">"the"</span>, <span class="string">"wind"</span>);</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> stringStream4.collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//[gone, with, the, wind]</span></span><br><span class="line">        <span class="comment">//[gone, with, the, wind]</span></span><br><span class="line">        <span class="comment">//[gone, with, the, wind]</span></span><br><span class="line">        <span class="comment">//[the, with, gone, wind]</span></span><br><span class="line">        <span class="comment">//[gone, the, wind, with]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="基本类型流">基本类型流<a title="#基本类型流" href="#基本类型流"></a></h3>
<p>对于基本类型，可以使用其包装类创建流，如 Stream<integer>。为了直接将基本类型值存储到流中而不需要进行包装，Stream类库提供了<code>IntStream、LongStream DoubleStream</code>类型，对 short、char、byte、boolean类型使用 IntStream类型，对 float使用DoubleStream类型</integer></p>
<p>当拥有一个对象流时，可以使用 mapToInt()、mapToLong()或mapToDouble() 方法将其转换成基本类型流.<br>
<code>Stream&lt;String&gt; words = Stream.of("this","is","a","java","string");</code><br>
<code>IntStream lengths = words.mapToInt(String::length);</code></p>
<p>要将一个基本类型流转换成一个对象流，可以使用 boxed()方法。<br>
<code>Stream&lt;Integer&gt; integers = IntStream.range(0,100).boxed();</code><br>
基本类型流还定义了许多方法</p>
<p>Random 类中提供了 ints()、longs()、doubles() 方法，它们返回包含随机数的基本类型流.</p>
<h3 id="并行流">并行流<a title="#并行流" href="#并行流"></a></h3>
<p>可以并行执行多个线程, 流使得并行计算变得容易。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">long</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span>( n == <span class="number">1</span> || n == <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;Integer&gt; nums = Arrays.asList(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> ,<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>);</span><br><span class="line">        <span class="type">Instant</span> <span class="variable">start</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        nums.parallelStream().map(i-&gt;fibonacci(i)).forEach(System.out::println);</span><br><span class="line">        <span class="type">Instant</span> <span class="variable">end</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        System.out.println(<span class="string">"parallelStream period:  "</span> + Duration.between(start, end).toMillis() + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">        start = Instant.now();</span><br><span class="line">        nums.stream().map(i-&gt;fibonacci(i)).forEach(System.out::println);</span><br><span class="line">        end = Instant.now();</span><br><span class="line">        System.out.println(<span class="string">"sequentialStream period:  "</span> + Duration.between(start, end).toMillis() + <span class="string">"ms"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305171337039.png" alt="" loading="lazy" class="φbp"></p>
<p>从结果可以看到，使用并行流计算时间要比使用顺序流短。使用并行流时，输出也可能不是按顺序输出的。<br>
然而，使用并行流并不是总能使程序运行得更快。对某些特定任务，在决定使用并行流之前应该测试并行流是否比顺序流更快。</p>
<h2 id="知识点">知识点<a title="#知识点" href="#知识点"></a></h2>
<ol>
<li>接口或者更普遍的抽象类, 不能直接实例化对象是应为其中的抽象方法需要实现, 有两种方法可以创建抽象类的对象, 第一种最常见的使用非抽象的子类上转型, 第二种用new初始化的时候给出匿名实现类(相当于给出抽象方法的实现).</li>
</ol>
<p><strong>参考</strong></p>
<ol>
<li>《Java程序设计(第3版)》 IBSN 9787302485520</li>
<li><a href="https://docs.oracle.com/en/java/javase/19/docs/api/index.html" target="_blank">Java API 文档</a></li>
</ol>
</div><is-e class="φu"><!----><ul class="φy"><li class="φw"><strong class="φx">Author<span>:</span></strong><p class="φv">slacr_</p></li><li class="φw"><strong class="φx">Copyright<span>:</span></strong><p class="φv"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><img src="/lib/cc-by-nc-sa.svg">CC BY-NC-ND 4.0</a></p></li><li class="φw"><strong class="φx">Published<span>:</span></strong><p class="φv">May 17, 2023</p></li><li class="φw"><strong class="φx">Updated<span>:</span></strong><p class="φv">May 17, 2023</p></li><!----></ul><!----></is-e><!----><is-j class="φcm"><p class="φcr">Buy me a cup of coffee ☕.</p><div class="φco"><div class="φct"><a class="φcs φa iκ-wechat" style="color:;"></a><a class="φcs" style="color:;">支</a><!----></div><div class="φcq"><!----></div></div></is-j><!----><div><div issnippet="" class="φb">


<link href="https://cdn.jsdelivr.net/gh/s1acr/my_jsDelivr@main/clipboard.css" rel="stylesheet">
</div><!----></div><!----></article><footer class="φex"><!----><div class="φey"><a class="φez φfb" href="/2023/05/17/%5BIDEA%5D%E5%BC%80%E5%90%AF%E6%96%AD%E8%A8%80">[IDEA]开启断言</a><!----><a class="φez φfa" href="/2023/05/13/%5BNotion%5D%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E5%9B%BE%E4%B9%A6%E9%A6%86">[Notion]搭建个人电子图书馆</a><!----></div><!----></footer><is-d class="φt"><div issnippet=""><div id="vcomments"></div>

</div><!----></is-d><!----><!----><!----></is-r><!----></main><!----></div></div></div><is-f class="φz"><div class="φbi"><span class="φa iκ-up"></span><span class="φa iκ-down"></span><!----><span class="φa iκ-toc"></span><!----><span class="φa iκ-search"></span><!----></div><div class="φbb φbc"><svg class="φbh"><defs><filter id="dp"><feGaussianBlur in="SourceGraphic" stdDeviation="2"></feGaussianBlur></filter></defs><circle filter="url(#dp)" fill="rgba(0,0,0,.3)" cx="50%" cy="52%" r="44%"></circle><circle cx="50%" cy="50%" r="44%" class="φbd"></circle><circle cx="50%" cy="50%" r="48%" class="φbg" stroke-dasharray="0% 314.15926%"></circle><!----><g class="φbe"><circle r=".2rem" cx="0" cy="-.8rem"></circle><circle r=".2rem"></circle><circle r=".2rem" cx="0" cy=".8rem"></circle></g><!----></svg></div></is-f><is-m class="φdq"><div class="φds φdt"><a class="φdv"><span class="φdx">1 </span><!----><span class="φdy">泛型</span></a><div class="φds"><a class="φdv"><span class="φdx">1.1 </span><!----><span class="φdy">泛型类型</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">1.2 </span><!----><span class="φdy">通配符’？’</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">1.3 </span><!----><span class="φdy">有界类型参数</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">1.4 </span><!----><span class="φdy">类型擦除</span></a><!----></div><!----><!----><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">2 </span><!----><span class="φdy">集合框架</span></a><div class="φds"><a class="φdv"><span class="φdx">2.1 </span><!----><span class="φdy">基本操作</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">2.2 </span><!----><span class="φdy">批量操作</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">2.3 </span><!----><span class="φdy">数组操作</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">2.4 </span><!----><span class="φdy">流(Stream)操作</span></a><!----></div><!----><!----><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">3 </span><!----><span class="φdy">List 接口及实现类</span></a><div class="φds"><a class="φdv"><span class="φdx">3.1 </span><!----><span class="φdy">ArrayList类</span></a><div class="φds"><a class="φdv"><span class="φdx">3.1.1 </span><!----><span class="φdy">使用迭代器</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">3.1.2 </span><!----><span class="φdy">双向迭代器</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">3.1.3 </span><!----><span class="φdy">数组转List对象</span></a><!----></div><!----><!----><!----></div><div class="φds"><a class="φdv"><span class="φdx">3.2 </span><!----><span class="φdy">Vector 和 Stack</span></a><!----></div><!----><!----><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">4 </span><!----><span class="φdy">Set接口及其实现类</span></a><div class="φds"><a class="φdv"><span class="φdx">4.1 </span><!----><span class="φdy">HashSet 类</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">4.2 </span><!----><span class="φdy">用 Set 对象实现集合运算</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">4.3 </span><!----><span class="φdy">TreeSet 类</span></a><div class="φds"><a class="φdv"><span class="φdx">4.3.1 </span><!----><span class="φdy">对象顺序</span></a><!----></div><!----><!----><!----></div><!----><!----><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">5 </span><!----><span class="φdy">Queue 接口及其实现类</span></a><div class="φds"><a class="φdv"><span class="φdx">5.1 </span><!----><span class="φdy">Queue 接口和 Deque 接口</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">5.2 </span><!----><span class="φdy">ArrayDeque 类和 LinkedList 类</span></a><!----></div><!----><!----><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">6 </span><!----><span class="φdy">集合转换</span></a><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">7 </span><!----><span class="φdy">Map 接口及其实现类</span></a><div class="φds"><a class="φdv"><span class="φdx">7.1 </span><!----><span class="φdy">基本操作</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">7.2 </span><!----><span class="φdy">批量操作</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">7.3 </span><!----><span class="φdy">Map 接口实现类</span></a><div class="φds"><a class="φdv"><span class="φdx">7.3.1 </span><!----><span class="φdy">HashMap 类</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">7.3.2 </span><!----><span class="φdy">TreeMap 类</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">7.3.3 </span><!----><span class="φdy">Hashtable 类和 Enumeration 接口</span></a><!----></div><!----><!----><!----></div><!----><!----><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">8 </span><!----><span class="φdy">Collections 类</span></a><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">9 </span><!----><span class="φdy">Stream API</span></a><div class="φds"><a class="φdv"><span class="φdx">9.1 </span><!----><span class="φdy">创建与获得流</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">9.2 </span><!----><span class="φdy">连接与限制流</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">9.3 </span><!----><span class="φdy">过滤流</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">9.4 </span><!----><span class="φdy">流转换</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">9.5 </span><!----><span class="φdy">流规约</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">9.6 </span><!----><span class="φdy">收集结果</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">9.7 </span><!----><span class="φdy">基本类型流</span></a><!----></div><div class="φds"><a class="φdv"><span class="φdx">9.8 </span><!----><span class="φdy">并行流</span></a><!----></div><!----><!----><!----></div><div class="φds φdt"><a class="φdv"><span class="φdx">10 </span><!----><span class="φdy">知识点</span></a><!----></div><!----></is-m><!----><!----></is-a><!-- hexo injector body_begin end --><!-- hexo injector body_end start --><script src="//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script src="//cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/s1acr/my_jsDelivr@main/blogSelfDesign.js"></script><script src="/runtime.1ed960b0635ea0669f87.js"></script><script src="/polyfills.b7bf56fc45f931a8b83e.js"></script><script src="/main.543c891b4aad158701f3.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"superSample":2,"position":"right","hOffset":0,"vOffset":-20,"bottom":100,"width":150,"height":200},"mobile":{"show":true,"scale":0.5},"react":{"opacity":0.7,"opacityDefault":0.7,"opacityOnHover":0.9},"log":false});</script>

</body></html>