{"title":"[C++笔记]泛型程序设计与STL","date":"2023-05-02T00:00:00.000Z","date_formatted":{"ll":"May 2, 2023","L":"05/02/2023","MM-DD":"05-02"},"link":"2023/05/02/[C++笔记]泛型程序设计与STL","comments":true,"categories":["C++"],"updated":"2023-05-02T00:00:00.000Z","content":"<h2 id=\"泛型程序设计\">泛型程序设计<a title=\"#泛型程序设计\" href=\"#泛型程序设计\"></a></h2>\n<p>所谓泛型程序设计，就是编写不依赖于具体数据类型的程序。c++ 中，<code>模板是泛型程序设计的主要工具</code>。</p>\n<p>泛型程序设计的主要思想是将算法从特定的数据结构中抽象出来，使算法成为通用的、可以作用于各种不同的数据结构。这样就不必为每种容器都编写一套同样的算法，当容器类模板修改、扩充时也不必重写大量算法函数。这种以函数模板形式实现的通用算法与各种通用容器结合，提高了软件的复用性。</p>\n<p>我们可以用<code>概念 (concept)来描述泛型程序设计中作为参数的数据类型所需具备的功能</code>。这里的&quot;概念&quot;是泛型程序设计中的一个术语，它的内涵是这些功能，它的外延是具备这些功能的所有数据类型。</p>\n<p>例如，&quot;可以用比大小、具有公有的复制构造函数并可以用’='赋值的所有数据类型&quot;就是一个概念，可以把这个概念记作 Sortable 。<code>具备一个概念所需要功能的数据类型</code>称为这一<code>概念的一个模型 (model)</code> 。例如 .int 数据类型就是 Sortable 概念的一个模型。</p>\n<p>对于两个不同的概念A和B. 如果概念A所需求的所有功能也是感念B 所需求的功能(即概念B的模型一定是概念A的模型) .那么就说概念B 是概念A的子概念(有些书上又把它称为精炼(refinement))。我们把&quot;可以比大小的所有数据类型&quot;这一橄念记为 Comparable ，把&quot;具有公有的复制构造函数并可以用’='赋值的数据类型&quot;这一概念记为 Assignable ，那么Sortable 既是 Comparable 的子概念，也是 Assignable 的子概念。<br>\n很多 STL 的实现代码就是使用概念来命名模板参数的。</p>\n<h2 id=\"stl简介\">STL简介<a title=\"#stl简介\" href=\"#stl简介\"></a></h2>\n<p><code>标准模板库 (Standard Template Library , STL)</code> 最初是由 HP 公司的 Alexander Stepanov 和 Meng Lee 开发的一个用于支持 C++ 泛型编程的模板库, <code>1994 年被纳入了C++ 标准</code>, 成为 C++ 标准库的一部分。由于 C++ 标准库有多种不同的实现，因此 STL 有不同的版本，但它们为用户提供的接口都遵守共同的标准。</p>\n<p>STL定义了一套概念体系，为泛型程序设计提供了逻辑基础。 STL 中的各个类模板、函数模板的参数都是用这个体系中的概念来规定的。使 STL 的一个模板时所提供的类型参数既可以是 C++ 标准库中已有的类型，也可以是自定义的类型, 只要这些类型是所要求概念的模型，因此, STL 是一个开放的体系。</p>\n<h3 id=\"容器(container)\">容器(container)<a title=\"#容器(container)\" href=\"#容器(container)\"></a></h3>\n<p>容器是容纳、包含一组元素的对象。容器类库中包括7种基本容器: <code>向量 (vector) 双端队列 (deque) 、列表 (list) 、集合 (set) 、多重集合( multiset) 、映射 (map) 和多重映射(multimap)</code>。</p>\n<p>在 STL 中，容器是封装起来的类模板，其内部结构无从知晓，而只能通过容器接口来使用容器。</p>\n<p>可以分为两种基本类型 <code>顺序容器 (sequence container) 和关联容器 (associative container)</code> 。顺序容器将一组具有相同类型的元素以严格的线性形式组织起来，向量、双端队列和列表容器就属于这一种。关联容器具有根据一组索引来快速提取元素的能力，集合和映射容器就属于这一种。</p>\n<h3 id=\"迭代器(iterater)\">迭代器(iterater)<a title=\"#迭代器(iterater)\" href=\"#迭代器(iterater)\"></a></h3>\n<p>迭代器提供了顺序访问容器中每个元素的方法。因此<code>指针本身就是一种迭代器，迭代器是泛化的指针</code>。</p>\n<h3 id=\"函数对象(function-object)\">函数对象(function object)<a title=\"#函数对象(function-object)\" href=\"#函数对象(function-object)\"></a></h3>\n<p>函数对象是一个<code>行为类似函数的对象</code>，对它可以像<code>调用函数一样调用</code>。任何普通的函数和任何重载了&quot;()&quot;运算符的类的对象都可以作为函数对象使用，<code>函数对象是泛化的函数</code>。<br>\n使用 STL 的函数对象，需要包含头文件<code>&lt;functional&gt;</code></p>\n<h3 id=\"算法-(algorithm)\">算法 (algorithm)<a title=\"#算法-(algorithm)\" href=\"#算法-(algorithm)\"></a></h3>\n<p>STL 包括 70 多个算法，这些算法覆盖了相当大的应用领域，其中包括查找算法、排序算法、消除算法、计数算法、比较算法、变换算法、置换算法和容器管理等。这些算法的一个最重要的特性就是它们的统一性，并且可以广泛用于不同的对象和内置的数据类型。<br>\n使用 STL 的算法，需要包含头文件<code>&lt;algorithm&gt;</code></p>\n<p>STL 把迭代器作为算法的参数，通过迭代器来访问容器而不是把容器直接作为算法的参数 ;STL 把函数对象作为算法的参数而不是把函数所执行的运算作为算法的一部分。这些都是非常成功的设计，它为 STL 提供了极大的灵活性。使用 STL中提供的或自定义的迭代器和函数对象，配合 STL 的算法，可以组合出各种各样的功能。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305021608371.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"迭代器\">迭代器<a title=\"#迭代器\" href=\"#迭代器\"></a></h2>\n<p>虽然指针也是一种迭代器，但迭代器却不仅仅是指针。指针可以指向内存中的一个地址，通过这个地址就可以访问相应的内存单元;而迭代器更为抽象，它可以指向容器中的一个位置，我们不必关心这个位置对应的真正物理地址，只需要通过迭代器访问这个位置的元素。</p>\n<h3 id=\"输入输出流迭代器\">输入输出流迭代器<a title=\"#输入输出流迭代器\" href=\"#输入输出流迭代器\"></a></h3>\n<p>输入/输出流迭代器用来从一个输入流/输出流中连续地输入/输出某种类型的数据.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tistream_iterator&lt;<span class=\"type\">int</span>&gt; is_i = <span class=\"built_in\">istream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cin);</span><br><span class=\"line\">\tostream_iterator&lt;<span class=\"type\">int</span>&gt; os_i = <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot;\\n&quot;</span>); <span class=\"comment\">//第二个参数 delimiter</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> a = *is_i;</span><br><span class=\"line\">\tis_i++;</span><br><span class=\"line\">\t<span class=\"type\">int</span> b = *is_i;</span><br><span class=\"line\">\t*os_i = a;</span><br><span class=\"line\">\tos_i++;</span><br><span class=\"line\">\t*os_i = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\t*os_i = i;</span><br><span class=\"line\">\t\tos_i++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出流迭代器的特点是它在赋值时会将值写入到它所指向的输出流中。当我们使用输出流迭代器时，每次对它进行解引用操作 * 时，它会将该值写入到它所指向的输出流中.</p>\n<p>虽然输入流迭代器和输出流迭代器本身并不能比输入流和输出流提供更强大的功能，但由于它们采用迭代器的接口，在这两种<code>迭代器的帮助下，输入流和输出流可以直接参与 STL 的算法</code>，这就是引入这两种迭代器的意义。输入流迭代器和输出流迭代器可以被看作一种适配器。<code>适配器 (adapter)</code> 是指用于为已有对象提供新的接口的对象，<code>适配器本身一般并不提供新的功能，只为了改变对象的接口而存在</code>。输入流迭代器和输出流迭代器将输入流和输出流的接口变更为迭代器的接口，因此它们属于适配器。</p>\n<h3 id=\"迭代器的分类\">迭代器的分类<a title=\"#迭代器的分类\" href=\"#迭代器的分类\"></a></h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305021655962.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>用输入选代器读入的序列不能保证是可重复的。，如果 pl == p2 ，并不能保证 ++p1 == ++p2, 输入流迭代器只适用于作为那些只需遍历序列一次的算法的输入。p++返回结果未知, 最好用 ++p.</p>\n<p>使用输出迭代器，写入元素的操作和使用&quot;++“自增的操作必须交替进行。如果连续两次自增之间没有写入元素，或连续两次使用”* pl =t&quot;这样的语法写入元素之间没有自增，其行为都是不确定的。</p>\n<p><code>前向迭代器</code>这一概念是输入迭代器和输出迭代器这两个概念的子概念，它既支持数据读取，也支持数据写入。前向迭代器支持对序列进行可重复的单向遍历。它去掉了输入迭代器和输出迭代器这两个概念中的一些不确定性.<br>\n前向迭代器对序列的遍历是可重复的。，前向迭代器不再有输出迭代器关于&quot;++&quot;自增操作和对元素的写入操作必须交替进行&quot;的限制。</p>\n<p><code>双向迭代器</code>这一概念是单向迭代器的子概念。在单向迭代器所支持的功能基础上，它又支持迭代器向反向移动。</p>\n<p><code>随机访问迭代器</code>这一概念是双向迭代器的子概念。在双向迭代器的基础上，它又支持直接将选代器向前或向后移动n个元素，因此随机访问迭代器的功能几乎和指针一样。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现泛型排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T, <span class=\"keyword\">class</span> input_iterator, <span class=\"keyword\">class</span> output_iterator&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mySort</span><span class=\"params\">(input_iterator first, input_iterator last, output_iterator result)</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;T&gt; v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( ; first !=  last; ++first) v.<span class=\"built_in\">push_back</span>(*first);</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">double</span> arr[] = &#123; <span class=\"number\">1.1</span>, <span class=\"number\">2.7</span>, <span class=\"number\">9.0</span>, <span class=\"number\">1.25</span>, <span class=\"number\">0.3</span> &#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">mySort</span>&lt;<span class=\"type\">double</span>&gt;(arr, arr + <span class=\"number\">5</span>, <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">double</span>&gt;(cout, <span class=\"string\">&quot;  &quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//mySort&lt;int&gt;(istream_iterator&lt;int&gt;(cin), istream_iterator&lt;int&gt;(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"迭代器的辅助函数\">迭代器的辅助函数<a title=\"#迭代器的辅助函数\" href=\"#迭代器的辅助函数\"></a></h3>\n<p>STL 为迭代器提供了两个辅助函数模板 <code>advance 和 distance</code> 。它们为所有迭代器提供了一些原本只有随机访问迭代器才具有的访问能力:前进或后退多个元素，以及计算两个迭代器之间的距离。</p>\n<p><code>template&lt;class Inputlterator, class Disstance&gt; </code><br>\n<code>void advance (Inputlterator&amp; iter, Distance n);</code></p>\n<p><code>template&lt;class Inputlterator&gt; </code><br>\n<code>unsigned distance (Inputlterator first , Inputlterator last);</code></p>\n<h2 id=\"容器\">容器<a title=\"#容器\" href=\"#容器\"></a></h2>\n<h3 id=\"容器的基本功能\">容器的基本功能<a title=\"#容器的基本功能\" href=\"#容器的基本功能\"></a></h3>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">S s1</td>\n<td style=\"text-align:left\">容器都有→个默认构造函数，用于构造一个没有任何元素的空容器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s1 op s2</td>\n<td style=\"text-align:left\">这里 op 可以是= =,! = ,&lt;,&lt;= ，&gt;，&gt;=之一，它会对两个容器之间的元素按字典顺序进行比较。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s1.begin()</td>\n<td style=\"text-align:left\">返回指向 s1 第一个元素的迭代器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s1.end()</td>\n<td style=\"text-align:left\">返回指向 s1 最后一个元素的下一个位置的迭代器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s1.clear()</td>\n<td style=\"text-align:left\">将容器 s1 的内容清空。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s1.empty()</td>\n<td style=\"text-align:left\">返回一个布尔值，表示 s1 容器是否为空。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s1.size()</td>\n<td style=\"text-align:left\">返回 s1 的元素个数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s1.swap(s2)</td>\n<td style=\"text-align:left\">s1 容器和 s2 容器的内容交换。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">S::iterator</td>\n<td style=\"text-align:left\">表示与 相关的普通迭代器类型，迭代器指向元素的类型为T</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">S::const_iterator</td>\n<td style=\"text-align:left\">表示与 相关的常迭代器类型，迭代器指向元素的类型为 const T; s1 是常量时，使用 s1.begin()返回的迭代器的类型就是 S::const_iterator否则是S::iterator</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s1.rbegin()</td>\n<td style=\"text-align:left\">得到指向容器的最后一个元素的逆向迭代器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>可逆容器</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s1.rend()</td>\n<td style=\"text-align:left\">得到指向容器的第一个元素的前一个位置的逆向迭代器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">S::reverse_iterator</td>\n<td style=\"text-align:left\">表示与S相关的普通迭代器类型，选代器指向元素的类型为T</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">S::const_reverse_iterator</td>\n<td style=\"text-align:left\">表示与S相关的常迭代器类型，迭代器指向元素的类型const ，因此只能通过迭代器读取元素，不能通过迭代器改写元素。</td>\n</tr>\n</tbody>\n</table></div></div><p>容器作为一种 STL 的概念，有许多子概念。容器分为顺序容器和关联容器，这就是容器的两个子概念，这种划分是基于容器中元素的组织方式的。另一方面，按照与容器所关联的迭代器类型划分，容器又具有&quot;可逆容器&quot;这一子概念，可逆容器又具有&quot;随机访问容器&quot;这一子概念</p>\n<p>使用一般容器的 begin()或 end() 成员函数所得到的迭代器都是前向迭代器，也就是说可以对容器的元素进行单向的遍历。而可逆容器所提供的迭代器是双向迭代器，可以对容器的元素进行双向的遍历。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305021917089.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305021925182.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"顺序容器\">顺序容器<a title=\"#顺序容器\" href=\"#顺序容器\"></a></h3>\n<p>STL 中的顺序容器包括向量 (vector) 、双端队列 (deque) 和列表(list) ，它们在逻辑上可看作是一个长度可扩展的数组，容器中的元素都线性排列。程序员可以随意决定每个元素在容器中的位置，可以随时向指定位置插入新的元素和删除已有的元素。每种类型的容器都是一个类模板，都具有一个模板参数，表示容器的元素类型，该类型必须符合Assignable这一概念(即具有公有的复制构造函数并可以用&quot;=&quot;赋值)。</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>构造函数</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">S s(n, t);</td>\n<td style=\"text-align:left\">构造一个由n元素t构成的容器实例 s</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">S s(n);</td>\n<td style=\"text-align:left\">构造一个有n个元素的容器实例s， 每个元素都是 T()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">S s(q1,q2);</td>\n<td style=\"text-align:left\">使用将 [q1 q2) 区间内的数据作为s的元素构造s</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>赋值函数</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s.assign(n, t)</td>\n<td style=\"text-align:left\">赋值后的容器由n元素构成。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s.assign(n)</td>\n<td style=\"text-align:left\">赋值后的容器有n个元素的容器实例s，每个元素都是 T()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s.assign(q1, q2)</td>\n<td style=\"text-align:left\">赋值后的容器的元素为 [q1, q2) 区间内的数据。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>元素的插入</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s.insert(p1, t)</td>\n<td style=\"text-align:left\">在s容器中 p1 所指向的位置插入一个新的元素t，插入后的元素夹在原p1 和 p1-1 所指向的元素之间，该函数会返回一个迭代器指向新插入的元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s.insert(p1, n, t)</td>\n<td style=\"text-align:left\">在s容器中 p1 所指向的位置插入 n个新的元素，插入后的元素夹在原 p1 和 p1-1 所指向的元素之间，没有返回值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s.insert(p1，q1, q2)</td>\n<td style=\"text-align:left\">将[q1, q2) 区间内的元素顺序插入到s容器中 p1 位置处，新元素夹在原 p1和p1-1 所指向的元素之间。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>元素的删除</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s1.erase(p1)</td>\n<td style=\"text-align:left\">删除 s1 容器中 p1 所指向的元素，返回被删除的下一个元素的迭代器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s1.erase(p1, p2)</td>\n<td style=\"text-align:left\">删除 s1 容器中 [p1， p2) 区间内的元素，返回最后一个被删除元素的下一个元素的迭代器(即在删除前 p2 所指向元素的迭代器).</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>改变容器的大小</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s1.resize(n)</td>\n<td style=\"text-align:left\">将容器的大小变为n, 如果原有的元素个数大于 n 则容器末尾多余的元素会被删除; 如果原有的元素个数小于 n, 则在容器末尾会用T()填充。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>首尾元素的直接访问</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s.front()</td>\n<td style=\"text-align:left\">获得容器首元素的引用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s.back()</td>\n<td style=\"text-align:left\">获得容器尾元素的引用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>在容器尾部插入、删除元素</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s.push_back(t)</td>\n<td style=\"text-align:left\">向容器尾部插入元素t</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s.pop_back()</td>\n<td style=\"text-align:left\">将容器尾部的元素删除</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>在容器头部插入、删除元素</code></td>\n<td style=\"text-align:left\">列表 list 和双端队列 deque 两个容器支持高效地在容器头部插入新的元素或删除容器头部的元素，但是向量容器 vector 不支持。支持这一操作的概念构成了(FrontlnsertionSequence) “前插顺序容器” 这一概念，它是&quot;顺序容器&quot;的子概念。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s.push_front(t)</td>\n<td style=\"text-align:left\">向容器头部插入元素t</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">s.pop_front()</td>\n<td style=\"text-align:left\">删除容器头部的元素t</td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;deque&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printContainer</span><span class=\"params\">(T iterator_begin, T iterator_end)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (iterator_begin != iterator_end) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; *iterator_begin &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t\titerator_begin++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; v;</span><br><span class=\"line\">\tv.<span class=\"built_in\">resize</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; v.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">\t\tv[i] = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (vector&lt;<span class=\"type\">int</span>&gt;::iterator v_it = v.<span class=\"built_in\">begin</span>(); v_it != v.<span class=\"built_in\">end</span>(); v_it++) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; *v_it &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">deque&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">d</span><span class=\"params\">(v.rbegin(), v.rend())</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!d.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\tdeque&lt;<span class=\"type\">int</span>&gt;::const_iterator d_c_it =  d.<span class=\"built_in\">end</span>()<span class=\"number\">-1</span> ;</span><br><span class=\"line\">\t\tcout &lt;&lt; *d_c_it &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t\td.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlist&lt;<span class=\"type\">int</span>&gt; l;</span><br><span class=\"line\">\tl.<span class=\"built_in\">assign</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\tl.<span class=\"built_in\">push_back</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">\tl.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">\tl.<span class=\"built_in\">erase</span>(l.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\">\tprintContainer&lt;list&lt;<span class=\"type\">int</span>&gt;::iterator&gt;(l.<span class=\"built_in\">begin</span>(), l.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"三种容器的比较\">三种容器的比较<a title=\"#三种容器的比较\" href=\"#三种容器的比较\"></a></h4>\n<h5 id=\"vector\"><code>vector</code><a title=\"#vector\" href=\"#vector\"></a></h5>\n<p>向量容器是一种支持高效的随机访问和高效向尾部加入新元素的容器。向量容器­般实现为一个<code>动态分配的数组</code>，向量中的元素连续地存放在这个数组中，因此对向量容器进行随机访问，具有和动态访问动态数组几乎一样的效率。</p>\n<p>将已有元素从向量容器中删除时，多出的闲置空间并不会被释放，因为再插入新的元素时可能会重新占用这些空间。因此，向量容器对象已分配的空间所能容纳的元素个数，常常会大于容器中实际有效的元素个数，前者叫做向量容器的容量(capacity) ，后者叫做向量容器的大小(size).<br>\n  |  <br>\ns.capacity() | 返回s的容量<br>\ns.reserve(n) | 若当前的容量大于或等于n，什么也不做，否则扩大s的容量，使得的容量不小于n. 如果在准备向向量容器中插入大量数据之前，能够粗略估计出插入元素之后向量元素的大小，就可以在插入前使用 reserve 函数来确保这部分空间被分配，避免在插入过程中多次重新分配空间，提高效率。</p>\n<h5 id=\"deque\"><code>deque</code><a title=\"#deque\" href=\"#deque\"></a></h5>\n<p>双端队列是一种支持向两端高效地插入数据、支持随机访问的容器。双端队列的内部实现不如向量容器那样直观，在很多的 STL 实现中，双端队列的数据被表示为一个<code>分段数组</code>, &quot;容器中的元素分段存放在一个个大小固定的数组中，此外容器还需要维护一个存放这些数组首地址的索引数.</p>\n<p>执行向两端加入元素的操作时，会使所有的迭代器失效，但是不会使任何指向已有元素的指针、引用失效。指针和引用不会失效是因为向两端加入新元素不会改变已有元素在分段数组中的位置，而选代器之所以会失效，是因为向两端插入新元素可能会引起索引数组中已有元素位置的改变(例如索引数组被重新分配) ，而迭代器需要依赖索引数组。</p>\n<p>当删除双端队列中间的元素时，由于被删除元素到某一端之间的所有元素都要向中间移动，删除的位置越靠近中间，效率越低，删除操作也会使所有迭代器和指针、引用失效。</p>\n<h5 id=\"list\"><code>list</code><a title=\"#list\" href=\"#list\"></a></h5>\n<p>列表是一种<code>不能随机访问但可以高效地在任意位置插入和删除元素的容器</code>。类似<code>双向链表.</code><br>\n执行删除操作时只会使指向被删除元素的迭代器和指针、引用失效，而不会影响其他迭代器或指针、引用。<br>\n列表容器还支持一种特殊的操作 接合 (splice).</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>s1.splice(p. s2)</code></td>\n<td style=\"text-align:left\">将 s2 列表的所有元素插入到s1列表中 p-1 和 p 之间, 将 s2 列表清空.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s1.splice(p, s2, q1)</code></td>\n<td style=\"text-align:left\">将 s2 列表中 q1 所指向的元素插入到 s1列表中 p-1 和 p 之间, 将 q1 所指向的元素从 s2 列表中删除.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>sl.splice(p, s2, ql, q2)</code></td>\n<td style=\"text-align:left\">将 s2 列表中[q1, q2) 区间内的所有元素插入到s1列表中 p-1 和 p 之间, 将 [q1, q2) 区间内的元素从 s2 列表中删除.</td>\n</tr>\n</tbody>\n</table></div></div><p>执行接合操作时，原先指向被接入 s1 列表中的那些元素的迭代器和指针、引用都会失效，其他迭代器或指针、引用不会受到影响。</p>\n<p>列表容器还支持其他特殊的操作，其中有很多是与一定的 STL 算法相对应的，例如<code>删除(remove) 、条件删除 (remove_if)、排序 (sort) 、去重(unique) 、归并(merge) 、倒序(reverse)</code> 等。但由于列表容器存储结构的特殊性，直接使用这些 STL 算法并不能达到最高的效率，因此这些算法提供了专门针对列表容器的实现，作为列表容器的成员函数。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305022139032.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"顺序容器的插入迭代器\">顺序容器的插入迭代器<a title=\"#顺序容器的插入迭代器\" href=\"#顺序容器的插入迭代器\"></a></h4>\n<p>插入迭代器是一种适配器，使用它可以通过输出迭代器的接口来向指定元素的指定位置插入元素。因而如果在调用 STL 算法时使用输出迭代器，可以将结果顺序插入到容器的指定位置，而无须覆盖已有的元素。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">FrontlnsertionSequence</span>&gt;<span class=\"keyword\">class</span> <span class=\"title class_\">front_insert_iterator</span>;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Sequence</span>&gt;<span class=\"keyword\">class</span> <span class=\"title class_\">back_insert_iterator</span>; </span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Sequence</span>&gt;<span class=\"keyword\">class</span> <span class=\"title class_\">insert_iterator</span>;</span><br></pre></td></tr></table></figure>\n<p>把一个容器类型作为模板参数，分别用于向指定容器头部、尾部和中间某个指定位置插入元素.front_insert_iterator 只适用于前插顺序容器(双端队列和列表), back_insert_iterator insert_iterator 适用于所有顺序容器。</p>\n<p>插入迭代器的实例可以通过构造函数来创建，但一般无须直接调用构造函数，而是可以通过下面的三个辅助函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> FrontlnsertionSequence&gt; </span></span><br><span class=\"line\"><span class=\"function\">front_insert_iterator&lt;FrontlnsertionSequence&gt; <span class=\"title\">front_inserter</span><span class=\"params\">(FrontlnsertionSequence&amp; s)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> Sequence&gt; </span></span><br><span class=\"line\"><span class=\"function\">back_insert_iterator&lt;Sequence&gt; <span class=\"title\">back_inserter</span><span class=\"params\">(Sequence&amp; s)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> Sequence , <span class=\"keyword\">class</span> Iterator&gt; </span></span><br><span class=\"line\"><span class=\"function\">insert_iterator&lt;Sequence&gt; <span class=\"title\">inserter</span><span class=\"params\">(Sequence&amp; s , Iterator i)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>使用辅助函数与直接使用构造函数的优点在于，辅助函数是一般的函数模板，调用时可以自动推导类型参数而无须显式将其给出，从而使代码变得更简短，因此人们一般用辅助函数代替构造函数。</p>\n<h4 id=\"顺序容器的适配器\">顺序容器的适配器<a title=\"#顺序容器的适配器\" href=\"#顺序容器的适配器\"></a></h4>\n<p>STL 提供的<code>容器适配器找(stack) 和队列 (queue)</code> ，就是对顺序容器的封装。如果使用时不指定第二个参数，则默认使用双端队列容器。</p>\n<p><code>template&lt;class T, class Sequence=deque&lt;T&gt;&gt;class stack; </code><br>\n<code>template&lt;class T , class FrontInsertonSequence = deque&lt;T&gt; &gt; class queue;</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstack&lt;<span class=\"type\">int</span>, vector&lt;<span class=\"type\">int</span>&gt;&gt; s;     <span class=\"comment\">// 使用容器适配器将vector的接口转换成stack的接口</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t\ts.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; s.<span class=\"built_in\">top</span>() &lt;&lt; endl;</span><br><span class=\"line\">\t\ts.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优先队列适配器<br>\n<code>template&lt; class T, class Sequence= lector&lt;T&gt;&gt;class priority_queue;</code></p>\n<p>优先级队列的基础容器必须是支持随机访问的顺序容器，因此它必须是向量容器或双端队列容器，默认为向量容器。优先级队列也像栈和队列一样支持元素的压人和弹出，但元素弹出的顺序与压入的顺序无关，而是与元素的大小有关，每次弹出的总是容器中最&quot;大&quot;的一个元素。</p>\n<h3 id=\"关联容器\">关联容器<a title=\"#关联容器\" href=\"#关联容器\"></a></h3>\n<p>对于关联容器而言，它的每个元素都有一个键 (key) ，容器中元素的顺序按照键的取值升序排列<br>\n而关联容器会将元素根据键的大小组织在一棵<code>&quot;平衡二又树&quot;</code>中，最坏情况下只需要大约<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"5.379ex\" height=\"2.509ex\" style=\"vertical-align: -0.671ex;\" viewBox=\"0 -791.3 2315.9 1080.4\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">log_2{n}</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-6C\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-6F\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-67\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-6E\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-6C\" x=\"0\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-6F\" x=\"298\" y=\"0\"></use>\n<g transform=\"translate(784,0)\">\n <use xlink:href=\"#E1-MJMATHI-67\" x=\"0\" y=\"0\"></use>\n <use transform=\"scale(0.707)\" xlink:href=\"#E1-MJMAIN-32\" x=\"675\" y=\"-213\"></use>\n</g>\n <use xlink:href=\"#E1-MJMATHI-6E\" x=\"1715\" y=\"0\"></use>\n</g>\n</svg>次比较就可根据键来查找一个元素。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305202208329.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>简单关联容器只有一个类型参数，该类型既是键类型，又是容器类型; 二元关联容器则有两个类型参数，前一个是键类型，后一个是附加数据的类型，二元关联容器的元素类型是键类型和附加数据类型的组合，这种组合类型可以用一个<code>二元组 (pair)</code>来表示， <code>pair 是 &lt;utility&gt; 头文件中定义的结构体模板</code>.</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>S s(q1, q2)</code>   `</td>\n<td style=\"text-align:left\">迭代器 [q1， q2) 区间内的数据作为 的元素构造</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s.ínsert (t)  </code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s.insert( p1 , t)  </code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s.insert(q1 , q2)  </code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s.erase( p1)   </code></td>\n<td style=\"text-align:left\">删除 p1 所指向的元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s.erase( p1 , p2)  </code></td>\n<td style=\"text-align:left\">删除 [p1 p2) 区间内的元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s.erase( k)  </code></td>\n<td style=\"text-align:left\">删除所有键为 的元素，返回被删除元素的个数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s.find(k)    </code></td>\n<td style=\"text-align:left\">找到任意一个键为k的元素，返回该元素的迭代器，如果没有键为k的元素，则返回 s.end()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s.lower_bound(k)  </code></td>\n<td style=\"text-align:left\">得到 s中第一个键值不小于k的元素的迭代器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s.upper_bound(k)  </code></td>\n<td style=\"text-align:left\">得到 s 中第一个键值大于k的元素的迭代器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s.equal_range(k)   </code></td>\n<td style=\"text-align:left\">得到一个用 pair&lt;S::iterator , S::iterator&gt; 表示的区间，记为 [pl. p2) 。该区间刚好包含所有键为k的元素 p1==s.lower_bound(k) p2==s.upper_bound(k) 一定成立。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s.count(k)   </code></td>\n<td style=\"text-align:left\">得到容器中键为k的元素个数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">关联容器的插入和删除操作不会使任何已有的迭代器、指针或引用失效。</td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table></div></div><h4 id=\"set\">set<a title=\"#set\" href=\"#set\"></a></h4>\n<p>集合用来存储一组无重复的元素。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tset&lt;string&gt; s;</span><br><span class=\"line\">\ts.<span class=\"built_in\">insert</span>(<span class=\"string\">&quot;happy&quot;</span>);</span><br><span class=\"line\">\tpair&lt;set&lt;string&gt;::iterator, <span class=\"type\">bool</span>&gt; res = s.<span class=\"built_in\">insert</span>(<span class=\"string\">&quot;happy&quot;</span>);</span><br><span class=\"line\">\tcout &lt;&lt; res.second &lt;&lt; endl;  <span class=\"comment\">// 0</span></span><br><span class=\"line\">\ts.<span class=\"built_in\">insert</span>(<span class=\"string\">&quot;good&quot;</span>);</span><br><span class=\"line\">\ts.<span class=\"built_in\">insert</span>(<span class=\"string\">&quot;funk&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(s.<span class=\"built_in\">begin</span>(), s.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;string&gt;(cout, <span class=\"string\">&quot; &quot;</span>)); <span class=\"comment\">// funk good happy</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"map\">map<a title=\"#map\" href=\"#map\"></a></h4>\n<p>映射的元素类型是由键和附加数据所构成的二元组。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tmap&lt;string, <span class=\"type\">int</span>&gt; m;</span><br><span class=\"line\">\tm.<span class=\"built_in\">insert</span>(<span class=\"built_in\">pair</span>&lt;string, <span class=\"type\">int</span>&gt;(<span class=\"string\">&quot;zhangsan&quot;</span>, <span class=\"number\">18</span>));</span><br><span class=\"line\">\tm.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"string\">&quot;lisi&quot;</span>, <span class=\"number\">39</span>));</span><br><span class=\"line\">\tm.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"string\">&quot;wangwu&quot;</span>, <span class=\"number\">10</span>));</span><br><span class=\"line\">\tm.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"string\">&quot;slacr&quot;</span>, <span class=\"number\">92</span>));</span><br><span class=\"line\">\tm.<span class=\"built_in\">erase</span>(<span class=\"string\">&quot;slacr&quot;</span>);</span><br><span class=\"line\">\tm[<span class=\"string\">&quot;lisi&quot;</span>] = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (pair&lt;string, <span class=\"type\">int</span>&gt; entry : m) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; entry.first &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; entry.second &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//lisi 100</span></span><br><span class=\"line\">\t<span class=\"comment\">//wangwu 10</span></span><br><span class=\"line\">\t<span class=\"comment\">//zhangsan 18</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数对象\">函数对象<a title=\"#函数对象\" href=\"#函数对象\"></a></h2>\n<p>函数对象 (function object / functor) STL 提供的一类主要组件，它使得 STL应用更加灵活方便，从而增强了算法的通用性。大多数 STL 算法可以用一个函数对象作为参数。所谓函数对象其实就是一个行为类似函数的对象，它可以不需参数，也可以带有若干参数，其功能是获取一个值，或者改变操作的状态。在 C++程序设计中.任何普通的函数和任何重载了调用运算符 operator() 的类的对象都满足函数对象的特征，因此都可以作为函数对象传递给算法作为参数使用。</p>\n<p>常用的函数对象可分为<code>产生器 (generator) 、一元函数 (unary function) 、二元函数( binary function) 、一元谓词 (unary predicate) 和二元谓词 (binary predicate)</code> 函数对象五大类。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305211301289.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">muti</span><span class=\"params\">(T t1, T t2)</span> </span>&#123; <span class=\"keyword\">return</span> t1 * t2; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">myplus</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\">T <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(T t1, T t2)</span> </span>&#123; <span class=\"keyword\">return</span> t1 + t2; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tlist&lt;<span class=\"type\">int</span>&gt; l;</span><br><span class=\"line\">\tl.<span class=\"built_in\">push_back</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">\tl.<span class=\"built_in\">push_back</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">\tl.<span class=\"built_in\">push_back</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">accumulate</span>(l.<span class=\"built_in\">begin</span>(), l.<span class=\"built_in\">end</span>(), <span class=\"number\">1</span>, muti&lt;<span class=\"type\">int</span>&gt;) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">accumulate</span>(l.<span class=\"built_in\">begin</span>(), l.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>, <span class=\"built_in\">myplus</span>&lt;<span class=\"type\">int</span>&gt;()) &lt;&lt; endl;   <span class=\"comment\">// 仿函数， 这里的muplus&lt;int&gt;()整体是函数名，括号是重载的运算符</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"产生器-(generator)-一元函数-(unary-function)-二元函数-(binary-function)\">产生器 (generator) 一元函数 (unary function) 二元函数 (binary function)<a title=\"#产生器-(generator)-一元函数-(unary-function)-二元函数-(binary-function)\" href=\"#产生器-(generator)-一元函数-(unary-function)-二元函数-(binary-function)\"></a></h3>\n<p>将具有 0 个、 1 个和 2 个传入参数的函数对象，分别称为产生器( generator) 、一元函数 (unary function) 和二元函数 (binary function).</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305211351157.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>调用这些标准函数对象，需要包含头文件 <functional> 。标准函数对象是内联函数。</p>\n<h3 id=\"一元谓词-(unary-predicate)-二元谓词-(binary-predicate)\">一元谓词 (unary predicate) 二元谓词 (binary predicate)<a title=\"#一元谓词-(unary-predicate)-二元谓词-(binary-predicate)\" href=\"#一元谓词-(unary-predicate)-二元谓词-(binary-predicate)\"></a></h3>\n<p>这种函数对象要求<code>返回值为 bool 型</code>，并具有一个或两个参数，称之为一元谓词或二元谓词函数对象。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305211353234.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">vi</span><span class=\"params\">(arr, arr + <span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(vi.<span class=\"built_in\">begin</span>(), vi.<span class=\"built_in\">end</span>(), <span class=\"built_in\">less</span>&lt;<span class=\"type\">int</span>&gt;());</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(vi.<span class=\"built_in\">begin</span>(), vi.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"关联类型-(associated-types)\">关联类型 (associated types)<a title=\"#关联类型-(associated-types)\" href=\"#关联类型-(associated-types)\"></a></h3>\n<p>STL 中，定义了两个函数对象的基类 <code>unary_function binary_function</code> ，分别用于设计一元函数对象和二元函数对象。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">my_binary_pred</span> : <span class=\"keyword\">public</span> binary_function&lt;pair&lt;string, <span class=\"type\">int</span>&gt;, pair&lt;string, <span class=\"type\">int</span>&gt;, <span class=\"type\">bool</span>&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(pair&lt;string, <span class=\"type\">int</span>&gt; p1, pair&lt;string, <span class=\"type\">int</span>&gt; p2)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p1.second &lt; p2.second;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;pair&lt;string, <span class=\"type\">int</span>&gt;&gt; sheet;</span><br><span class=\"line\">\tsheet.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(<span class=\"string\">&quot;slacr&quot;</span>, <span class=\"number\">98</span>));</span><br><span class=\"line\">\tsheet.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(<span class=\"string\">&quot;Tim&quot;</span>, <span class=\"number\">66</span>));</span><br><span class=\"line\">\tsheet.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(<span class=\"string\">&quot;Jose&quot;</span>, <span class=\"number\">54</span>));</span><br><span class=\"line\">\tsheet.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(<span class=\"string\">&quot;frank&quot;</span>, <span class=\"number\">99</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(sheet.<span class=\"built_in\">begin</span>(), sheet.<span class=\"built_in\">end</span>(), <span class=\"built_in\">my_binary_pred</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (pair&lt;string, <span class=\"type\">int</span>&gt; p : sheet) &#123; cout &lt;&lt; p.first &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数适配器\">函数适配器<a title=\"#函数适配器\" href=\"#函数适配器\"></a></h3>\n<p>函数适配器实现了这一功能，将一种函数对象转化为另一种符合要求的函数对象。函数适配器可以分为4大类: <code>绑定适配器(bind adaptor) 、组合适配器 (composite adaptor) 、指针函数适配器 (pointer function adaptor) 和成员函数适配器 (member function adaptor)</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305211427779.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>直接构造 STL 中的函数适配器通常会导致冗长的类型声明。为简化函数适配器的构造 .STL 还提供了函数适配器辅助函数. 借助于泛型自动推断技术，无<br>\n须显式的类型声明便可实现函数适配器的构造。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305211428889.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">greater&lt;<span class=\"type\">int</span>&gt; g;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">greater5</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">g</span>(x, <span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[] = &#123; <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">find_if</span>(arr, arr + <span class=\"number\">5</span>, greater5)) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;find it&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;  <span class=\"comment\">// find it</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// std::binder2nd&lt;_Fn&gt;::binder2nd(const _Fn &amp; _Func, const typename _Fn::second_argument_type &amp; _Right)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">find_if</span>(arr, arr + <span class=\"number\">5</span>, <span class=\"built_in\">bind2nd</span>(<span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;(), <span class=\"number\">5</span>))) &#123; </span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;find it&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">g</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &gt; y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[] = &#123; <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span> , <span class=\"number\">60</span>, <span class=\"number\">70</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> len = <span class=\"keyword\">sizeof</span> arr / <span class=\"keyword\">sizeof</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v</span><span class=\"params\">(arr, arr + len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt;::iterator p;</span><br><span class=\"line\">\tp = <span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"built_in\">bind2nd</span>(<span class=\"built_in\">ptr_fun</span>(g), <span class=\"number\">40</span>)); <span class=\"comment\">// 指针函数适配器</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p == v.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;none&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;found&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp = <span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"built_in\">not1</span>(<span class=\"built_in\">bind2nd</span>(<span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;(), <span class=\"number\">40</span>)));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p == v.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;none&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;found&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp = <span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"built_in\">bind2nd</span>(<span class=\"built_in\">not2</span>(<span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;()), <span class=\"number\">40</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p == v.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;none&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;found&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"算法\">算法<a title=\"#算法\" href=\"#算法\"></a></h2>\n<p>算法本身就是一种函数模板。STL 的算法是通用的:每个算法都适合于若干种不同的数据结构.<br>\n算法不是直接使用容器作为参数，而是使用迭代器类型。<br>\nSTL 的算法可以分为4大类: <code>不可变序列算法、可变序列算法、排序和搜索算法、数值算法</code></p>\n<h3 id=\"不可变序列算法\">不可变序列算法<a title=\"#不可变序列算法\" href=\"#不可变序列算法\"></a></h3>\n<p><code>不可变序列算法 (non-mutating algorithms)</code> 是指那些不直接修改所操作的容器内容的算法。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305211534012.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">g</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &gt; y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v1</span><span class=\"params\">(arr, arr+len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> sub_arr[] = &#123; <span class=\"number\">3</span>, <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">\tlen = <span class=\"built_in\">sizeof</span>(sub_arr)/ <span class=\"built_in\">sizeof</span>(sub_arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v2</span><span class=\"params\">(sub_arr, sub_arr + len)</span></span>;</span><br><span class=\"line\">\tcout &lt;&lt; *<span class=\"built_in\">adjacent_find</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>()) &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"comment\">// 找出第一个相邻元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">count_if</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>(), <span class=\"built_in\">bind2nd</span>(<span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;(), <span class=\"number\">5</span>)) &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"comment\">// 统计大于5的元素个数</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; *<span class=\"built_in\">find_if</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>(), <span class=\"built_in\">bind2nd</span>(<span class=\"built_in\">less</span>&lt;<span class=\"type\">int</span>&gt;(), <span class=\"number\">2</span>)) &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"comment\">// 找出第一个小于2的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; *<span class=\"built_in\">search</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>(), v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>()) &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"comment\">// 找出子序列在原序列中第一次出现位置的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; *<span class=\"built_in\">search_n</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>(), <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;()) &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"comment\">// 找出第一次连续出现3个&gt;4的元素的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">equal</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>(), v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>()) &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"comment\">// 判断两个序列是否相等</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tpair&lt;vector&lt;<span class=\"type\">int</span>&gt;::iterator, vector&lt;<span class=\"type\">int</span>&gt;::iterator&gt; res = <span class=\"built_in\">mismatch</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>(), v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"comment\">// 查找v2在v1中不匹配的首位置    </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可变序列算法\">可变序列算法<a title=\"#可变序列算法\" href=\"#可变序列算法\"></a></h3>\n<p>可变序列算法 (mutating algorithms) 可以修改它们所操作的容器的元素。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305211604573.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">myGenerator</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建随机数生成器</span></span><br><span class=\"line\">\t\trandom_device rd;</span><br><span class=\"line\">\t\t<span class=\"function\">mt19937 <span class=\"title\">gen</span><span class=\"params\">(rd())</span></span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建分布器</span></span><br><span class=\"line\">\t\tuniform_int_distribution&lt;&gt; <span class=\"built_in\">dis</span>(<span class=\"number\">1</span>, <span class=\"number\">9</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 生成随机数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">dis</span>(gen);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">g</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123; <span class=\"keyword\">return</span> x &gt; y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span> &#125;;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">sizeof</span>(arr) / <span class=\"built_in\">sizeof</span>(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v1</span><span class=\"params\">(arr, arr+len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> sub_arr[] = &#123; <span class=\"number\">3</span>, <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">\tlen = <span class=\"built_in\">sizeof</span>(sub_arr)/ <span class=\"built_in\">sizeof</span>(sub_arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v2</span><span class=\"params\">(sub_arr, sub_arr + len)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">ostream_iterator&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">output</span><span class=\"params\">(cout, <span class=\"string\">&quot; &quot;</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">fill</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 将v1填充 0 </span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>(), output);</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">generate</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>(), <span class=\"built_in\">myGenerator</span>());</span><br><span class=\"line\">\t<span class=\"comment\">// 生成每一个元素为随机值</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>(), output);</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">remove_copy</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>(), <span class=\"built_in\">back_inserter</span>(v2), <span class=\"number\">5</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 删除v1小于5的元素并放到v2后</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>(), output);</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tv2.<span class=\"built_in\">erase</span>(<span class=\"built_in\">remove_if</span>(v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>(), <span class=\"built_in\">bind2nd</span>(<span class=\"built_in\">less</span>&lt;<span class=\"type\">int</span>&gt;(), <span class=\"number\">4</span>)));</span><br><span class=\"line\">\t<span class=\"comment\">// 删除v2小于4的值, 只用remove_if不会清除原来空间</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>(), output);</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">replace</span>(v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>(), <span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 将v2中4改为0</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>(), output);</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">reverse</span>(v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"comment\">// 逆序</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>(), output);</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">rotate_copy</span>(v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">begin</span>() + <span class=\"number\">4</span>, v2.<span class=\"built_in\">end</span>(), output);</span><br><span class=\"line\">\t<span class=\"comment\">// 将两个区间旋转输出, 不会改变原容器</span></span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">temp</span><span class=\"params\">(v2)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">rotate_copy</span>(temp.<span class=\"built_in\">begin</span>(), temp.<span class=\"built_in\">begin</span>() + <span class=\"number\">4</span>, temp.<span class=\"built_in\">end</span>(), v2.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\">\t<span class=\"comment\">// 旋转序列改变原序列.</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>(), output);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"排序和搜索算法\">排序和搜索算法<a title=\"#排序和搜索算法\" href=\"#排序和搜索算法\"></a></h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305211709365.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>sort 要求 first last 必须是随机迭代器类型，因为 sort 的具体实现使用了快速排序算法，使用随机迭代器是出于效率上的考虑。<br>\nstable_sort 原型声明和 sort 几乎相同，它的不同之处在于，对于相等数值的元素，排序前后的相对位置将保持不变。</p>\n<p>lower_bound函数返回指向第一个大于或等于指定值的元素的迭代器，如果所有元素都小于指定值，则返回容器的end()迭代器。<br>\nupper_bound函数返回指向第一个大于指定值的元素的迭代器，如果所有元素都小于或等于指定值，则返回容器的end()迭代器。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;random&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[] = &#123; <span class=\"number\">24</span>, <span class=\"number\">32</span>, <span class=\"number\">42</span>, <span class=\"number\">51</span>, <span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">54</span> &#125;;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v</span><span class=\"params\">(arr, arr + <span class=\"keyword\">sizeof</span>(arr) / <span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>]))</span></span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> arr1[] = &#123; <span class=\"number\">39</span>, <span class=\"number\">54</span>, <span class=\"number\">87</span>, <span class=\"number\">43</span> &#125;;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v2</span><span class=\"params\">(arr1, arr1 + <span class=\"keyword\">sizeof</span>(arr1) / <span class=\"keyword\">sizeof</span>(arr1[<span class=\"number\">0</span>]))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt;::iterator p = <span class=\"built_in\">max_element</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"comment\">// 计算区间最值</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> n = p - v.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> dist = <span class=\"built_in\">distance</span>(v.<span class=\"built_in\">begin</span>(), p); <span class=\"comment\">// 这个函数也可以算</span></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;max_e: &quot;</span> &lt;&lt; *p &lt;&lt; <span class=\"string\">&quot; idx: &quot;</span> &lt;&lt; n &lt;&lt; <span class=\"string\">&quot; distance: &quot;</span> &lt;&lt; dist &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v1</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">partial_sort_copy</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"comment\">// 将v局部排序并拷贝到其他容器, v本身不变化</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;());</span><br><span class=\"line\">\t<span class=\"comment\">// 降序排列</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; *<span class=\"built_in\">lower_bound</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"number\">50</span>, <span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;()) &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"comment\">// 默认的lower_bound必须要求按照升序排序后才行, 之前是是按降序排序的，这里也要传一个相同的谓词</span></span><br><span class=\"line\">\tcout &lt;&lt; *<span class=\"built_in\">upper_bound</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"number\">50</span>, <span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;()) &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">binary_search</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"number\">32</span>, <span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;()) &lt;&lt; endl; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v3</span><span class=\"params\">(v.size() + v2.size())</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"built_in\">merge</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>(), v3.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\">\t<span class=\"comment\">// 将v，v2合并到v3中</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v3.<span class=\"built_in\">begin</span>(), v3.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\trandom_device rd;</span><br><span class=\"line\">\t<span class=\"function\">mt19937 <span class=\"title\">g</span><span class=\"params\">(rd())</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">shuffle</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), g);</span><br><span class=\"line\">\t<span class=\"comment\">// 打乱元素</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"built_in\">nth_element</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">begin</span>() + <span class=\"number\">2</span>, v.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"comment\">// 保证在第n个位置之前的元素都小于等于第n个元素，而在第n个位置之后的元素都大于等于第n个元素。这个能更高效部分查找</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">stable_sort</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"comment\">// 稳定的排序， 保持相对位置</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">inplace_merge</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">begin</span>()+<span class=\"number\">2</span>, v.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"comment\">// 合并两个有序序列， 保存到原序列</span></span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">lexicographical_compare</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), v2.<span class=\"built_in\">begin</span>(), v2.<span class=\"built_in\">end</span>()) &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"comment\">// 按字典顺序比较 // 1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数值算法\">数值算法<a title=\"#数值算法\" href=\"#数值算法\"></a></h3>\n<p>STL 提供了 个通用数值算法。为了调用此类算法，需要包含头文件<numeric>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305211826812.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"扩展\">扩展<a title=\"#扩展\" href=\"#扩展\"></a></h2>\n<h3 id=\"利用函数对象的类型特征实现函数适配器\">利用函数对象的类型特征实现函数适配器<a title=\"#利用函数对象的类型特征实现函数适配器\" href=\"#利用函数对象的类型特征实现函数适配器\"></a></h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将二元函数转换成一元函数</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">BinaryFunction</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">binder1st</span> : <span class=\"keyword\">public</span> unary_function&lt;</span><br><span class=\"line\">\t<span class=\"keyword\">typename</span> BinaryFunction::second_argument_type,</span><br><span class=\"line\">\t<span class=\"keyword\">typename</span> BinaryFunction::result_type&gt; </span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\tBinaryFunction op;</span><br><span class=\"line\">\t<span class=\"keyword\">typename</span> BinaryFunction::first_argument_type value;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">\t<span class=\"built_in\">binder1st</span>(<span class=\"type\">const</span> BinaryFunction&amp; op, <span class=\"type\">const</span> <span class=\"keyword\">typename</span> BinaryFunction::first_argument_type &amp; value) : <span class=\"built_in\">op</span>(op), <span class=\"built_in\">value</span>(value) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 重载()</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">typename</span> Operation::result_type <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">typename</span> BinaryFunction::second_argument_type&amp; x)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">op</span>(value, x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>c++ 标准规定，凡是在模板中引用的、依赖于模板参数的数据类型，必须用 <code>typename</code> 修饰，否则该标识符就不被解析为一个数据类型。</p>\n<h3 id=\"迭代器的类型特征\">迭代器的类型特征<a title=\"#迭代器的类型特征\" href=\"#迭代器的类型特征\"></a></h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305212044790.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>两个指针相减得到的数值的类型就是 ptrdiff_t</p>\n<p>iterator_category 起到了非常特殊的作用，它可以是下面个结构体之一。</p>\n<p>struct input iterator tag { };<br>\nstruct output_iterator_tag { };<br>\nstruct forward iterator tag: public input iterator tag { };<br>\nstruct bidirectional_iterator_tag: public forward_iterator_tag { };<br>\nstruct random access iterator tag: public bidirectional iterator tag { };</p>\n<p>5个结构体全部定义在 <iterator> 头文件中，它们都不具有任何成员，只<code>用来表示一个迭代器所属的分类</code>。其中<code>每个结构体对应于一种迭代器概念</code>，迭代器之间的继承关系也与相应概念及其子概念之间的关系一致。</p>\n<p>与函数对象的 unary_function binary_function 这两个关联类型类似，迭代器也有相应的关联类型 iterator ，它也定义在 <iterator> 头文件中</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Category</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">T</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">Distance</span> = <span class=\"type\">ptrdiff_t</span>,</span><br><span class=\"line\"><span class=\"keyword\">class</span> Pointer = T*， <span class=\"keyword\">class</span> Reference = T&amp;&gt; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> iterator &#123; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> T value type; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Distance difference type; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Pointer poi teri</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Reference reference; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Category iterator_category;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当定义自己的迭代器时，元须分别定义各个类型特征，只要继承 iterator 类即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IncrementIterator</span> : <span class=\"keyword\">public</span> iterator&lt;input_iterator_tag, T, <span class=\"type\">ptrdiff_t</span>, <span class=\"type\">const</span> T*, <span class=\"type\">const</span> T&amp;&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tT value;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> IncrementIterator&lt;T&gt; Self;</span><br><span class=\"line\">\t<span class=\"built_in\">IncrementIterator</span>(<span class=\"type\">const</span> T&amp; value = <span class=\"built_in\">T</span>()) : <span class=\"built_in\">value</span>(value) &#123;&#125;  <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>== (<span class=\"type\">const</span> Self&amp; rhs) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> value == rhs.value; &#125;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>!= (<span class=\"type\">const</span> Self&amp; rhs) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> value != rhs.value; &#125;</span><br><span class=\"line\">\tSelf&amp; <span class=\"keyword\">operator</span>++() &#123; value++; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125; <span class=\"comment\">// 前缀++</span></span><br><span class=\"line\">\tSelf&amp; <span class=\"keyword\">operator</span>++(<span class=\"type\">int</span>) &#123;\t\t\t\t<span class=\"comment\">// 后缀++</span></span><br><span class=\"line\">\t\tSelf tmp = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\tvalue++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">const</span> T&amp; <span class=\"keyword\">operator</span>*() <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">\t<span class=\"type\">const</span> T* <span class=\"keyword\">operator</span>-&gt;() <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> &amp;value; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(<span class=\"built_in\">IncrementIterator</span>&lt;<span class=\"type\">int</span>&gt;(), <span class=\"built_in\">IncrementIterator</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"type\">int</span> s[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span> ,<span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">transform</span>(s, s + <span class=\"built_in\">sizeof</span>(s) / <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>), <span class=\"built_in\">IncrementIterator</span>&lt;<span class=\"type\">int</span>&gt;(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>), <span class=\"built_in\">plus</span>&lt;<span class=\"type\">int</span>&gt;());</span><br><span class=\"line\">\t<span class=\"comment\">//template&lt;class InputIt1, class InputIt2, class OutputIt, class BinaryOperation&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">//\tOutputIt transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt d_first, BinaryOperation binary_op);</span></span><br><span class=\"line\">\t<span class=\"comment\">// 这个transform是一个重载版本, 有两个输入迭代器, 处理函数是plus, 输出迭代器ostream_iterator</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"comment\">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class=\"line\">\t<span class=\"comment\">// 1 3 5 7 9</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用类型特征实现算法\">利用类型特征实现算法<a title=\"#利用类型特征实现算法\" href=\"#利用类型特征实现算法\"></a></h3>\n<p><iterator>头文件中提供了一个作为助手的模板 <code>iterator_tralts</code> ，使用它可以以统一的方式得到包括指针在内的<code>各种迭代器的类型特征</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Iterator</span>&gt;<span class=\"keyword\">struct</span> <span class=\"title class_\">iterator_traits</span> &#123; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> Iterator::difference_type difference_type; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> Iterator::value_type value_type; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> Iterator::pointer pointer; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> Iterator:: reference reference; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> Iterator::iterator_category iterator_category;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &lt;iterator&gt; 中还对 iterator_traits 进行了偏特化:</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;<span class=\"keyword\">struct</span>  <span class=\"title class_\">iterator_traits</span> &lt;T*&gt;&#123; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">ptrdiff_t</span> difference_type;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> T value_type; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> T* pointer;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> T&amp; reference;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt; <span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt; <span class=\"keyword\">struct</span> <span class=\"title class_\">iterator_traits</span>&lt;<span class=\"type\">const</span> T*&gt; &#123; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">ptrdiff_t</span> difference_type; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> T value_type;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">const</span> T* pointer; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">const</span> T&amp; reference; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以把一个迭代器类型作为它的模板参数，该模板中定义了 种迭代器的类型特征，这些特征分别使用作为模板参数的迭代器的相应类型特征来定义。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> InputIterator, <span class=\"keyword\">class</span> OutputIterator&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mySort</span><span class=\"params\">(InputIterator first, InputIterator last, OutputIterator result)</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;<span class=\"keyword\">typename</span> iterator_traits&lt;InputIterator&gt;::value_type&gt; <span class=\"built_in\">s</span>(first, last);</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(s.<span class=\"built_in\">begin</span>(), s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(s.<span class=\"built_in\">begin</span>(), s.<span class=\"built_in\">end</span>(), result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">double</span> a[<span class=\"number\">5</span>] = &#123; <span class=\"number\">3.1</span>, <span class=\"number\">4</span>,<span class=\"number\">3</span>, <span class=\"number\">8.4</span>, <span class=\"number\">2.0</span>&#125;;</span><br><span class=\"line\">\t<span class=\"built_in\">mySort</span>(a, a + <span class=\"number\">5</span>, <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">double</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">mySort</span>(<span class=\"built_in\">istream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cin), <span class=\"built_in\">istream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">&quot; &quot;</span>));</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"知识点\">知识点<a title=\"#知识点\" href=\"#知识点\"></a></h3>\n<ol>\n<li>删除向量容器的元素时，并不会使空闲的空间被释放，这时可以使用下面的语句达到释放多余空间的目的 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;T&gt; (s .begin() s.end()).swap(s);</span><br></pre></td></tr></table></figure>\n</li>\n<li>C++ 中，接口通常通过纯虚函数或接口类来定义，并被用于实现多态和接口隔离等设计模式。</li>\n<li>mem_fn函数是一个类模板，用于将一个成员函数转换为一个普通函数对象。</li>\n<li>Boost库: Boost 社区和 c++ 标准委员会具有非常密切的联系。Boost 中的一部分程序库是对 TR1 的实现，所谓 TR1 (C++ Technical Report 1)是指 c++ 标准委员会发布的一个文档，文档中定义了对C++标准库的一些扩展，TR1 即将被纳入下一版 c++ 标准。</li>\n</ol>\n<p><strong>参考</strong></p>\n<ol>\n<li>《C++语言程序设计（第4版）》 IBSN 9787302227984</li>\n<li><a href=\"https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5\" target=\"_blank\">C++参考手册</a></li>\n<li><a href=\"https://learn.microsoft.com/zh-cn/cpp/standard-library/iomanip?view=msvc-170\" target=\"_blank\">Microsoft C++文档</a></li>\n</ol>\n","prev":{"title":"[Java笔记]类&对象","link":"2023/05/03/[Java笔记]类&对象"},"next":{"title":"[Java]Task","link":"2023/05/01/[Java]Task"},"plink":"https://s1acr.github.io/2023/05/02/[C++笔记]泛型程序设计与STL/","toc":[{"id":"泛型程序设计","title":"泛型程序设计","index":"1"},{"id":"stl简介","title":"STL简介","index":"2","children":[{"id":"容器(container)","title":"容器(container)","index":"2.1"},{"id":"迭代器(iterater)","title":"迭代器(iterater)","index":"2.2"},{"id":"函数对象(function-object)","title":"函数对象(function object)","index":"2.3"},{"id":"算法-(algorithm)","title":"算法 (algorithm)","index":"2.4"}]},{"id":"迭代器","title":"迭代器","index":"3","children":[{"id":"输入输出流迭代器","title":"输入输出流迭代器","index":"3.1"},{"id":"迭代器的分类","title":"迭代器的分类","index":"3.2"},{"id":"迭代器的辅助函数","title":"迭代器的辅助函数","index":"3.3"}]},{"id":"容器","title":"容器","index":"4","children":[{"id":"容器的基本功能","title":"容器的基本功能","index":"4.1"},{"id":"顺序容器","title":"顺序容器","index":"4.2","children":[{"id":"三种容器的比较","title":"三种容器的比较","index":"4.2.1"},{"id":"顺序容器的插入迭代器","title":"顺序容器的插入迭代器","index":"4.2.2"},{"id":"顺序容器的适配器","title":"顺序容器的适配器","index":"4.2.3"}]},{"id":"关联容器","title":"关联容器","index":"4.3","children":[{"id":"set","title":"set","index":"4.3.1"},{"id":"map","title":"map","index":"4.3.2"}]}]},{"id":"函数对象","title":"函数对象","index":"5","children":[{"id":"产生器-(generator)-一元函数-(unary-function)-二元函数-(binary-function)","title":"产生器 (generator) 一元函数 (unary function) 二元函数 (binary function)","index":"5.1"},{"id":"一元谓词-(unary-predicate)-二元谓词-(binary-predicate)","title":"一元谓词 (unary predicate) 二元谓词 (binary predicate)","index":"5.2"},{"id":"关联类型-(associated-types)","title":"关联类型 (associated types)","index":"5.3"},{"id":"函数适配器","title":"函数适配器","index":"5.4"}]},{"id":"算法","title":"算法","index":"6","children":[{"id":"不可变序列算法","title":"不可变序列算法","index":"6.1"},{"id":"可变序列算法","title":"可变序列算法","index":"6.2"},{"id":"排序和搜索算法","title":"排序和搜索算法","index":"6.3"},{"id":"数值算法","title":"数值算法","index":"6.4"}]},{"id":"扩展","title":"扩展","index":"7","children":[{"id":"利用函数对象的类型特征实现函数适配器","title":"利用函数对象的类型特征实现函数适配器","index":"7.1"},{"id":"迭代器的类型特征","title":"迭代器的类型特征","index":"7.2"},{"id":"利用类型特征实现算法","title":"利用类型特征实现算法","index":"7.3"},{"id":"知识点","title":"知识点","index":"7.4"}]}],"reward":true,"copyright":{"author":"slacr_","license":"<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" target=\"_blank\"><img src = \"/lib/cc-by-nc-sa.svg\">CC BY-NC-ND 4.0</a>","published":"May 2, 2023","updated":"May 2, 2023"},"reading_time":"10447 words in 70 min"}