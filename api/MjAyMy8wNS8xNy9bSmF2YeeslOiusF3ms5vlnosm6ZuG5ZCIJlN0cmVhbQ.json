{"title":"[Java笔记]泛型&集合&Stream","date":"2023-05-17T00:00:00.000Z","date_formatted":{"ll":"May 17, 2023","L":"05/17/2023","MM-DD":"05-17"},"link":"2023/05/17/[Java笔记]泛型&集合&Stream","comments":true,"categories":["Java"],"updated":"2023-05-17T00:00:00.000Z","content":"<blockquote>\n<p>Java 笔记</p>\n</blockquote>\n<h2 id=\"泛型\">泛型<a title=\"#泛型\" href=\"#泛型\"></a></h2>\n<p>泛型是Java5引进的新特征，是类和接口的一种扩展机制，主要实现<code>参数化类型(parameterized type)</code>机制。泛型被广泛应用在 Java 集合API 中，在Java集合框架中大多数的类和接口都是泛型类型。使用泛型，程序员可以编写更安全的程序.</p>\n<h3 id=\"泛型类型\">泛型类型<a title=\"#泛型类型\" href=\"#泛型类型\"></a></h3>\n<p>泛型 (generics) 是带一个或多个类型参数 (type parameter) 的类或接口。<br>\n按照约定，类型参数名使用单个大写字母表示。常用的类型参数名有E (表示元素)、K (表示键)、 N (表示数字)、 T (表示类型)、 V (表示值)等<br>\n泛型参数不能是原始数据类型 primitive type</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Entry</span>&lt;K, V&gt; &#123;  <span class=\"comment\">// 泛型接口</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> K <span class=\"title function_\">getKey</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> V <span class=\"title function_\">getValue</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Pair</span>&lt;K, V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Entry</span>&lt;K, V&gt; &#123;   <span class=\"comment\">// 泛型类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> K key;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> V value;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Pair</span><span class=\"params\">(K key, V value)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setKey</span><span class=\"params\">(K key)</span> &#123;<span class=\"built_in\">this</span>.key = key;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  K <span class=\"title function_\">getKey</span><span class=\"params\">()</span> &#123;<span class=\"keyword\">return</span> key;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(V value)</span> &#123;<span class=\"built_in\">this</span>.value = value;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> V <span class=\"title function_\">getValue</span><span class=\"params\">()</span> &#123;<span class=\"keyword\">return</span> value;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"keyword\">void</span> <span class=\"title function_\">getType</span><span class=\"params\">(T t, K k, V v)</span> &#123;   <span class=\"comment\">// 泛型方法, 泛型参数表位置在返回值前</span></span><br><span class=\"line\">        System.out.println(t.getClass().getName());</span><br><span class=\"line\">        System.out.println(k.getClass().getName());</span><br><span class=\"line\">        System.out.println(v.getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Pair&lt;String, Integer&gt; p_1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Pair</span>&lt;&gt;(<span class=\"string\">&quot;slacr&quot;</span>, <span class=\"number\">19</span>);</span><br><span class=\"line\">        Pair&lt;String, Integer&gt; p_2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Pair</span>&lt;&gt;(<span class=\"string\">&quot;hacker&quot;</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">        Pair&lt;Pair, Pair&gt; pp = <span class=\"keyword\">new</span> <span class=\"title class_\">Pair</span>&lt;&gt;(p_1, p_2);</span><br><span class=\"line\">        System.out.println(pp.getKey().getKey());</span><br><span class=\"line\">        System.out.println(pp.getKey().getValue());</span><br><span class=\"line\"></span><br><span class=\"line\">        pp.&lt;Integer&gt;getType(<span class=\"number\">2</span>, pp, p_1 );   <span class=\"comment\">// 注意类型位置在方法名前， C++中是在后</span></span><br><span class=\"line\">        <span class=\"comment\">//java.lang.Integer</span></span><br><span class=\"line\">        <span class=\"comment\">//generics.Pair</span></span><br><span class=\"line\">        <span class=\"comment\">//generics.Pair</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通配符'？'\">通配符’？’<a title=\"#通配符'？'\" href=\"#通配符'？'\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt;<span class=\"keyword\">void</span> <span class=\"title function_\">printList</span><span class=\"params\">(List&lt;T&gt; list)</span> &#123; <span class=\"comment\">// 通配符的存在相当于让方法参数化便于传入类型的多样，但在类中无法使用参数化的类型</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Object e : list) &#123;              <span class=\"comment\">// 这样也能实现一样的效果， 只不过通配符是让编译器识别</span></span><br><span class=\"line\">            System.out.println(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printList_1</span><span class=\"params\">(List&lt;?&gt; list)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Object e : list) &#123;</span><br><span class=\"line\">            System.out.println(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;slacr&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Main.&lt;String&gt;printList(list);</span></span><br><span class=\"line\">        printList(list); <span class=\"comment\">// 也可以让编译器自动识别，</span></span><br><span class=\"line\">        printList_1(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"有界类型参数\">有界类型参数<a title=\"#有界类型参数\" href=\"#有界类型参数\"></a></h3>\n<p><code>有界类型参数 (bounded type parameter)</code>。 有界类型分为上界和下界，上界用 extends指定，下界用super指定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//public static double getAvg(List&lt;? extends Number &gt; list)&#123;  // extends指定上界为Number, 只能传Number或其子类对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;U <span class=\"keyword\">extends</span> <span class=\"title class_\">Number</span> &amp; java.io.Serializable&gt; <span class=\"type\">double</span> <span class=\"title function_\">getAvg</span><span class=\"params\">(List&lt;U&gt; list)</span>&#123;   <span class=\"comment\">// 或者这么写, 不用通配符</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">total</span> <span class=\"operator\">=</span> <span class=\"number\">0D</span>;                                  <span class=\"comment\">// 下界用 super 关键词指定, 实现接口用 &amp;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Number number : list) &#123;</span><br><span class=\"line\">            total += number.doubleValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total/list.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; integerList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        integerList.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">        integerList.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">        integerList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">        System.out.println(getAvg(integerList));</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Float&gt; floatList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        floatList.add(<span class=\"number\">3F</span>);</span><br><span class=\"line\">        floatList.add(<span class=\"number\">4F</span>);</span><br><span class=\"line\">        System.out.println(getAvg(floatList));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型擦除\">类型擦除<a title=\"#类型擦除\" href=\"#类型擦除\"></a></h3>\n<p>当实例化泛型类型时，编译器使用一种叫<code>类型擦除 (type erasure)</code>的技术转换这些类型。在编译时，编译器将清除类和方法中所有与类型参数有关的信息。类型擦除可让使用泛型的Java应用程序与之前不使用泛型类型的 Java类库和应用程序兼容</p>\n<p>例如，<code>Node&lt;Integer&gt;被转换成 Node, 它称为源类型 (raw type)</code>。源类型是不带任何类型参数的泛型类或接口名。这说明在运行时找不到泛型类使用的是什么类型。</p>\n<p>也就是说泛型类在编译时泛型参数的类型是不可确定的, 只有在实例化对象时才能确定, 因此定义泛型类或方法的时候只能声明存在该参数类型的变量, 而不能直接使用, 像 new T() 或者赋值.</p>\n<h2 id=\"集合框架\">集合框架<a title=\"#集合框架\" href=\"#集合框架\"></a></h2>\n<p>Java 提供了一个集合框架 (Collections Framework), 该框架定义了一组接口和类, 使得处理对象组更容易。</p>\n<p><code>集合是指集中存放一组对象的一个对象</code>。集合相当于一个容器，提供了保存、获取和操作其他元素的方法。集合能够帮助Java程序员轻松地管理对象。 Java 集合框架由两种类型构成，一个是<code>Collection</code>; 另一个是<code>Map</code>。Collection 对象用于存放一组对象， Map 对象用于存放一组“关键字/值”的对象。 Collection和 Map 是最基本的接口，它们又有子接口.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305161320016.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>Collection<E>接口是所有集合类型的根接口，继承了 Iterable<E>接口. Collection接口定义了集合操作的常用方法，这些方法可以简单分为<code>基本操作、批量操作、数组操作和流操作</code>。</p>\n<h3 id=\"基本操作\">基本操作<a title=\"#基本操作\" href=\"#基本操作\"></a></h3>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>boolean add(E e)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>boolean remove(Object o)</code></td>\n<td style=\"text-align:left\">删除首次出现元素 o</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>boolean contains(Object o)</code></td>\n<td style=\"text-align:left\">返回集合中是否包含指定的元素o。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>boolean isEmpty()</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int size()</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>Iterator iterator()</code></td>\n<td style=\"text-align:left\">返回包含所有元素的迭代器对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>default void forEach(Consumer&lt;? super T&gt;action)</code></td>\n<td style=\"text-align:left\">从父接口继承的方法，在集合的每个元素上执行指定的操作。</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"批量操作\">批量操作<a title=\"#批量操作\" href=\"#批量操作\"></a></h3>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td>\n<td style=\"text-align:left\">将集合 c 中的所有元素添加到当前集合中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>boolean removeAll(Collection&lt;?&gt;c)</code></td>\n<td style=\"text-align:left\">从当前集合中删除c 中的所有元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>default boolean removeif(Predicate&lt;? super E&gt; filter)</code></td>\n<td style=\"text-align:left\">从当前集合中删除满足谓词的所有元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>boolean containsAll(Collection&lt;?&gt;c)</code></td>\n<td style=\"text-align:left\">返回当前集合是否包含c 中的所有元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>boolean retainAll(Collection&lt;?&gt;c)</code></td>\n<td style=\"text-align:left\">在当前集合中只保留指定集合 c 中的元素，其他元素删除。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>void clear()</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"数组操作\">数组操作<a title=\"#数组操作\" href=\"#数组操作\"></a></h3>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>Object[] toArray()</code></td>\n<td style=\"text-align:left\">返回包含集合中所有元素的对象数组。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>&lt;T&gt;T[] toArray(T[] a)</code></td>\n<td style=\"text-align:left\">返回包含集合中所有元素的数组，返回数组的元素类型是指定的数组类型</td>\n</tr>\n</tbody>\n</table></div></div><p>Object[] a = c.toArray(); 将Collection对象转换为Object数组.</p>\n<h3 id=\"流(stream)操作\">流(Stream)操作<a title=\"#流(stream)操作\" href=\"#流(stream)操作\"></a></h3>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>public default Stream&lt;E&gt; stream()</code></td>\n<td style=\"text-align:left\">以当前集合作为源返回一个顺序 Stream对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public default Stream&lt;E&gt; paralellStream()</code></td>\n<td style=\"text-align:left\">以当前集合作为源返回一个并行 Stream对象。</td>\n</tr>\n</tbody>\n</table></div></div><h2 id=\"list-接口及实现类\">List 接口及实现类<a title=\"#list-接口及实现类\" href=\"#list-接口及实现类\"></a></h2>\n<p>List接口是 Collection的子接口，实现一种线性表的数据结构.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305161332445.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>List 接口除继承 Collection的方法外，还定义了一些自己的方法。</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>E get(int index)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>E set(int index,E element)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>void add(int index, E element)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>E remove(int index)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>abstract boolean addAll(int index, Collection&lt;? extends E&gt; c)</code></td>\n<td style=\"text-align:left\">在指定下标处插入集合c 中的全部元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int indexOf(Object o)</code></td>\n<td style=\"text-align:left\">查找指定对象第一次出现的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int lastIndexOf(Object o)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>List&lt;E&gt;subList(int from,int to)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>default void replaceAll(UnaryOperator&lt;E&gt; operator)</code></td>\n<td style=\"text-align:left\">将操作符应用于元素，并使用其结果替代每个元素。</td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// List 接口不能直接实例化, 但能通过子类上转型来实现</span></span><br><span class=\"line\">        List&lt;Character&gt; characterList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            characterList.add((<span class=\"type\">char</span>)(<span class=\"string\">&#x27;A&#x27;</span>+i));</span><br><span class=\"line\">            System.out.println(characterList.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"arraylist类\">ArrayList类<a title=\"#arraylist类\" href=\"#arraylist类\"></a></h3>\n<p>ArrayList是最常用的线性表实现类，通过数组实现的集合对象。 ArrayList类实际上实现了一个<code>变长的对象数组</code>，其元素可以动态地增加和删除。它的定位访问时间是常量时间。</p>\n<p>ArrayList() 创建一个空的数组线性表对象，默认初始容量是10。<br>\nArrayList(Collection c) 用集合c 中的元素创建一个数组线性表对象.<br>\nArrayList(int initialCapacity)</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; stringArrayList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        stringArrayList.add(<span class=\"string\">&quot;how &quot;</span>);</span><br><span class=\"line\">        stringArrayList.add(<span class=\"string\">&quot;are &quot;</span>);</span><br><span class=\"line\">        stringArrayList.add(<span class=\"string\">&quot;you &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String s : stringArrayList) &#123;  <span class=\"comment\">// 增强的 for 循环, 不仅仅可以用来遍历数组, 还可以用来遍历 集合 , 实现了collection 接口的实例</span></span><br><span class=\"line\">            System.out.print(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        stringArrayList.forEach((s) -&gt; System.out.print(s));  <span class=\"comment\">// 使用 forEach 方法, 跟 js 太像了</span></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        stringArrayList.forEach(System.out::print);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用迭代器\">使用迭代器<a title=\"#使用迭代器\" href=\"#使用迭代器\"></a></h4>\n<p>迭代器是一个可以遍历集合中每个元素的对象。调用集合对象的 <code>iterator()</code> 方法可以得到 Iterator对象</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>boolean hasNext()</code></td>\n<td style=\"text-align:left\">返回迭代器中是否还有对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>E next()</code></td>\n<td style=\"text-align:left\">返回迭代器中下一个对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>void remove()</code></td>\n<td style=\"text-align:left\">删除迭代器中的当前对象</td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; stringArrayList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        stringArrayList.add(<span class=\"string\">&quot;how &quot;</span>);</span><br><span class=\"line\">        stringArrayList.add(<span class=\"string\">&quot;are &quot;</span>);</span><br><span class=\"line\">        stringArrayList.add(<span class=\"string\">&quot;you &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Iterator&lt;String&gt; stringIterator = stringArrayList.iterator();</span><br><span class=\"line\">        stringIterator.next();   <span class=\"comment\">// 一开始是首元素前， 移动到第一个元素位置</span></span><br><span class=\"line\">        stringIterator.remove();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (stringIterator.hasNext()) &#123;      <span class=\"comment\">// 使用迭代器遍历</span></span><br><span class=\"line\">            System.out.printf(stringIterator.next()); <span class=\"comment\">// next() 返回容器中对象后自增</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"双向迭代器\">双向迭代器<a title=\"#双向迭代器\" href=\"#双向迭代器\"></a></h4>\n<p>List还提供了listIterator() 方法返回ListIterator对象。它可以从前后两个方向遍历线性表中元素，在迭代中修改元素以及获得元素的当前位置。ListIterator是Iterator的子接口，不但继承了Iterator接口中的方法，还定义了自己的方法。</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>E next()</code></td>\n<td style=\"text-align:left\">返回下一个元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>boolean hasPrevious()</code></td>\n<td style=\"text-align:left\">返回是否还有前一个元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>E previous()</code></td>\n<td style=\"text-align:left\">返回前一个元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int nextIndex()</code></td>\n<td style=\"text-align:left\">返回下一个元素的索引。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int previousIndex()</code></td>\n<td style=\"text-align:left\">返回前一个元素的索引。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>void remove()</code></td>\n<td style=\"text-align:left\">删除当前元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>void set(E o)</code></td>\n<td style=\"text-align:left\">修改当前元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>void add(E o)</code></td>\n<td style=\"text-align:left\">在当前位置插入一个元素</td>\n</tr>\n</tbody>\n</table></div></div><p>使用迭代器可以修改线性表中的元素，但不能同时使用两个迭代器修改一个线性表中的元素，否则将抛出异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; stringArrayList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        stringArrayList.add(<span class=\"string\">&quot;how &quot;</span>);</span><br><span class=\"line\">        stringArrayList.add(<span class=\"string\">&quot;are &quot;</span>);</span><br><span class=\"line\">        stringArrayList.add(<span class=\"string\">&quot;you &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ListIterator&lt;String&gt; stringListIterator = stringArrayList.listIterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (stringListIterator.hasNext()) stringListIterator.next();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (stringListIterator.hasPrevious()) System.out.println(stringListIterator.previous()); <span class=\"comment\">// 逆向遍历</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"数组转list对象\">数组转List对象<a title=\"#数组转list对象\" href=\"#数组转list对象\"></a></h4>\n<p>java.util.Arrays 类提供了一个 asList()方法，实现将数组转换成 List对象的功能.</p>\n<p><code>public static &lt;T&gt; List&lt;T&gt; asList(T ...a)</code></p>\n<p>该方法提供了一个从多个元素创建 List 对象的途径，它的功能与 <code>Collection 接口的 toArray()</code>方法相反.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; stringArrayList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        stringArrayList.add(<span class=\"string\">&quot;how &quot;</span>);</span><br><span class=\"line\">        stringArrayList.add(<span class=\"string\">&quot;are &quot;</span>);</span><br><span class=\"line\">        stringArrayList.add(<span class=\"string\">&quot;you &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        String[] strings = stringArrayList.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String string : strings) &#123;</span><br><span class=\"line\">            System.out.print(string + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        List&lt;String&gt; stringList =  Arrays.asList(strings);  <span class=\"comment\">// asList()底层其实就是 调用ArrayList(... a) 构造</span></span><br><span class=\"line\">        stringList.forEach(System.out::print);</span><br><span class=\"line\">        List&lt;String&gt; stringList1 = Arrays.asList(<span class=\"string\">&quot;seize&quot;</span>, <span class=\"string\">&quot;the&quot;</span>, <span class=\"string\">&quot;moment&quot;</span>);</span><br><span class=\"line\">        stringList1.forEach(s-&gt;&#123;System.out.print(s + <span class=\"string\">&quot; &quot;</span>);&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"vector-和-stack\">Vector 和 Stack<a title=\"#vector-和-stack\" href=\"#vector-和-stack\"></a></h3>\n<p>Vector类和Stack类是Java早期版本提供的两个集合类，分别实现<code>向量和对象栈</code>。Vector类和 Stack类的方法都是<code>同步的</code>，适合在<code>多线程</code>的环境中使用.</p>\n<h2 id=\"set接口及其实现类\">Set接口及其实现类<a title=\"#set接口及其实现类\" href=\"#set接口及其实现类\"></a></h2>\n<p>Set 接口是 Collection的子接口，Set 接口对象类似于数学上的集合概念，其中<code>不允许有重复的元素</code>。 Set 接口没有定义新的方法，只包含从Collection接口继承的方法。<br>\nSet 接口的常用实现类有 <code>HashSet 类、 TreeSet 类和 LinkedHashSet类</code> 。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305161456356.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"hashset-类\">HashSet 类<a title=\"#hashset-类\" href=\"#hashset-类\"></a></h3>\n<p>HashSet类用散列方法存储元素，具有最好的存取性能，但元素没有顺序。<br>\nHashing 散列算法最重要的就是 hash函数, 通过实际值与生成哈希值的单射完成高效存取.</p>\n<p><code>HashSet()</code>  创建一个空的散列集合，该集合的默认初始容量是16, 默认装填因子(loadfactor) 是0.75。装填因子决定何时对散列表进行再散列。例如，如果装填因子为0.75(默认值), 而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说，装填因子为75%是比较合理的。</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>HashSet(Collection c)</code></td>\n<td style=\"text-align:left\">用指定的集合c 的元素创建一个散列集合。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>HashSet(int initialCapacity)</code></td>\n<td style=\"text-align:left\">创建一个散列集合，并指定集合的初始容量。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>HashSet(int initialCapacity, float loadFactor)</code></td>\n<td style=\"text-align:left\">创建一个散列集合，并指定的集合初始容量和装填因子</td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Set&lt;String&gt; words =<span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        words.add(<span class=\"string\">&quot;one&quot;</span>);</span><br><span class=\"line\">        words.add(<span class=\"string\">&quot;two&quot;</span>);</span><br><span class=\"line\">        words.add(<span class=\"string\">&quot;three&quot;</span>);</span><br><span class=\"line\">        words.add(<span class=\"string\">&quot;one&quot;</span>);       <span class=\"comment\">// 重复元素无效</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String word : words) &#123;</span><br><span class=\"line\">            System.out.println(word);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"用-set-对象实现集合运算\">用 Set 对象实现集合运算<a title=\"#用-set-对象实现集合运算\" href=\"#用-set-对象实现集合运算\"></a></h3>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>sl.addAll(s2)</code></td>\n<td style=\"text-align:left\">实现集合sl 与 s2 的并运算。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>sl.retainAll(s2)</code></td>\n<td style=\"text-align:left\">实现集合 s1与 s2 的交运算。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>sl.removeAll(s2)</code></td>\n<td style=\"text-align:left\">实现集合 s1 与 s2 的差运算。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>sl.containAll(s2)</code></td>\n<td style=\"text-align:left\">如果 s2是 s1 的子集，该方法返回 true。</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"treeset-类\">TreeSet 类<a title=\"#treeset-类\" href=\"#treeset-类\"></a></h3>\n<p>TreeSet实现一种树集合，使用<code>红-黑树</code>为元素排序，添加到 TreeSet 中的元素必须是可比较的，即元素的类必须实现 <code>Comparable&lt;T&gt;</code> 接口。它的操作要比 HashSet 慢。</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>TreeSet(Collection c)</code></td>\n<td style=\"text-align:left\">用指定集合c 中的元素创建一个新的树集合，集合中的元素按自然顺序排序。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>TreeSet(Comparator c)</code></td>\n<td style=\"text-align:left\">创建一个空的树集合，元素的排序规则按给定的比较器c 的规则排序。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>TreeSet(SortedSet s)</code></td>\n<td style=\"text-align:left\">用 SortedSet 对象 s 中的元素创建一个树集合，排序规则与 s 的排序规则相同。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"> </td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>E first()</code></td>\n<td style=\"text-align:left\">返回有序集合中的第一个元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>E last()</code></td>\n<td style=\"text-align:left\">返回有序集合中最后一个元素。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>SortedSet&lt;E&gt; subSet(E fromElement, E toElement)</code></td>\n<td style=\"text-align:left\">返回有序集合中的一个子有序集合，它的元素从 fromElement 开始到 toElement结束(不包括最后元素)。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>SortedSet&lt;E&gt; headSet(E toElement)</code></td>\n<td style=\"text-align:left\">返回有序集合中小于指定元素 toElement 的一个子有序集合。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>SortedSet&lt;E&gt; tailSet(E fromElement)</code></td>\n<td style=\"text-align:left\">返回有序集合中大于等于 fromElement 元素的子有序集合。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>Comparator&lt;? super E&gt; comparator()</code></td>\n<td style=\"text-align:left\">返回与该有序集合相关的比较器，如果集合使用自然顺序则返回 null</td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        String[] strings = &#123;<span class=\"string\">&quot;Swift&quot;</span>, <span class=\"string\">&quot;TypeScript&quot;</span>, <span class=\"string\">&quot;Scala&quot;</span>, <span class=\"string\">&quot;Lisp&quot;</span>, <span class=\"string\">&quot;VBScript&quot;</span>, <span class=\"string\">&quot;Basic&quot;</span>&#125;;</span><br><span class=\"line\">        TreeSet&lt;String&gt; stringSet = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class=\"line\">            stringSet.add(strings[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(stringSet);  <span class=\"comment\">// 按自然顺序排列 // [Basic, Lisp, Scala, Swift, TypeScript, VBScript]</span></span><br><span class=\"line\">        SortedSet&lt;String&gt; sortedSet = stringSet.subSet(<span class=\"string\">&quot;Lisp&quot;</span>, <span class=\"string\">&quot;Swift&quot;</span>);</span><br><span class=\"line\">        System.out.println(sortedSet);  <span class=\"comment\">// [Lisp, Scala]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"对象顺序\">对象顺序<a title=\"#对象顺序\" href=\"#对象顺序\"></a></h4>\n<p>创建 TreeSet 类对象时如果没有指定比较器对象，集合中的元素按自然顺序排列。所谓自然顺序(natural order)是指集合对象实现了 <code>Comparable 接口的 compareTo()方法</code>，对象则根据该方法排序。如果试图对没有实现 Comparable 接口的集合元素排序，将抛出ClassCastException 异常。另一种排序方法是创建 TreeSet 对象时指定一个比较器对象，这样，元素将按比较器的规则排序。如果需要指定新的比较规则，可以定义一个类实现Comparator 接口，然后为集合提供一个新的比较器.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        String[] strings = &#123;<span class=\"string\">&quot;Swift&quot;</span>, <span class=\"string\">&quot;TypeScript&quot;</span>, <span class=\"string\">&quot;Scala&quot;</span>, <span class=\"string\">&quot;Lisp&quot;</span>, <span class=\"string\">&quot;VBScript&quot;</span>, <span class=\"string\">&quot;Basic&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"comment\">// TreeSet&lt;String&gt; stringSet = new TreeSet&lt;&gt;(Comparator.reverseOrder());   </span></span><br><span class=\"line\">        <span class=\"comment\">// 传个Comparator 比较器对象使Set红黑树按指定顺序进入</span></span><br><span class=\"line\">        TreeSet&lt;String&gt; stringSet = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeSet</span>&lt;&gt;((String s1, String s2) -&gt; s2.compareTo(s1));  <span class=\"comment\">// 或者Lambda表达式</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class=\"line\">            stringSet.add(strings[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(stringSet);   </span><br><span class=\"line\">        <span class=\"comment\">// [VBScript, TypeScript, Swift, Scala, Lisp, Basic]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"queue-接口及其实现类\">Queue 接口及其实现类<a title=\"#queue-接口及其实现类\" href=\"#queue-接口及其实现类\"></a></h2>\n<p>Queue接口是Collection的子接口，是以先进先出 (first in first out,FIFO)的方式排列其元素，一般称为队列。</p>\n<p>Deque 接口对象实现双端队列，ArrayDeque 和 LinkedList 是它的两个实现类。<br>\nPriorityQueue 实现的是一种优先队列，优先队列中元素的顺序是根据元素的值排列的.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305162100313.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"queue-接口和-deque-接口\">Queue 接口和 Deque 接口<a title=\"#queue-接口和-deque-接口\" href=\"#queue-接口和-deque-接口\"></a></h3>\n<p>Queue 接口除了提供 Collection的操作外, 还提供了插入、删除和检查操作。</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>boolean add(E e)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>boolean offer(E e)</code></td>\n<td style=\"text-align:left\">将指定的元素 e 插入到队列中。 失败add抛出异常, offer返回false</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"> </td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>E remove()</code></td>\n<td style=\"text-align:left\">返回队列头元素，同时将其删除。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>E poll()</code></td>\n<td style=\"text-align:left\">返回队列头元素，同时将其删除。 失败remove抛出异常, poll返回null</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"> </td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>E element()</code></td>\n<td style=\"text-align:left\">返回队列头元素，但不将其删除。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>E peek() </code></td>\n<td style=\"text-align:left\">返回队列头元素，但不将其删除。 失败element抛出异常, peek返回null</td>\n</tr>\n</tbody>\n</table></div></div><p>Queue 接口的每种操作都有两种形式：一个是在操作失败时抛出异常；另一个是在操作失败时返回一个特定的值(根据操作的不同，可能返回 null或 false)</p>\n<p>Deque 接口实现双端队列，支持从两端插入和删除元素，同时实现了 Stack 和 Queue 的功能。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305162112698.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>第一个方法在操作失败时抛出异常；第二个方法操作失败返回一个特殊值。除表中定义的基本方法外, Deque 接口还定义了 removeFirstOccurence() 和 removeLastOccurence()方法，分别用于删除第一次出现的元素，删除最后出现的元素.</p>\n<h3 id=\"arraydeque-类和-linkedlist-类\">ArrayDeque 类和 LinkedList 类<a title=\"#arraydeque-类和-linkedlist-类\" href=\"#arraydeque-类和-linkedlist-类\"></a></h3>\n<p>Deque 的常用实现类包括 <code>ArrayDeque类和LinkedList</code>类，前者是<code>可变数组</code>的实现；后者是<code>线性表</code>的实现。LinkedList类比 ArayDeque类更灵活，实现了线性表的所有操作，其中可以存储null元素，但ArrayDeque 对象不能存储null.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ArrayDeque&lt;String&gt; arrayDeque = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\">        arrayDeque.add(<span class=\"string\">&quot;till &quot;</span>);</span><br><span class=\"line\">        arrayDeque.offerFirst(<span class=\"string\">&quot;it &quot;</span>);</span><br><span class=\"line\">        arrayDeque.addFirst(<span class=\"string\">&quot;fake &quot;</span>);</span><br><span class=\"line\">        arrayDeque.offerLast(<span class=\"string\">&quot;you &quot;</span>);</span><br><span class=\"line\">        arrayDeque.add(<span class=\"string\">&quot;make &quot;</span>);</span><br><span class=\"line\">        arrayDeque.addLast(<span class=\"string\">&quot;it. &quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        arrayDeque.forEach(System.out::print);</span><br><span class=\"line\">        arrayDeque.forEach(<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">                System.out.print(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        arrayDeque.forEach(x -&gt; System.out.print(x));</span><br><span class=\"line\">        Iterator&lt;String&gt; stringIterator = arrayDeque.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(stringIterator.hasNext()) System.out.print(stringIterator.next());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String s : arrayDeque) &#123; System.out.print(s);&#125;</span><br><span class=\"line\">        <span class=\"comment\">// 几种遍历练习练习</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LinkedList允许null元素, 如果需要经常在线性表的头部添加元素或在内部删除元素，就应该使用LinkedList。这些操作在LinkedList中是常量时间，在ArrayList中是线性时间。而对定位访问LinkedList是线性时间，ArrayList是常量时间。<br>\n就是链表和顺序表的区别.<br>\n<code>LinkedList 同时实现了List 接口和Queue 接口</code>.</p>\n<p><code>LinkedList()</code><br>\n<code>LinkedList(Collection c)</code><br>\n<code>addFirst()、getFirst()、removeFirst()、addLast()、getLast() removeLast()</code>…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        Queue&lt;String&gt; stringQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">        stringQueue.add(<span class=\"string\">&quot;loading...&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">bar</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;██████████████████████████████&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; i &lt; bar.length() + <span class=\"number\">1</span>; i+= <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            stringQueue.add(bar.substring(<span class=\"number\">0</span>,i) + <span class=\"string\">&quot;  &quot;</span> + i/<span class=\"number\">3</span>*<span class=\"number\">10</span> + <span class=\"string\">&quot;%&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stringQueue.add(<span class=\"string\">&quot;done!&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stringQueue.isEmpty()) &#123;</span><br><span class=\"line\">            System.out.println(stringQueue.remove());</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305162207311.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"集合转换\">集合转换<a title=\"#集合转换\" href=\"#集合转换\"></a></h2>\n<p>集合实现类的构造方法可以接收一个Collection对象, 转换成该类型的集合. 所以许多集合类型之间可以相互转换.</p>\n<p><code>public ArrayList(Collection c)</code><br>\n<code>public HashSet(Collection c)</code><br>\n<code>public LinkedList(Collection c)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        HashSet&lt;Integer&gt; integerHashSet = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        integerHashSet.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">        integerHashSet.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">        LinkedList&lt;Integer&gt; integerLinkedList = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;(integerHashSet);</span><br><span class=\"line\">        integerLinkedList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">        integerLinkedList.add(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(integerLinkedList);  <span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"map-接口及其实现类\">Map 接口及其实现类<a title=\"#map-接口及其实现类\" href=\"#map-接口及其实现类\"></a></h2>\n<p>Map 是用来存储“键/值”对的对象。在 Map 中存储的<code>关键字和值都必须是对象</code>，并要求<code>关键字唯一</code>的，而值可以重复.<br>\nMap接口常用的实现类有 HashMap类、TreeMap类、Hashtable类和 LinkedHashMap类。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305162222926.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"基本操作-1\">基本操作<a title=\"#基本操作-1\" href=\"#基本操作-1\"></a></h3>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>public V put(K key, V value)</code></td>\n<td style=\"text-align:left\">向映射对象中添加一个“键/值”对。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public V get(Object key)</code></td>\n<td style=\"text-align:left\">返回指定键的值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public V remove(Object key)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public boolean containsKey(Object key)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public boolean containsValue(Object value)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>default V replace(K key,V value)</code></td>\n<td style=\"text-align:left\">若指定的“键/值”对存在于映射中，用指定的“键/值&quot;对替换之。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>default void forEach(BiConsumer&lt;? super K,? super V)</code></td>\n<td style=\"text-align:left\">对映射中的每项执行一次动作，直到所有项处理完或发生异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public int size()</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public boolean isEmpty()</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"批量操作-1\">批量操作<a title=\"#批量操作-1\" href=\"#批量操作-1\"></a></h3>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>public void putAll(Map&lt;? extends K,? extends V&gt; map)</code></td>\n<td style=\"text-align:left\">将参数 map 中的所有“键/值&quot;对添加到映射中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public void clear()</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public Set&lt;K&gt;keySet()</code></td>\n<td style=\"text-align:left\">返回由键组成的 Set对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public Collection&lt;V&gt;values()</code></td>\n<td style=\"text-align:left\">返回由值组成的 Collection对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet()</code></td>\n<td style=\"text-align:left\">返回包含 Map.Entry&lt;K,V&gt;的一个 Set对象</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"map-接口实现类\">Map 接口实现类<a title=\"#map-接口实现类\" href=\"#map-接口实现类\"></a></h3>\n<p>常用实现类有<code>HashMap、TreeMap和 Hashtable</code>类</p>\n<h4 id=\"hashmap-类\">HashMap 类<a title=\"#hashmap-类\" href=\"#hashmap-类\"></a></h4>\n<p>HashMap类以散列方法存放“键/值”对</p>\n<p><code>HashMap()</code> 创建一个空的映射对象，使用默认的装填因子(0.75)。<br>\n<code>HashMap(int initialCapacity)</code> 用指定初始容量和默认装填因子创建一个映射对象。<br>\n<code>HashMap(Map m)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt;  nameList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(Arrays.asList(<span class=\"string\">&quot;slacr&quot;</span>, <span class=\"string\">&quot;John&quot;</span>, <span class=\"string\">&quot;Amy&quot;</span>, <span class=\"string\">&quot;Tim&quot;</span>));</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; scoreList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(Arrays.asList(<span class=\"number\">60</span>, <span class=\"number\">53</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>));</span><br><span class=\"line\">        <span class=\"comment\">// Java的方法感觉比C++更好理解, 命名知其义, 注解也很全. 并且IDEA比VS智能多了</span></span><br><span class=\"line\">        Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nameList.size(); i++) &#123;</span><br><span class=\"line\">            map.put(nameList.get(i), scoreList.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.forEach((k, v) -&gt; &#123; System.out.printf(<span class=\"string\">&quot;%-10s%d\\n&quot;</span>, k, v);&#125;);</span><br><span class=\"line\">        <span class=\"comment\">//slacr     60</span></span><br><span class=\"line\">        <span class=\"comment\">//John      53</span></span><br><span class=\"line\">        <span class=\"comment\">//Tim       99</span></span><br><span class=\"line\">        <span class=\"comment\">//Amy       88</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"treemap-类\">TreeMap 类<a title=\"#treemap-类\" href=\"#treemap-类\"></a></h4>\n<p><code>TreeMap 类实现了SortedMap 接口</code>，保证Map 中的“键/值”对按关键字升序排序。</p>\n<p><code>TreeMap()</code><br>\n<code>TreeMap(Comparator c)</code><br>\n<code>TreeMap(Map m)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt;  nameList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(Arrays.asList(<span class=\"string\">&quot;slacr&quot;</span>, <span class=\"string\">&quot;John&quot;</span>, <span class=\"string\">&quot;Amy&quot;</span>, <span class=\"string\">&quot;Tim&quot;</span>));</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; scoreList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(Arrays.asList(<span class=\"number\">60</span>, <span class=\"number\">53</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>));</span><br><span class=\"line\">        TreeMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(String o1, String o2)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> scoreList.get(nameList.indexOf(o2)) - scoreList.get(nameList.indexOf(o1));    <span class=\"comment\">// map先放入的后输出</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);     <span class=\"comment\">// 按成绩高低排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nameList.size(); i++) &#123;</span><br><span class=\"line\">            map.put(nameList.get(i), scoreList.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.forEach(<span class=\"keyword\">new</span> <span class=\"title class_\">BiConsumer</span>&lt;String, Integer&gt;() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(String k, Integer v)</span> &#123;</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;No.%-5d%-10s%d\\n&quot;</span>,i, k, v);</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">//No.1    Tim       99</span></span><br><span class=\"line\">        <span class=\"comment\">//No.2    Amy       88</span></span><br><span class=\"line\">        <span class=\"comment\">//No.3    slacr     60</span></span><br><span class=\"line\">        <span class=\"comment\">//No.4    John      53</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hashtable-类和-enumeration-接口\">Hashtable 类和 Enumeration 接口<a title=\"#hashtable-类和-enumeration-接口\" href=\"#hashtable-类和-enumeration-接口\"></a></h4>\n<p>Hashtable类是 Java 早期版本提供的一个存放“键/值”对的实现类，实现了一种散列表，也属于集合框架。Hashtable类的方法都是同步的，因此它是线程安全的。<br>\n任何非null对象都可以作为散列表的关键字和值。但是要求作为关键字的对象必须实现 <code>hashCode()方法和equals()</code>方法，以使对象的比较成为可能。<br>\nHashtable类的 keys()方法和elements()方法的返回类型都是 <code>Enumeration</code> 接口类型的对象，通过该接口中hasMoreElements()方法和nextElement()方法可以对枚举对象元素迭代</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Hashtable&lt;Integer, String&gt; hashtable = <span class=\"keyword\">new</span> <span class=\"title class_\">Hashtable</span>&lt;&gt;();</span><br><span class=\"line\">        hashtable.put(<span class=\"number\">1</span>, <span class=\"string\">&quot;王二&quot;</span>);</span><br><span class=\"line\">        hashtable.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;陈清扬&quot;</span>);</span><br><span class=\"line\">        hashtable.put(<span class=\"number\">3</span>, <span class=\"string\">&quot;罗小四&quot;</span>);</span><br><span class=\"line\">        hashtable.put(<span class=\"number\">4</span>, <span class=\"string\">&quot;军代表&quot;</span>);</span><br><span class=\"line\">        hashtable.put(<span class=\"number\">5</span>, <span class=\"string\">&quot;敦敦伟大友谊&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> hashtable.get(<span class=\"number\">5</span>);</span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        Enumeration&lt;String&gt; words = hashtable.elements();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (words.hasMoreElements()) System.out.println(words.nextElement());</span><br><span class=\"line\">        <span class=\"comment\">//敦敦伟大友谊   map 先入后出</span></span><br><span class=\"line\">        <span class=\"comment\">//敦敦伟大友谊</span></span><br><span class=\"line\">        <span class=\"comment\">//军代表</span></span><br><span class=\"line\">        <span class=\"comment\">//罗小四</span></span><br><span class=\"line\">        <span class=\"comment\">//陈清扬</span></span><br><span class=\"line\">        <span class=\"comment\">//王二</span></span><br><span class=\"line\">        <span class=\"comment\">// map一些遍历</span></span><br><span class=\"line\">        hashtable.forEach((k, v) -&gt; System.out.println(k + <span class=\"string\">&quot;  &quot;</span> + v));    <span class=\"comment\">// 遍历键值对</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Integer k : hashtable.keySet()) System.out.print(k + <span class=\"string\">&quot;  &quot;</span>);  <span class=\"comment\">// keySet()返回key的set对象, 遍历键</span></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        hashtable.keySet().forEach(i-&gt; System.out.print(i+<span class=\"string\">&quot;  &quot;</span>));</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Iterator&lt;Integer&gt; it = hashtable.keySet().iterator(); it.hasNext(); )</span><br><span class=\"line\">            System.out.print(it.next()+<span class=\"string\">&quot;  &quot;</span>);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        hashtable.values().forEach(System.out::println);   <span class=\"comment\">// values() 返回 Collection 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        hashtable.entrySet().forEach((Map.Entry&lt;Integer, String&gt; entry) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(entry.getKey() + <span class=\"string\">&quot;  &quot;</span> + entry.getValue());</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// entrySet() 返回  Set&lt;Map.Entry&lt;K,V&gt;&gt;, 可以再用相当于将Map中每一个Entry条目再组合成一个Set, 可以按Set容器遍历</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"collections-类\">Collections 类<a title=\"#collections-类\" href=\"#collections-类\"></a></h2>\n<p><code>Collections类是java.util包中定义的工具类</code>，这个类提供了若干static方法实现集合对象的操作。这些操作大多对List操作，主要包括排序、重排、查找、求极值以及常规操作等。</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>排序</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static&lt;T&gt;void sort(List&lt;T&gt;list)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static&lt;T&gt; void sort(List&lt;T&gt;list, Comparator&lt;? super T&gt;c)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>查找</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static&lt;T&gt; int binarySearch(List&lt;T&gt; list, T key)</code></td>\n<td style=\"text-align:left\">List需要sorted 如果 List包含要查找的元素，方法返回元素的下标，否则返回值为(-插入点-1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static &lt;T&gt;int binarySearch(List&lt;T&gt; list, T key, Comparator c)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>打乱元素次序</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static void shuffle(List&lt;?&gt; list)</code></td>\n<td style=\"text-align:left\">使用默认的随机数打乱 List中元素的次序。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static void shuffle(List&lt;?&gt; list, Random rnd)</code></td>\n<td style=\"text-align:left\">使用指定的Random 对象，打乱List 中元素的次序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>求极值</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static  &lt;T&gt;T max(Collection&lt;? extends T&gt;coll)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static &lt;T&gt;T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static &lt;T&gt;T min(Collection&lt;? extends T&gt;coll)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static &lt;T&gt;T min(Collection&lt;? extends T&gt;coll, Comparator&lt;? super T&gt;comp)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>其他常用</strong></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static void reverse(List&lt;?&gt;list)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static void fill(List&lt;? super T&gt;list,T obj)</code></td>\n<td style=\"text-align:left\">用指定的值覆盖List中原来的每个值，该方法主要用于对 List进行重新初始化。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static void swap(List&lt;?&gt;list, int i, int j)</code></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static void rotate(List&lt;?&gt; list, int distance)</code></td>\n<td style=\"text-align:left\">旋转列表，将 i 位置的元素移动到(i+distance)%list.size() 的位置。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt;c, T ...elements)</code></td>\n<td style=\"text-align:left\">该方法用于将指定的元素添加到集合 c 中，可以指定单个元素或数组。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static int frequency(Collection&lt;?&gt;c, Object o)</code></td>\n<td style=\"text-align:left\">返回指定的元素o 在集合c 中出现的次数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static boolean disjoint(Collection&lt;?&gt;cl, Collection&lt;?&gt;c2)</code></td>\n<td style=\"text-align:left\">判断两个集合是否不相交。如果两个集合不包含相同的元素，该方法返回 true。</td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; integerArrayList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>));</span><br><span class=\"line\">        Collections.sort(integerArrayList, Comparator.reverseOrder());</span><br><span class=\"line\">        System.out.println(integerArrayList);</span><br><span class=\"line\">        Collections.shuffle(integerArrayList);</span><br><span class=\"line\">        System.out.println(integerArrayList);</span><br><span class=\"line\">        Collections.reverse(integerArrayList);</span><br><span class=\"line\">        System.out.println(integerArrayList);</span><br><span class=\"line\">        <span class=\"comment\">//[7, 6, 5, 4, 3, 2, 1]</span></span><br><span class=\"line\">        <span class=\"comment\">//[5, 1, 7, 2, 4, 6, 3]</span></span><br><span class=\"line\">        <span class=\"comment\">//[3, 6, 4, 2, 7, 1, 5]</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            map.put(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(Arrays.asList(<span class=\"string\">&quot;slacr&quot;</span>, <span class=\"string\">&quot;John&quot;</span>, <span class=\"string\">&quot;Amy&quot;</span>, <span class=\"string\">&quot;Tim&quot;</span>)).get(i),</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(Arrays.asList(<span class=\"number\">60</span>, <span class=\"number\">53</span>, <span class=\"number\">88</span>, <span class=\"number\">99</span>)).get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Collections.max(map.entrySet(), (entry1, entry2) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> entry1.getValue() - entry2.getValue();</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        <span class=\"comment\">//Tim=99</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"stream-api\">Stream API<a title=\"#stream-api\" href=\"#stream-api\"></a></h2>\n<p>流 (stream) 就像一个管道，将数据从源传输到目的地。流可分为顺序流和并行流。<br>\n流初看起来像集合，但流并不是存储对象的数据结构，仅<code>用来移动数据</code>，因此不能像集合一样向流中添加元素<br>\n使用流的主要原因是它支持顺序和并行的聚集操作。例如，可以很容易地过滤、排序或转换流中的元素<br>\nStream接口是最常用的类型。 Stream 对象可用来传输任何类型的对象。还有一些特殊的 Stream,如 IntStream、LongStream、DoubleStream等。上述的 Stream 都派生自 BaseStream。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305171150522.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>Stream 的有些方法执行中间操作，有些方法执行终止操作。中间操作是将一个流转换成另一个流，sorted、filter和 map 方法执行中间操作。终止操作产生一个最终结果， count、forEach 方法执行终止操作。流操作是延迟的，在源上的计算只有当终止操作开始时才执行.</p>\n<h3 id=\"创建与获得流\">创建与获得流<a title=\"#创建与获得流\" href=\"#创建与获得流\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Stream.of() 静态方法创建一个顺序流</span></span><br><span class=\"line\">        Stream&lt;Integer&gt; stream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        String[] strings = &#123;<span class=\"string\">&quot;Victor&quot;</span>, <span class=\"string\">&quot;Deque&quot;</span>, <span class=\"string\">&quot;Set&quot;</span>, <span class=\"string\">&quot;Map&quot;</span>&#125;;</span><br><span class=\"line\">        Stream&lt;String&gt; stringStream = Arrays.stream(strings);  <span class=\"comment\">// Arrays stream()将数组转换为流对象</span></span><br><span class=\"line\">        <span class=\"comment\">//default java.util.stream.Stream&lt;E&gt; stream();</span></span><br><span class=\"line\">        <span class=\"comment\">//default java.util.stream.Stream&lt;E&gt; parallelStream(); Collection接口中返回流对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//  public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;? extends T&gt; s)</span></span><br><span class=\"line\">        Stream&lt;Double&gt; randoms = Stream.generate(Math::random);   <span class=\"comment\">// 无限流</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class=\"line\">        Stream&lt;BigInteger&gt; integerStream = Stream.iterate(BigInteger.ZERO, n-&gt;n.add(BigInteger.ONE));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"连接与限制流\">连接与限制流<a title=\"#连接与限制流\" href=\"#连接与限制流\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Stream&lt;Integer&gt; s1 = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        Stream&lt;Integer&gt; s2 = Stream.of(<span class=\"number\">4</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        Stream&lt;Integer&gt; s3 = Stream.of(<span class=\"number\">6</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">// public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br><span class=\"line\">        <span class=\"comment\">// Stream.concat(Stream.concat(s1, s2), s3).sorted().forEach(System.out::print); // 123456</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);</span></span><br><span class=\"line\">        Stream.concat(Stream.concat(s1, s2), s3).sorted(Comparator.reverseOrder()).forEach(System.out::print); <span class=\"comment\">// 654321</span></span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        Stream&lt;Double&gt; randoms = Stream.generate(() -&gt; Double.valueOf(String.format(<span class=\"string\">&quot;%.2f&quot;</span>, Math.random()))).limit(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"comment\">// limit() 限制流长度, 截断流</span></span><br><span class=\"line\">        randoms.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"过滤流\">过滤流<a title=\"#过滤流\" href=\"#过滤流\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        Stream&lt;Integer&gt; stream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">        stream = stream.filter(i -&gt; i&gt;<span class=\"number\">3</span>);</span><br><span class=\"line\">        stream.forEach(System.out::println); <span class=\"comment\">// 4 5</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Path</span> <span class=\"variable\">parent</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;..&quot;</span>);</span><br><span class=\"line\">        Stream&lt;Path&gt; list = Files.walk(parent);</span><br><span class=\"line\">        list.filter((Path p) -&gt; p.toString().endsWith(<span class=\"string\">&quot;.java&quot;</span>)).forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"流转换\">流转换<a title=\"#流转换\" href=\"#流转换\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Stream&lt;Character&gt; characterStream = Stream.of(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//   &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span></span><br><span class=\"line\">        Stream&lt;Integer&gt; integerStream = characterStream.map((character -&gt; &#123;<span class=\"keyword\">return</span> Integer.valueOf(character);&#125;));</span><br><span class=\"line\">        integerStream.forEach(System.out::println);  <span class=\"comment\">// 65 66 67</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"流规约\">流规约<a title=\"#流规约\" href=\"#流规约\"></a></h3>\n<p>经常需要从流中获得一个结果，如返回流中元素的数量。此时，可以使用流的 count()方法实现。这样的方法称为规约方法 (reduction),规约是终止操作。Stream接口提供了几个简单的规约方法，除count()方法外，还有max()和min()方法，它们分别返回流中的最大值和最小值。需要注意的是，这两个方法返回一个Optional<T>类型的值，它可能会封装返回值，也可能表示没有返回(当流为空时).</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Stream&lt;Character&gt; characterStream = Stream.of(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//   &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span></span><br><span class=\"line\">        Stream&lt;Integer&gt; integerStream = characterStream.map((character -&gt; &#123;<span class=\"keyword\">return</span> Integer.valueOf(character);&#125;));</span><br><span class=\"line\">        <span class=\"comment\">// integerStream.forEach(System.out::println);  // 65 66 67</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//   Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);</span></span><br><span class=\"line\">        <span class=\"comment\">// System.out.println(integerStream.max(Comparator.reverseOrder())); Optional[65]</span></span><br><span class=\"line\">        System.out.println(integerStream.max(Comparator.reverseOrder()).get()); <span class=\"comment\">// 65</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"收集结果\">收集结果<a title=\"#收集结果\" href=\"#收集结果\"></a></h3>\n<p>当处理完流后，可能需要查看结果或将结果收集到其他容器中。可以使用 iterator()方法，该方法可以生成一个能够用来访问元素的传统迭代器。<br>\n调用toArray()方法获得一个含有流中所有元素的数组。因为<code>不可能在运行时创建一个泛型数组，所以表达式 stream.toArray()返回一个 Object[]类型数组</code>。如果想获得相应类型数组，可以将类型传递给数组的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stringStream = Stream.of(<span class=\"string\">&quot;gone&quot;</span>, <span class=\"string\">&quot;with&quot;</span>, <span class=\"string\">&quot;the&quot;</span>, <span class=\"string\">&quot;wind&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span></span><br><span class=\"line\">        String[] res = stringStream.toArray(String[]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\">        ArrayList&lt;String&gt; arrayList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(List.of(res));</span><br><span class=\"line\">        System.out.println(arrayList);</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;String&gt; stringStream1 = Stream.of(<span class=\"string\">&quot;gone&quot;</span>, <span class=\"string\">&quot;with&quot;</span>, <span class=\"string\">&quot;the&quot;</span>, <span class=\"string\">&quot;wind&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">LinkedList</span> <span class=\"variable\">linkedList</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;(stringStream1.toList());</span><br><span class=\"line\">        System.out.println(linkedList);</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;String&gt; stringStream2 = Stream.of(<span class=\"string\">&quot;gone&quot;</span>, <span class=\"string\">&quot;with&quot;</span>, <span class=\"string\">&quot;the&quot;</span>, <span class=\"string\">&quot;wind&quot;</span>);</span><br><span class=\"line\">        List&lt;String&gt; list = stringStream2.collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;String&gt; stringStream3 = Stream.of(<span class=\"string\">&quot;gone&quot;</span>, <span class=\"string\">&quot;with&quot;</span>, <span class=\"string\">&quot;the&quot;</span>, <span class=\"string\">&quot;wind&quot;</span>);</span><br><span class=\"line\">        Set&lt;String&gt; set = stringStream3.collect(Collectors.toSet());</span><br><span class=\"line\">        System.out.println(set);</span><br><span class=\"line\"></span><br><span class=\"line\">        Stream&lt;String&gt; stringStream4 = Stream.of(<span class=\"string\">&quot;gone&quot;</span>, <span class=\"string\">&quot;with&quot;</span>, <span class=\"string\">&quot;the&quot;</span>, <span class=\"string\">&quot;wind&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">TreeSet</span> <span class=\"variable\">treeSet</span> <span class=\"operator\">=</span> stringStream4.collect(Collectors.toCollection(TreeSet::<span class=\"keyword\">new</span>));</span><br><span class=\"line\">        System.out.println(treeSet);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//[gone, with, the, wind]</span></span><br><span class=\"line\">        <span class=\"comment\">//[gone, with, the, wind]</span></span><br><span class=\"line\">        <span class=\"comment\">//[gone, with, the, wind]</span></span><br><span class=\"line\">        <span class=\"comment\">//[the, with, gone, wind]</span></span><br><span class=\"line\">        <span class=\"comment\">//[gone, the, wind, with]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本类型流\">基本类型流<a title=\"#基本类型流\" href=\"#基本类型流\"></a></h3>\n<p>对于基本类型，可以使用其包装类创建流，如 Stream<Integer>。为了直接将基本类型值存储到流中而不需要进行包装，Stream类库提供了<code>IntStream、LongStream DoubleStream</code>类型，对 short、char、byte、boolean类型使用 IntStream类型，对 float使用DoubleStream类型</p>\n<p>当拥有一个对象流时，可以使用 mapToInt()、mapToLong()或mapToDouble() 方法将其转换成基本类型流.<br>\n<code>Stream&lt;String&gt; words = Stream.of(&quot;this&quot;,&quot;is&quot;,&quot;a&quot;,&quot;java&quot;,&quot;string&quot;);</code><br>\n<code>IntStream lengths = words.mapToInt(String::length);</code></p>\n<p>要将一个基本类型流转换成一个对象流，可以使用 boxed()方法。<br>\n<code>Stream&lt;Integer&gt; integers = IntStream.range(0,100).boxed();</code><br>\n基本类型流还定义了许多方法</p>\n<p>Random 类中提供了 ints()、longs()、doubles() 方法，它们返回包含随机数的基本类型流.</p>\n<h3 id=\"并行流\">并行流<a title=\"#并行流\" href=\"#并行流\"></a></h3>\n<p>可以并行执行多个线程, 流使得并行计算变得容易。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">fibonacci</span><span class=\"params\">(<span class=\"type\">long</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( n == <span class=\"number\">1</span> || n == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fibonacci(n-<span class=\"number\">1</span>) + fibonacci(n-<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; nums = Arrays.asList(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span> ,<span class=\"number\">40</span>, <span class=\"number\">41</span>, <span class=\"number\">42</span>, <span class=\"number\">43</span>);</span><br><span class=\"line\">        <span class=\"type\">Instant</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> Instant.now();</span><br><span class=\"line\">        nums.parallelStream().map(i-&gt;fibonacci(i)).forEach(System.out::println);</span><br><span class=\"line\">        <span class=\"type\">Instant</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> Instant.now();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;parallelStream period:  &quot;</span> + Duration.between(start, end).toMillis() + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        start = Instant.now();</span><br><span class=\"line\">        nums.stream().map(i-&gt;fibonacci(i)).forEach(System.out::println);</span><br><span class=\"line\">        end = Instant.now();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sequentialStream period:  &quot;</span> + Duration.between(start, end).toMillis() + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305171337039.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>从结果可以看到，使用并行流计算时间要比使用顺序流短。使用并行流时，输出也可能不是按顺序输出的。<br>\n然而，使用并行流并不是总能使程序运行得更快。对某些特定任务，在决定使用并行流之前应该测试并行流是否比顺序流更快。</p>\n<h2 id=\"知识点\">知识点<a title=\"#知识点\" href=\"#知识点\"></a></h2>\n<ol>\n<li>接口或者更普遍的抽象类, 不能直接实例化对象是应为其中的抽象方法需要实现, 有两种方法可以创建抽象类的对象, 第一种最常见的使用非抽象的子类上转型, 第二种用new初始化的时候给出匿名实现类(相当于给出抽象方法的实现).</li>\n</ol>\n<p><strong>参考</strong></p>\n<ol>\n<li>《Java程序设计(第3版)》 IBSN 9787302485520</li>\n<li><a href=\"https://docs.oracle.com/en/java/javase/19/docs/api/index.html\" target=\"_blank\">Java API 文档</a></li>\n</ol>\n","prev":{"title":"[IDEA]开启断言","link":"2023/05/17/[IDEA]开启断言"},"next":{"title":"[Notion]搭建个人电子图书馆","link":"2023/05/13/[Notion]搭建个人电子图书馆"},"plink":"https://s1acr.github.io/2023/05/17/[Java笔记]泛型&集合&Stream/","toc":[{"id":"泛型","title":"泛型","index":"1","children":[{"id":"泛型类型","title":"泛型类型","index":"1.1"},{"id":"通配符'？'","title":"通配符’？’","index":"1.2"},{"id":"有界类型参数","title":"有界类型参数","index":"1.3"},{"id":"类型擦除","title":"类型擦除","index":"1.4"}]},{"id":"集合框架","title":"集合框架","index":"2","children":[{"id":"基本操作","title":"基本操作","index":"2.1"},{"id":"批量操作","title":"批量操作","index":"2.2"},{"id":"数组操作","title":"数组操作","index":"2.3"},{"id":"流(stream)操作","title":"流(Stream)操作","index":"2.4"}]},{"id":"list-接口及实现类","title":"List 接口及实现类","index":"3","children":[{"id":"arraylist类","title":"ArrayList类","index":"3.1","children":[{"id":"使用迭代器","title":"使用迭代器","index":"3.1.1"},{"id":"双向迭代器","title":"双向迭代器","index":"3.1.2"},{"id":"数组转list对象","title":"数组转List对象","index":"3.1.3"}]},{"id":"vector-和-stack","title":"Vector 和 Stack","index":"3.2"}]},{"id":"set接口及其实现类","title":"Set接口及其实现类","index":"4","children":[{"id":"hashset-类","title":"HashSet 类","index":"4.1"},{"id":"用-set-对象实现集合运算","title":"用 Set 对象实现集合运算","index":"4.2"},{"id":"treeset-类","title":"TreeSet 类","index":"4.3","children":[{"id":"对象顺序","title":"对象顺序","index":"4.3.1"}]}]},{"id":"queue-接口及其实现类","title":"Queue 接口及其实现类","index":"5","children":[{"id":"queue-接口和-deque-接口","title":"Queue 接口和 Deque 接口","index":"5.1"},{"id":"arraydeque-类和-linkedlist-类","title":"ArrayDeque 类和 LinkedList 类","index":"5.2"}]},{"id":"集合转换","title":"集合转换","index":"6"},{"id":"map-接口及其实现类","title":"Map 接口及其实现类","index":"7","children":[{"id":"基本操作-1","title":"基本操作","index":"7.1"},{"id":"批量操作-1","title":"批量操作","index":"7.2"},{"id":"map-接口实现类","title":"Map 接口实现类","index":"7.3","children":[{"id":"hashmap-类","title":"HashMap 类","index":"7.3.1"},{"id":"treemap-类","title":"TreeMap 类","index":"7.3.2"},{"id":"hashtable-类和-enumeration-接口","title":"Hashtable 类和 Enumeration 接口","index":"7.3.3"}]}]},{"id":"collections-类","title":"Collections 类","index":"8"},{"id":"stream-api","title":"Stream API","index":"9","children":[{"id":"创建与获得流","title":"创建与获得流","index":"9.1"},{"id":"连接与限制流","title":"连接与限制流","index":"9.2"},{"id":"过滤流","title":"过滤流","index":"9.3"},{"id":"流转换","title":"流转换","index":"9.4"},{"id":"流规约","title":"流规约","index":"9.5"},{"id":"收集结果","title":"收集结果","index":"9.6"},{"id":"基本类型流","title":"基本类型流","index":"9.7"},{"id":"并行流","title":"并行流","index":"9.8"}]},{"id":"知识点","title":"知识点","index":"10"}],"reward":true,"copyright":{"author":"slacr_","license":"<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" target=\"_blank\"><img src = \"/lib/cc-by-nc-sa.svg\">CC BY-NC-ND 4.0</a>","published":"May 17, 2023","updated":"May 17, 2023"},"reading_time":"8212 words in 55 min"}