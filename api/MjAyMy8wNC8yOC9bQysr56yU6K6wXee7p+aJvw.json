{"title":"[C++笔记]继承","date":"2023-04-28T00:00:00.000Z","date_formatted":{"ll":"Apr 28, 2023","L":"04/28/2023","MM-DD":"04-28"},"link":"2023/04/28/[C++笔记]继承","comments":true,"categories":["C++"],"updated":"2023-04-28T00:00:00.000Z","content":"<h2 id=\"继承与派生\">继承与派生<a title=\"#继承与派生\" href=\"#继承与派生\"></a></h2>\n<h3 id=\"派生类生成过程\">派生类生成过程<a title=\"#派生类生成过程\" href=\"#派生类生成过程\"></a></h3>\n<p>吸收基类成员、改造基类成员、添加新的成员</p>\n<h3 id=\"访问控制\">访问控制<a title=\"#访问控制\" href=\"#访问控制\"></a></h3>\n<p>三种继承方式 public protected private<br>\n无论什么继承方式, 都无法访问基类private成员; public继承访问属性不变; private继承访问属性变private; protected继承访问属性变protected.</p>\n<h3 id=\"类型兼容规则\">类型兼容规则<a title=\"#类型兼容规则\" href=\"#类型兼容规则\"></a></h3>\n<p>类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。</p>\n<ul>\n<li>派生类的对象可以隐含转换为基类对象。</li>\n<li>派生类的对象可以初始化基类的引用。</li>\n<li>派生类的指针可以隐含转换为基类的指针。</li>\n</ul>\n<p>由于类型兼容规则的引入，对于基类及其公有派生类的对象，可以使用相同的函数统一进行处理。因为<code>当函数的形参为基类的对象(或引用、指针)时，实参可以是派生类的对象(或指针)</code> .而没有必要为每一个类设计单独的模块，大大提高了程序的效率。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GrandFather</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;GrandFather Say&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Father</span> : <span class=\"keyword\">public</span> GrandFather &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Father Say&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Son</span> : <span class=\"keyword\">public</span> Father &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Son Say&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">(GrandFather&amp; gf)</span> </span>&#123;</span><br><span class=\"line\">\tgf.<span class=\"built_in\">say</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tGrandFather gf;</span><br><span class=\"line\">\tFather f;</span><br><span class=\"line\">\tSon s;</span><br><span class=\"line\">\t<span class=\"built_in\">test</span>(gf);</span><br><span class=\"line\">\t<span class=\"built_in\">test</span>(f);</span><br><span class=\"line\">\t<span class=\"built_in\">test</span>(s);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304261729260.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>虽然发生了函数重写, 但通过这个基类型的引用(/指针/对象), 只能访问基类继承的成员.</p>\n<h3 id=\"继承中的构造析构\">继承中的构造析构<a title=\"#继承中的构造析构\" href=\"#继承中的构造析构\"></a></h3>\n<h4 id=\"继承中普通构造函数\">继承中普通构造函数<a title=\"#继承中普通构造函数\" href=\"#继承中普通构造函数\"></a></h4>\n<p>派生类继承了基类除自身构造析构函数之外的成员. 基类的构造函数并没有继承下来，要完成这些工作，就必须给派生类添加新的构造函数。派生类对于基类的很多成员对象是不能直接访问的，因此要完成对基类成员对象的初始化, 需要通过<code>调用基类的构造函数</code>。</p>\n<p>在构造派生类的对象时，会首先<code>调用基类的构造函数</code>，来初始化它们的数据成员，然后按照构造函<code>数初始化列表</code>中指定的方式初始化派生类新增的成员对象，最后才执行派生类构造函数的函数体。<br>\n当一个类同时有多个基类时，对于所有需要给予参数进行初始化的基类，都要显式给出基类名和参数表。对于使用默认构造函数的基类，可以不给出类名。</p>\n<p>派生类构造函数执行的一般次序如下。<br>\n(1)调用基类构造函数，调用顺序按照它们被继承时声明的顺序(从左向右)。<br>\n(2) 对派生类新增的成员对象初始化，调用顺序按照它们在类中声明的顺序。<br>\n(3) 执行派生类的构造函数体中的内容。</p>\n<p>构造函数初始化列表中基类名、对象名之间的次序无关紧要，它们各自出现的顺序可以是任意的，无论它们的顺序怎样安排，基类构造函数的调用和各个成员对象的初始化顺序都是确定的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base_1</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;\t\t\t\t<span class=\"comment\">// 有参</span></span><br><span class=\"line\">\t<span class=\"built_in\">Base_1</span>(<span class=\"type\">int</span> i) : <span class=\"built_in\">i</span>(i) &#123; cout &lt;&lt; <span class=\"string\">&quot;Base_1 Construct_&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base_2</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> j;\t\t\t\t<span class=\"comment\">// 有参</span></span><br><span class=\"line\">\t<span class=\"built_in\">Base_2</span>(<span class=\"type\">int</span> j) : <span class=\"built_in\">j</span>(j) &#123; cout &lt;&lt; <span class=\"string\">&quot;Base_2 Construct_&quot;</span> &lt;&lt; j &lt;&lt; endl; &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base_3</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:\t\t\t\t\t<span class=\"comment\">// 默认</span></span><br><span class=\"line\">\t<span class=\"built_in\">Base_3</span>()&#123; cout &lt;&lt; <span class=\"string\">&quot;Base_3 Construct_*&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base_3, <span class=\"keyword\">public</span> Base_2, <span class=\"keyword\">public</span> Base_1 &#123; <span class=\"comment\">// 继承顺序 </span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tBase_1 M_1;\t\t\t\t\t\t\t\t<span class=\"comment\">// 函数执行顺序</span></span><br><span class=\"line\">\tBase_2 M_2;</span><br><span class=\"line\">\t <span class=\"comment\">//Base_1::Base_1(int i) : i(i) &#123;&#125;;</span></span><br><span class=\"line\">\t<span class=\"built_in\">Derived</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c, <span class=\"type\">int</span> d) : <span class=\"built_in\">Base_1</span>(a), <span class=\"built_in\">Base_2</span>(b), <span class=\"built_in\">M_1</span>(c), <span class=\"built_in\">M_2</span>(d)&#123;  </span><br><span class=\"line\">\t\t<span class=\"comment\">// 初始化列表中对基类有参构造函数引用性声明, 并传递初始化值, 没有声明的基类构造函数则调用默认构造.</span></span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Derived Construct&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Derived <span class=\"title\">d</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304261909543.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"继承中拷贝构造函数\">继承中拷贝构造函数<a title=\"#继承中拷贝构造函数\" href=\"#继承中拷贝构造函数\"></a></h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"built_in\">B</span>(<span class=\"type\">int</span> x): <span class=\"built_in\">x</span>(x)&#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">B</span>(<span class=\"type\">const</span> B&amp; b) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;base copy&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;x = b.x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> : <span class=\"keyword\">public</span> B &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">\t<span class=\"built_in\">D</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y):<span class=\"built_in\">B</span>(x), <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">D</span>(<span class=\"type\">const</span> D&amp; d) : <span class=\"built_in\">B</span>(d) &#123;\t<span class=\"comment\">// 重写拷贝构造, 这里用到类型兼容, 基类要接受的是基类指针.</span></span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;derived copy&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;y = d.y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">class</span> D <span class=\"title\">D_1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">\tcout &lt;&lt; D_1.x &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; D_1.y &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">class</span> D <span class=\"title\">D_2</span><span class=\"params\">(D_1)</span></span>;   </span><br><span class=\"line\">\t<span class=\"comment\">// 默认调用派生类拷贝构造, 默认的拷贝构造是递归的, 会将派生类对象作为参数调用基类的拷贝构造</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"继承中析构函数\">继承中析构函数<a title=\"#继承中析构函数\" href=\"#继承中析构函数\"></a></h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"built_in\">B</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">x</span>(x) &#123;&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">B</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;base destruct&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> : <span class=\"keyword\">public</span> B &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">\t<span class=\"built_in\">D</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) :<span class=\"built_in\">B</span>(x), <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">D</span>()&#123; cout &lt;&lt; <span class=\"string\">&quot;derived destruct&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 派生类不继承基类析构函数</span></span><br><span class=\"line\">    <span class=\"comment\">// 编译器会自动生成一个默认析构</span></span><br><span class=\"line\">\t<span class=\"comment\">// 派生类析构函数中没写也隐含调用基类析构函数, 析构与构造顺序相反. </span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">class</span> D <span class=\"title\">D_1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"虚继承与虚基类\">虚继承与虚基类<a title=\"#虚继承与虚基类\" href=\"#虚继承与虚基类\"></a></h3>\n<p>当某类的部分或全部直接基类是从另一个共同基类派生而来时，在这些直接基类中从上一级共同基类继承来的成员就拥有相同的名称。在派生类的对象中，这些同名数据成员在内存中同时拥有多个副本，同一个函数名会有多个映射。可以使用作用域分辨符来唯一标识并分别访问它们，也可以将<code>共同基类设置为虚基类</code>，这时从<code>不同的路径继承过来的同名数据成员在内存中就只有一个副本，同一个函数名也只有一个映射</code>。这样就解决了同名成员的唯一标识问题。<br>\n虚基类的声明是在派生类的定义过程中进行的.<br>\n声明基类为派生类的虚基类。在多继承情况下，<code>虚基类关键字的作用范围和继承方式关键字相同，只对紧跟其后的基类起作用</code>。声明了虚基类之后，虚基类的成员在进一步派生过程中和派生类一起维护同一个内存数据副本。</p>\n<p>虚继承解决了复杂继承关系中多个重复含义的成员的问题.</p>\n<p>比如这个例子:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"built_in\">Base</span>() :<span class=\"built_in\">x</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">Base</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">x</span>(x) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base_1</span> : <span class=\"keyword\">public</span>  Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">\t<span class=\"built_in\">Base_1</span>() :<span class=\"built_in\">y</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">Base_1</span>(<span class=\"type\">int</span> y) : <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base_2</span> :  <span class=\"keyword\">public</span>  Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">\t<span class=\"built_in\">Base_2</span>() :<span class=\"built_in\">y</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">Base_2</span>(<span class=\"type\">int</span> y) : <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base_1, <span class=\"keyword\">public</span> Base_2 &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> z;</span><br><span class=\"line\">\t<span class=\"built_in\">Derived</span>(<span class=\"type\">int</span> z) : <span class=\"built_in\">z</span>(z) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Derived <span class=\"title\">d</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>类图:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304271836108.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304272133158.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304271838733.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>Derived中含有两个不同的x 和 y</p>\n<p>将Base_1 Base_2 改成虚继承.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base_1</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span>  Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">\t<span class=\"built_in\">Base_1</span>() :<span class=\"built_in\">y</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">Base_1</span>(<span class=\"type\">int</span> y) : <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base_2</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span>  Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304272132282.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304272125429.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>类中多了一个虚基类的成员. 发生虚继承的子类中成员多了一个四个字节的<code>虚基类表指针vbptr</code>.vbptr指向<code>该作用域下的虚基类表vbtable</code>.虚基类表中记录了该类中虚基类成员的偏置值. 由该<code>偏置值就可以获取唯一的虚基类成员</code>. 虚函数地址表由编译器为每个类建立.</p>\n<p>vbi是一个该类中<code>虚基类信息表指针</code>, 指向<code>虚基类信息表</code>, 虚基类信息表中记录了虚基类的一些信息, 比如class和offset偏置值.</p>\n<p>分析虚继承发生了什么:<br>\n将基类的成员的吸收形式改为<code>一个虚基类表指针</code>和一<code>将基类的成员开辟在派生类后面</code>, 这个虚基类指针指向了一个虚基类表. 虚基类表中的每个继承的成员偏置值可以按照此时相对位置填充.<br>\n当Derived同时公共继承Base_1和Base_2时, 还是将其成员全部吸收,新增本类成员, 将虚基类成员开辟在本类后, 相同的基类成员在虚基类中只会出现一次, 然后更新虚基类表指针与虚基类表.</p>\n<p>复杂点, 试试把Derived也设置成虚继承.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Base_1, <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Base_2 &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> z;</span><br><span class=\"line\">\t<span class=\"built_in\">Derived</span>(<span class=\"type\">int</span> z) : <span class=\"built_in\">z</span>(z) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304272214166.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304272222983.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>可以看到, Base_1, Base_2 都变成了虚基类, 本类中多了一个<code>虚基类指针vbptr</code>, 用来记录从Base_1, Base_2中虚继承下来的成员. 指向的虚基类表记录了三个虚基类的偏置值. 虚基类Base_1中 又记录了他的虚基类Base的的vbptr.<br>\nBase现在既是Derived的虚基类, 也是Base的虚基类Base_1的虚基类.</p>\n<p>x的地址还是唯一的在虚基类base中, 当我们访问x时会在本类寻找, 本类没有在利用虚函数指针在虚基类表中寻找虚基类的地址偏置值, 再在虚基类中寻找. 虚基类中基类成员是唯一的.</p>\n<p><code>虚继承的目的是为了解决多继承(网状), 出现继承同一个类的多个相同成员副本的问题</code>. 单继承(树状)则不会产生这样的问题. 这样做并不会影响程序的执行, 但本例中没有必要. 除非呈现下图类似的网状关系.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304280151853.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><code>构造一个类的对象的一般顺序</code>:<br>\n(1) 如果该类有直接或间接的虚基类，则先执行虚基类的构造函数。<br>\n(2) 如果该类有其他基类，则按照它们在继承声明列表中出现的次序，分别执行它们<br>\n的构造函数，但构造过程中，不再执行它们的虚基类的构造函数。<br>\n(3) 按照在类定义中出现的顺序，对派生类中新增的成员对象进行初始化。对于类<br>\n类型的成员对象，如果出现在构造函数初始化列表中，则以其中指定的参数执行构造函<br>\n数，如未出现，则执行默认构造函数;对于基本数据类型的成员对象，如果出现在构造函数<br>\n的初始化列表中，则使用其中指定的值为其赋初值，否则什么也不做。<br>\n(4) 执行构造函数的函数体。</p>\n<h3 id=\"派生类对象的内存布局\">派生类对象的内存布局<a title=\"#派生类对象的内存布局\" href=\"#派生类对象的内存布局\"></a></h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> a, b, c;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> d, e, f;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y, z;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tDerived d;</span><br><span class=\"line\">\tDerived* ptr_derived = &amp;d; </span><br><span class=\"line\">\tBase* ptr_base = &amp;d;</span><br><span class=\"line\">\t<span class=\"comment\">// 基类指针接收派生类对象, 只需使基类指针定向到派生类中该基类的首地址,  由于基类指针的偏置量确定, 故无法访问派生类的成员.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指针类型转换时不止是复制地址</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304282105272.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"知识点\">知识点<a title=\"#知识点\" href=\"#知识点\"></a></h2>\n<ol>\n<li>派生类成按访问属性可分为: 不可访问成员, 私有成员, 保护成员, 共有成员.</li>\n<li>如果某派生类的多个基类拥有同名的成员，同时，派生类又新增这样的同名成员，在这种情况下，派生类成员将隐藏所有基类的同名成员。只有在相同的作用域中定义的函数才可以重载。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;from base&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">using</span> Base::test;    <span class=\"comment\">// 或者用using 关键词在当前作用域下声明  using 将一个作用域中的名字引入到另一个作用域中</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;from derived&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tDerived d;</span><br><span class=\"line\">\t<span class=\"comment\">// d.test(1, 1);   // 既使参数表不同, 符合重载的形式, 但作用域的关系, 派生类只要存在同名成员, 基类的同名成员就是不可见的, 只有在相同的作用域中定义的函数才可以重载。</span></span><br><span class=\"line\">\td.Base::<span class=\"built_in\">test</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>); <span class=\"comment\">// 加作用域以区分</span></span><br><span class=\"line\">\td.<span class=\"built_in\">test</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);\t\t<span class=\"comment\">// 使用using关键词后可以调用</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>多继承会出现一种菱形继承的情况, 产生的派生类中存在同级作用域下的同名成员, 此时必须用直接基类的类作用域加以区分.</li>\n<li>void 指针可以指向任何类型的对象，因此 void 类型指针和具体类型的指针具有一般与特殊的关系;基类指针可以指向任何派生类的对象，因此基类指针和派生类指针也具有一般和特殊的关系。从特殊的指针转换到一般的指针是安全的，因此允许隐含转换;从一般的指针转换到特殊的指针是不安全的，因此只能显式地转换。</li>\n<li>而从派生类对象到基类对象的转换之所以能够执行，是因为基类对象的复制构造函数接收一个基类引用的参数，而用派生类对象是可以给基类引用初始化的，因此基类的复制构造函数可以被调用，转换就能够发生。</li>\n</ol>\n<p><strong>参考</strong></p>\n<ol>\n<li>《C++语言程序设计（第4版）》 IBSN 9787302227984</li>\n<li><a href=\"https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5\" target=\"_blank\">C++参考手册</a></li>\n<li><a href=\"https://learn.microsoft.com/zh-cn/cpp/standard-library/iomanip?view=msvc-170\" target=\"_blank\">Microsoft C++文档</a></li>\n</ol>\n","prev":{"title":"[C++笔记]群体类和群体数据的组织一","link":"2023/04/29/[C++笔记]群体类和群体数据的组织一"},"next":{"title":"[VS]使用开发人员PowerShell查看类信息","link":"2023/04/27/[VS]使用开发人员PowerShell查看类信息"},"plink":"https://s1acr.github.io/2023/04/28/[C++笔记]继承/","toc":[{"id":"继承与派生","title":"继承与派生","index":"1","children":[{"id":"派生类生成过程","title":"派生类生成过程","index":"1.1"},{"id":"访问控制","title":"访问控制","index":"1.2"},{"id":"类型兼容规则","title":"类型兼容规则","index":"1.3"},{"id":"继承中的构造析构","title":"继承中的构造析构","index":"1.4","children":[{"id":"继承中普通构造函数","title":"继承中普通构造函数","index":"1.4.1"},{"id":"继承中拷贝构造函数","title":"继承中拷贝构造函数","index":"1.4.2"}]},{"id":"继承中析构函数","title":"继承中析构函数","index":"1.5"},{"id":"虚继承与虚基类","title":"虚继承与虚基类","index":"1.6"},{"id":"派生类对象的内存布局","title":"派生类对象的内存布局","index":"1.7"}]},{"id":"知识点","title":"知识点","index":"2"}],"reward":true,"copyright":{"author":"slacr_","license":"<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" target=\"_blank\"><img src = \"/lib/cc-by-nc-sa.svg\">CC BY-NC-ND 4.0</a>","published":"April 28, 2023","updated":"April 28, 2023"},"reading_time":"3600 words in 24 min"}