{"title":"[Java笔记]常用核心类内部类枚举注解","date":"2023-05-09T00:00:00.000Z","date_formatted":{"ll":"May 9, 2023","L":"05/09/2023","MM-DD":"05-09"},"link":"2023/05/09/[Java笔记]常用核心类内部类枚举注解","comments":true,"categories":["Java"],"updated":"2023-05-09T00:00:00.000Z","content":"<blockquote>\n<p>Java 笔记</p>\n</blockquote>\n<h2 id=\"object\">Object<a title=\"#object\" href=\"#object\"></a></h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305092218740.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><code>toString()</code><br>\n调用对象的 toString()方法可以返回对象的字符串表示toCast. 该方法在Object类中的定义是返回包名.类名@一个十六进制整数. 如 Father@4f3f5b24. 输出函数传入类的实例默认调用. Java 类库中，有许多类覆盖了 toString()方法，输出时能够得到可理解的结果.</p>\n<p><code>equals()</code><br>\n比较两个对象是否相等, 比较的是对象的引用. 在Java类库中的许多类也覆盖了该方法，如String类。因此，对String对象使用equals()方法的比较是字符串的内容是否相等。<br>\n在子类中，使用签名equals(ClassName obj)覆盖 equals()方法是一个常见的错误，应该使用 equals (Object obj) 覆盖 equals()方法.</p>\n<p><code>hashCode()</code><br>\nhashCode()方法返回一个对象的哈希码 (hash code) 值，它是一个整数，主要用来比较对象的大小。在Object类中hashCode()方法的实现是返回对象在计算机内部存储的十进制内存地址.<br>\nhashCode()方法和 equals()方法必须是兼容的，如果你为一个类覆盖了equals()方法，则也需要覆盖hashCode()方法，以兼容equals()方法<br>\njava.util.Objects类的 hash()方法的参数是可变参数，该方法计算每个参数的哈希码，并将它们组合起来。这个方法是空指针安全的。<br>\n如果类包含数组类型的实例变量，比较它们的哈希码时，首先使用静态方法Arrays.hashCode()计算数组的每个元素哈希码组成的哈希码，然后将结果传给 Objects 的hash()方法.</p>\n<p><code>clone()</code><br>\n使用 Object类的 clone()方法可以克隆一个对象，即创建一个对象的副本。要使类的对象能够克隆，类必须实现Cloneable接口.<br>\n使用 Object类继承的 clone()方法克隆对象只是做了浅拷贝。它简单地从原对象中复制所有实例变量到目标对象中。如果实例变量是基本类型或不变对象(如String), 将没有问题；否则，原对象和克隆对象将共享可变的状态。</p>\n<p><code>finalize()</code><br>\n每个对象都有一个 finalize()方法。在对象被销毁之前，<code>垃圾回收器允许对象调用该方法进行清理工作，这个过程称为对象终结 (finalization)</code>。 格式为 <code>protected void finalize() throws Throwable</code></p>\n<h2 id=\"math\">Math<a title=\"#math\" href=\"#math\"></a></h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305101332456.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"基本类型包装类\">基本类型包装类<a title=\"#基本类型包装类\" href=\"#基本类型包装类\"></a></h2>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202305101341697.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"character\">Character<a title=\"#character\" href=\"#character\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Character</span> <span class=\"variable\">c_1</span> <span class=\"operator\">=</span> (<span class=\"string\">&#x27;A&#x27;</span>);</span><br><span class=\"line\">        <span class=\"type\">Character</span> <span class=\"variable\">c_2</span> <span class=\"operator\">=</span> (<span class=\"string\">&#x27;$&#x27;</span>);</span><br><span class=\"line\">        <span class=\"type\">Character</span> <span class=\"variable\">c_3</span> <span class=\"operator\">=</span> (<span class=\"string\">&#x27;简&#x27;</span>);</span><br><span class=\"line\">        System.out.println(c_1.compareTo(<span class=\"string\">&#x27;D&#x27;</span>));  <span class=\"comment\">// -3</span></span><br><span class=\"line\">        System.out.println(c_2.charValue());       <span class=\"comment\">// $</span></span><br><span class=\"line\">        System.out.println(c_3.isLetter(<span class=\"string\">&#x27;简&#x27;</span>));  <span class=\"comment\">// true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>常用方法:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>public char charValue() </code></td>\n<td style=\"text-align:left\">返回 Character 对象所包含的 char值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public int compareTo(Character anotherChar) </code></td>\n<td style=\"text-align:left\">比较两个字符对象。如果该字符对象与参数字符对象相等，返回0;若小于参数字符，返回值小于0;若大于参数字符，则返回值大于0。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static boolean isDigit(char ch)</code></td>\n<td style=\"text-align:left\">返回参数字符是否是数字。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static boolean isLetter(char ch)</code></td>\n<td style=\"text-align:left\">返回参数字符是否是字母。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static boolean isLowerCase(char ch)</code></td>\n<td style=\"text-align:left\">返回参数字符是否是小写字母。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static boolean isUpperCase(char ch)</code></td>\n<td style=\"text-align:left\">返回参数字符是否是大写字母。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static boolean isWhiteSpace(char ch)</code></td>\n<td style=\"text-align:left\">返回参数字符是否是空白字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static char toLowerCase(char ch)</code></td>\n<td style=\"text-align:left\">将参数字符转换为小写字母返回。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static char toUpperCase(char ch)</code></td>\n<td style=\"text-align:left\">将参数字符转换为大写字母返回。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static boolean isJavaIdentifierStart(char ch) </code></td>\n<td style=\"text-align:left\">返回参数字符是否允许作为 Java标识符的开头字符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static boolean isJavaldentifierPart (char ch) </code></td>\n<td style=\"text-align:left\">返回参数字符是否允许作为 Java标识符的中间字符。</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"boolean\">Boolean<a title=\"#boolean\" href=\"#boolean\"></a></h3>\n<p>常用方法:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>public Boolean(boolean value)</code></td>\n<td style=\"text-align:left\">用一个boolean型值创建一个Boolean对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public Boolean(String s)</code></td>\n<td style=\"text-align:left\">用一个字符串创建Boolean对象。如果字符串 s不为 null 且其值为 “true”(不区分大小写)就创建一个true值，否则创建一个 false值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public boolean booleanValue()</code></td>\n<td style=\"text-align:left\">返回该Boolean 对象所封装的 boolean值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static boolean parseBoolean(String s)</code></td>\n<td style=\"text-align:left\">将参数s解析为一个 boolean 值。如果参数不为 null 且等于 “true”(不区分大小写),则返回true, 否则返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static Boolean valueOf(boolean b)</code></td>\n<td style=\"text-align:left\">将参数b 的值转换为 Boolean 对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static Boolean valueOf(String s)</code></td>\n<td style=\"text-align:left\">将参数s 的值转换为 Boolean对象。</td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">Boolean</span> <span class=\"variable\">b_1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(b);               <span class=\"comment\">// false</span></span><br><span class=\"line\">        <span class=\"type\">Boolean</span> <span class=\"variable\">b_2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"string\">&quot;TruE&quot;</span>);      <span class=\"comment\">// true , 这两个方法已经不支持, 将要移除</span></span><br><span class=\"line\">        System.out.println(b_1);</span><br><span class=\"line\">        System.out.println(b_2);</span><br><span class=\"line\">        System.out.println(b_1.booleanValue());  <span class=\"comment\">// false</span></span><br><span class=\"line\">        System.out.println(Boolean.parseBoolean(<span class=\"string\">&quot;True&quot;</span>));     <span class=\"comment\">// true</span></span><br><span class=\"line\">        System.out.println(Boolean.valueOf(b).booleanValue());   <span class=\"comment\">// false</span></span><br><span class=\"line\">        System.out.println(Boolean.valueOf(<span class=\"string\">&quot;OK&quot;</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数值类对象\">数值类对象<a title=\"#数值类对象\" href=\"#数值类对象\"></a></h3>\n<p>常用方法:</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>public Integer(int value) </code></td>\n<td style=\"text-align:left\">使用 int类型的值创建包装类型 Integer对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public Integer(String s) </code></td>\n<td style=\"text-align:left\">使用字符串构造Integer对象，如果字符串不能转换成相应的数值，则抛出NumberFormatException异常</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static String toBinaryString(int i)</code></td>\n<td style=\"text-align:left\">返回整数i用字符串表示的二进制序列。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static String toHexString(int i) </code></td>\n<td style=\"text-align:left\">返回整数i用字符串表示的十六进制序列。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static String toOctalString(int i) </code></td>\n<td style=\"text-align:left\">返回整数 i用字符串表示的八进制序列。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static int highestOneBit(int i) </code></td>\n<td style=\"text-align:left\">返回整数i的二进制补码的最高位1所表示的十进制数，如7(111)的最高位的1表示的值为4。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static int lowestOneBit(int i)</code></td>\n<td style=\"text-align:left\">返回整数 i的二进制补码的最低位1所表示的十进制数，如10(1010)的最低位的1表示的值为2。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static int reverse(int i) </code></td>\n<td style=\"text-align:left\">返回将整数i的二进制序列反转后的整数值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static int signum(inti)</code></td>\n<td style=\"text-align:left\">返回整数i的符号。若 i大于0,返回1;若 i等于0,</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">返回0,若 i小于0则返回-1。</td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table></div></div><p>每种包装类型都覆盖了toString()方法和 equals()方法，因此使用 equals()方法比较包装类型的对象时是比较内容或所包装值.每种包装类型的对象中所包装的值是不可改变的，要改变对象中的值必须重新生成新的对象.</p>\n<p>每个数值包装类都定义了 <code>SIZE、BYTES、MAX_VALUE、MIN_VALUE </code>常量。<br>\nSIZE 表示每种类型的数据所占的位数<br>\nBYTES 表示数据所占的字节数<br>\nMAX_VALUE 表示对应基本类型数据的最大值.<br>\n对于Byte、Short、Integer和Long 来说，MIN_VALUE 表示类型的最小值。对 Float和 Double 来说，MIN_VALUE 最小正值。<br>\n除了上面的常量外，在 Float 和 Double 类中还分别定义了 POSITIVE_INFINITY、NEGATIVE INFINITY、NaN(not a number), 它们分别表示正、负无穷大和非数值。</p>\n<h3 id=\"自动装箱与自动拆箱\">自动装箱与自动拆箱<a title=\"#自动装箱与自动拆箱\" href=\"#自动装箱与自动拆箱\"></a></h3>\n<p>Java 5 版提供了一种新的功能，称为自动装箱和自动拆箱。自动装箱 (autoboxing) 是指基本类型的数据可以自动转换为包装类的实例，自动拆箱 (unboxing) 是指包装类的实例自动转换为基本类型的数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">300</span>;   <span class=\"comment\">// auto boxing</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i_1</span> <span class=\"operator\">=</span> i;        <span class=\"comment\">// auto unboxing</span></span><br><span class=\"line\">        System.out.println(((Integer)i_1).toString()); <span class=\"comment\">// 强制转换</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串与基本数据类型转化\">字符串与基本数据类型转化<a title=\"#字符串与基本数据类型转化\" href=\"#字符串与基本数据类型转化\"></a></h3>\n<p><code>public static Type parse&#123;Type&#125;(String s)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">        System.out.println(Integer.parseInt(s));  <span class=\"comment\">// 字符串转基本类型</span></span><br><span class=\"line\">        System.out.println(Double.parseDouble(s));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">        System.out.println(String.valueOf(i) <span class=\"keyword\">instanceof</span>  String); <span class=\"comment\">// 基本类型转字符串</span></span><br><span class=\"line\">        System.out.println(((Integer)i).toString());   <span class=\"comment\">// 或者通过包装类的toString()方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"biginteger-bigdecimal\">BigInteger BigDecimal<a title=\"#biginteger-bigdecimal\" href=\"#biginteger-bigdecimal\"></a></h2>\n<p>如果在计算中需要非常大的整数或非常高精度的浮点数，可以使用java.math 包中定义的BigInteger类和 BigDecimal类。这两个类都扩展了Number类并实现了Comparable 接口，它们的实例都是不可变的.</p>\n<p><a href=\"https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/math/BigInteger.html\" target=\"_blank\">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/math/BigInteger.html</a></p>\n<h2 id=\"时间日期api\">时间日期API<a title=\"#时间日期api\" href=\"#时间日期api\"></a></h2>\n<p>java.time<br>\n<a href=\"https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/time/package-summary.html\" target=\"_blank\">https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/time/package-summary.html</a></p>\n<h2 id=\"内部类\">内部类<a title=\"#内部类\" href=\"#内部类\"></a></h2>\n<p>Java 语言允许在一个类的内部定义另一个类(接口、枚举或注解),这种类称为内部类 (inner class)或嵌套类 (nested class)<br>\n使用内部类的优点：对只在一处使用的类进行分组；提高封装性；增强代码的可读性和可维护性。<br>\n有多种类型的内部类，大致可分为<code>成员内部类、局部内部类、匿名内部类和静态内部类</code>。</p>\n<h3 id=\"内部成员类\">内部成员类<a title=\"#内部成员类\" href=\"#内部成员类\"></a></h3>\n<p>成员内部类没有用 static修饰且定义在外层类的类体中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OuterClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InnerClass</span> &#123;   <span class=\"comment\">// 内部类相当于成员, 可以访问外部内所有成员</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">OuterClass</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OuterClass</span>();</span><br><span class=\"line\">        OuterClass.<span class=\"type\">InnerClass</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> o.<span class=\"keyword\">new</span> <span class=\"title class_\">InnerClass</span>();   <span class=\"comment\">// 创建内部类</span></span><br><span class=\"line\"></span><br><span class=\"line\">        OuterClass.<span class=\"type\">InnerClass</span> <span class=\"variable\">ii</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OuterClass</span>().<span class=\"keyword\">new</span> <span class=\"title class_\">InnerClass</span>();  <span class=\"comment\">// 或者</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(ii.add()); <span class=\"comment\">// 3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用成员内部类时需要注意下面几个问题：</p>\n<ol>\n<li>成员内部类中不能定义 static变量和 static方法。</li>\n<li>成员内部类也可以使用 abstract和 final修饰，其含义与其他类一样。</li>\n<li>成员内部类还可以使用 private、public、protected或包可访问修饰符。</li>\n</ol>\n<h3 id=\"局部内部类\">局部内部类<a title=\"#局部内部类\" href=\"#局部内部类\"></a></h3>\n<p>可以在方法体或语句块内定义类。在方法体或语句块 (包括方法、构造方法、局部块、初始化块或静态初始化块)内部定义的类称为局部内部类 (local inner class)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OuterClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">makeInner</span><span class=\"params\">(<span class=\"type\">int</span> p)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;local_variable&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">class</span> <span class=\"title class_\">InnerClass</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">seekOuter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(x);</span><br><span class=\"line\">                System.out.println(s);</span><br><span class=\"line\">                System.out.println(p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;       <span class=\"comment\">// 此局部类只在这个函数中有效</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">InnerClass</span>().seekOuter();       <span class=\"comment\">// 创建对象调用方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">OuterClass</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OuterClass</span>();</span><br><span class=\"line\">        o.makeInner(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">//1</span></span><br><span class=\"line\">        <span class=\"comment\">//local_variable</span></span><br><span class=\"line\">        <span class=\"comment\">//2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"匿名内部类\">匿名内部类<a title=\"#匿名内部类\" href=\"#匿名内部类\"></a></h3>\n<p>定义类最终目的是创建一个类的实例，但如果某个类的实例只使用一次，可以将类的定义和实例的创建在一起完成，或者说在定义类的同时就创建一个实例。以这种方式定义的没有名字的类称为匿名内部类 (anonymous inner class)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;slacr&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> String <span class=\"title function_\">work</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OuterClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 匿名对象继承 Person, 初始化同时定义</span></span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">hero</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> String <span class=\"title function_\">work</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"string\">&quot;punish evil-doers&quot;</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hero &quot;</span> + hero.name + <span class=\"string\">&quot;, I will &quot;</span> + hero.work());</span><br><span class=\"line\">        <span class=\"comment\">// Hero slacr, I will punish evil-doers</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>匿名内部类可以继承一个类或实现一个接口, 如果实现一个接口，该类是Object类的直接子类。匿名类继承一个类或<br>\n实现一个接口不需要使用 extends 或 implements 关键字。匿名内部类不能同时继承一个类和实现一个接口，也不能实现多个接口<br>\n匿名内部类的一个重要应用是编写 JavaFX 图形界面的事件处理程序。如为按钮对象button 注册事件处理器，就可以使用匿名内部类。</p>\n<h3 id=\"静态内部类\">静态内部类<a title=\"#静态内部类\" href=\"#静态内部类\"></a></h3>\n<p>静态内部类使用 static修饰，静态内部类也称嵌套类 (nested class)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OuterClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">OuterClass</span>().getClass().getSimpleName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">static</span>  <span class=\"keyword\">class</span> <span class=\"title class_\">InnerClass</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            outer();</span><br><span class=\"line\">            System.out.println(x);      <span class=\"comment\">// 可以访问外部静态成员方法和变量</span></span><br><span class=\"line\">            System.out.println(y);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        OuterClass.<span class=\"type\">InnerClass</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OuterClass</span>.InnerClass();</span><br><span class=\"line\">        <span class=\"comment\">// 不需要外层实例就可以直接创建一个静态内部实例</span></span><br><span class=\"line\">        i.test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"枚举类型\">枚举类型<a title=\"#枚举类型\" href=\"#枚举类型\"></a></h2>\n<p>枚举类型是一种特殊的引用类型，它的声明和使用与类和接口有类似的地方。它可以作为顶层的类型声明，也可以像内部类一样在其他类的内部声明，但不能在方法内部声明枚举。</p>\n<p>任何枚举类型都隐含地继承了java.lang.Enum抽象类，Enum类又是Object类的子类，同时实现了 Comparable 接口和 Serializable接口。每个枚举类型都包含了若干方法，下面是一些常用的</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"padding:0\"></th>\n<th style=\"padding:0\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>public static E[] values()</code></td>\n<td style=\"text-align:left\">返回一个包含所有枚举常量的数组，这些枚举常量在数组中是按照它们的声明顺序存储的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public static E valueOf(String name)</code></td>\n<td style=\"text-align:left\">返回指定名字的枚举常量。如果这个名字与任何一个枚举常量的名字都不能精确匹配，将抛出 IlegalArgumentException 异常。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public final int compareTo(Eo)</code></td>\n<td style=\"text-align:left\">返回当前枚举对象与参数枚举对象的比较结果。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public final Class&lt;E&gt; getDeclaringClass()</code></td>\n<td style=\"text-align:left\">返回对应该枚举常量的枚举类型的类对象。两个枚举常量 el、e2, 当且仅当 el.getDeclaringClass() == e2.getDeclaringClass()时，这两个枚举常量类型相同。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public final String name()</code></td>\n<td style=\"text-align:left\">返回枚举常量名。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public final int ordinal()</code></td>\n<td style=\"text-align:left\">返回枚举常量的顺序值，该值是基于常量声明的顺序的，第一个常量的顺序值是0,第二个常量的顺序值为1,依次类推。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>public String toString()</code></td>\n<td style=\"text-align:left\">返回枚举常量名。</td>\n</tr>\n</tbody>\n</table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Direction</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> Direction.W;</span><br><span class=\"line\">        System.out.println(left);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( Direction d : Direction.values()) &#123;    <span class=\"comment\">// values() 是一个包含枚举常量的数组</span></span><br><span class=\"line\">            System.out.println(d.name() + <span class=\"string\">&quot; &quot;</span> + d.ordinal());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// enum 配合 Switch</span></span><br><span class=\"line\">        <span class=\"type\">Direction</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> Direction.values()[(<span class=\"type\">int</span>)(Math.random()*<span class=\"number\">4</span>)];</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (d) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> E -&gt; System.out.println(<span class=\"string\">&quot;EAST&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> S -&gt; System.out.println(<span class=\"string\">&quot;SOUTH&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> W -&gt; System.out.println(<span class=\"string\">&quot;WEST&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> N -&gt; System.out.println(<span class=\"string\">&quot;NORTH&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">default</span> -&gt; System.out.println(<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Color</span> &#123;</span><br><span class=\"line\">   R(<span class=\"string\">&quot;RED&quot;</span>, <span class=\"number\">1</span>), G(<span class=\"string\">&quot;GREEN&quot;</span>, <span class=\"number\">2</span>) , B(<span class=\"string\">&quot;BLUE&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">   <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">int</span> idx;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"title function_\">Color</span><span class=\"params\">(String name, <span class=\"type\">int</span> idx)</span> &#123; <span class=\"comment\">// 构造方法只能 private, 通过枚举具体的类型创建</span></span><br><span class=\"line\">       <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">       <span class=\"built_in\">this</span>.idx = idx;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">getName</span><span class=\"params\">(<span class=\"type\">int</span> idx)</span> &#123;  </span><br><span class=\"line\">       <span class=\"keyword\">for</span> (Color c : Color.values())&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(c.idx ==idx ) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> c.name;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> idx + <span class=\"string\">&quot; &quot;</span> + name;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Color</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Color.G;    <span class=\"comment\">// 自动调用构造</span></span><br><span class=\"line\">        System.out.println(c.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"注解类型\">注解类型<a title=\"#注解类型\" href=\"#注解类型\"></a></h2>\n<p>注解类型 (annotation type) 是 Java 5 新增的功能。注解以结构化的方式为程序元素提供信息，这些信息能够被外部工具(编译器、解释器等)自动处理.<br>\n注解有许多用途，其中包括：</p>\n<ol>\n<li>为编译器提供信息。编译器可以使用注解检测错误或阻止编译警告。</li>\n<li>编译时或部署时处理。软件工具可以处理注解信息生成代码、 XML 文件等。</li>\n<li>运行时处理。有些注解在运行时可以被检查。<br>\n像使用类一样，要使用注解必须先定义注解类型(也可以使用语言本身提供的注解)</li>\n</ol>\n<p><code>注解 (annotation)和注解类型 (annotation type)</code>。注解类型是一种特殊的接口类型，注解是注解类型的一个实例。就像接口一样，注解类型也有名称和成员。注解中包含的信息采用“键/值”对的形式，可以有零或多个“键/值”对，并且每个键有一个特定类型。没有“键/值”对的注解类型称作<code>标记注解类(marker annotation type)</code>。如果注解只需要一个“键/值”对，则称为<code>单值注解类型</code>。</p>\n<h3 id=\"标准注解\">标准注解<a title=\"#标准注解\" href=\"#标准注解\"></a></h3>\n<p>Java语言规范中定义了3个注解类型，它们是供编译器使用的。这3个注解类型定义在java.lang包中，分别为<code>@Override、@Deprecated 和 @SuppressWarnings</code>。</p>\n<p><code>Override</code> :<br>\n是一个标记注解类型, 告诉编译器此方法要覆盖父类方法.</p>\n<p><code>Deprecate</code>:<br>\n是一个标记注解类型，可以应用于某个方法或某个类型，指明方法或类型已被弃用。标记已被弃用的方法或类型，是为了警告其代码用户，不应该使用或覆盖该方法，或不该使用或扩展该类型。一个方法或类型被标记弃用通常是因为有了更好的方法或类型。当前的软件版本中保留这个被弃用的方法或类型是为了向后兼容。</p>\n<p><code>SuppressWarnings</code>:<br>\n注解指示编译器阻止某些类型的警告，具体的警告类型可以用初始化该注解的字符串来定义。该注解可应用于类型、构造方法、方法、成员变量、参数以及局部变量。它的用法是传递一个 String数组，其中包含需要阻止的警告。</p>\n<p>常用有效参数:</p>\n<ul>\n<li><code>unchecked  </code>  未检查的转换警告。</li>\n<li><code>deprecation</code> 使用了不推荐使用方法的警告。</li>\n<li><code>serial     </code> 实现 Serializable 接口但没有定义 serialVersionUID 常量的警告。</li>\n<li><code>rawtypes   </code> 如果使用旧的语法创建泛型类对象时发出的警告。</li>\n<li><code>finally    </code>  任何 finally子句不能正常完成的警告。</li>\n<li><code>fallthrough</code>    switch块中某个 case 后没有 break 语句的警告。</li>\n</ul>\n<h3 id=\"标准元注解\">标准元注解<a title=\"#标准元注解\" href=\"#标准元注解\"></a></h3>\n<p>元注解 (meta annotation) 是对注解进行标注的注解。在java.lang.annotation包中定义Documented、Inherited、Retention 和 Target 四个元注解类型。</p>\n<ol>\n<li><code>Documented</code><br>\nDocumented是一种标记注解类型，用于对一个注解类型的声明进行标注，使该注解类型的实例包含在用javadoc 工具产生的文档中。</li>\n<li><code>Inherited</code><br>\n用 Inherited标注的注解类型的任何实例都会被继承。如果 Inherited标注一个类，那么注解将会被这个被标注类的所有子类继承。</li>\n<li><code>Retension</code><br>\nRetension 注解指明被标注的注解保留多长时间。 Retension 注解的值为 RetensionPolicy枚举的一个成员：</li>\n</ol>\n<ul>\n<li><code>SOURCE</code> 表示注解仅存于源文件中，注解将被编译器丢弃。</li>\n<li><code>CLASS</code> 表示注解将保存在类文件中，但不被JVM保存的注解，是默认值。</li>\n<li><code>RUNTIME</code> 表示要被JVM保存的注解，在运行时可以利用反射机制查询</li>\n</ul>\n<ol start=\"4\">\n<li><code>Target</code><br>\nTarget注解用来指明哪个(些)程序元素可以利用被标注的注解类型进行标注。 Target的值为java.lang.annotation.ElementType枚举的一个成员：</li>\n</ol>\n<ul>\n<li><code>ANNOTATION_TYPE</code>  可以对注解类型标注。</li>\n<li><code>CONSTRUCTOR</code>  可以对构造方法进行标注。</li>\n<li><code>FIELD</code> 可以对成员的声明进行标注。</li>\n<li><code>LOCAL_VARIABLE</code>  可以对局部变量进行标注。</li>\n<li><code>METHOD</code>  可以对方法进行标注。</li>\n<li><code>PACKAGE</code>  可以对包进行标注。</li>\n<li><code>PARAMETER</code>  可以对参数声明进行标注。</li>\n<li><code>TYPE</code>  可以对类型声明进行标注</li>\n</ul>\n<p>如Override 注解类型使用了 Target 注解标注，使得 Override 只适用于方法声明.<br>\nSuppressWarnings 注解类型的声明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span> (value=&#123;TYPE,FIELD,METHOD,PARAMETER, CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention(value=SOURCE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SuppressWarnings</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义注解\">定义注解<a title=\"#定义注解\" href=\"#定义注解\"></a></h3>\n<p>默认情况下，所有的注解类型都扩展了java.lang.annotation.Annotation接口。该接口定义一个返回Class对象的 annotationType()方法 <code>Class &lt;?extends Annotation&gt; annotationType()</code>, 该接口还定义了equals()方法、hashCode()方法和toString()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"meta\">@interface</span> MyAnnotation &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">value</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"keyword\">class</span> <span class=\"title class_\">MyClass1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@MyAnnotation(value = &quot;Hello, World!&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> NoSuchMethodException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyClass1</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass1</span>();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> obj.getClass().getMethod(<span class=\"string\">&quot;myMethod&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">MyAnnotation</span> <span class=\"variable\">annotation</span> <span class=\"operator\">=</span> method.getAnnotation(MyAnnotation.class);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> annotation.value();</span><br><span class=\"line\">        System.out.println(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在注解类型中声明的方法称为注解类型的元素，它的声明类似于接口中的方法声明，没有方法体，但有返回类型。元素的类型有一些限制，如只能是基本类型、String、枚举类型、其他注解类型等，并且元素不能声明任何参数。<br>\n实际上，注解类型的元素就像对象的域一样，所有应用该注解类型的程序元素都要对这些域实例化。这些域的值是在应用注解时由初始化器决定，或由元素的默认值决定。<br>\n在定义注解时可以使用 default 关键字为元素指定默认值。</p>\n<p>javaxjws 包中定义了一些用来创建 Web 服务的注解类型，在 javax.xml.ws包和 javax.xml.bind.annotation 包中也定义了许多注解类型。注解类型在 Java Web 开发和Java EE 开发中被广泛使用.</p>\n<p><strong>参考</strong></p>\n<ol>\n<li>《Java程序设计(第3版)》 IBSN 9787302485520</li>\n<li><a href=\"https://docs.oracle.com/en/java/javase/19/docs/api/index.html\" target=\"_blank\">Java API 文档</a></li>\n<li><a href=\"https://blog.csdn.net/qq_52348926/article/details/129478117#:~:text=hashCode%20%28%29%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E8%AE%A1%E7%AE%97%E5%93%88%E5%B8%8C%E7%A0%81%E5%80%BC%EF%BC%8C%E8%80%8Cequals%20%28%29%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E7%AD%89%E6%80%A7%E3%80%82%20%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%20%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%93%88%E5%B8%8C%E7%A0%81%E5%80%BC%E7%9B%B8%E5%90%8C,%EF%BC%8C%20%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%84%8F%E5%91%B3%E7%9D%80%E5%AE%83%E4%BB%AC%E6%98%AF%E7%9B%B8%E7%AD%89%E7%9A%84%20%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%20%EF%BC%8C%E5%8D%B3%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E8%83%BD%E7%94%9F%E6%88%90%E7%9B%B8%E5%90%8C%E7%9A%84%E5%93%88%E5%B8%8C%E7%A0%81%E5%80%BC%E3%80%82\" target=\"_blank\">Hash值的理解，Java中hashCode()和equals究竟有什么用？</a></li>\n</ol>\n","prev":{"title":"[Java笔记]接口&Lambda表达式","link":"2023/05/10/[Java笔记]接口&Lambda表达式"},"next":{"title":"[Java笔记]继承&多态","link":"2023/05/09/[Java笔记]继承&多态"},"plink":"https://s1acr.github.io/2023/05/09/[Java笔记]常用核心类内部类枚举注解/","toc":[{"id":"object","title":"Object","index":"1"},{"id":"math","title":"Math","index":"2"},{"id":"基本类型包装类","title":"基本类型包装类","index":"3","children":[{"id":"character","title":"Character","index":"3.1"},{"id":"boolean","title":"Boolean","index":"3.2"},{"id":"数值类对象","title":"数值类对象","index":"3.3"},{"id":"自动装箱与自动拆箱","title":"自动装箱与自动拆箱","index":"3.4"},{"id":"字符串与基本数据类型转化","title":"字符串与基本数据类型转化","index":"3.5"}]},{"id":"biginteger-bigdecimal","title":"BigInteger BigDecimal","index":"4"},{"id":"时间日期api","title":"时间日期API","index":"5"},{"id":"内部类","title":"内部类","index":"6","children":[{"id":"内部成员类","title":"内部成员类","index":"6.1"},{"id":"局部内部类","title":"局部内部类","index":"6.2"},{"id":"匿名内部类","title":"匿名内部类","index":"6.3"},{"id":"静态内部类","title":"静态内部类","index":"6.4"}]},{"id":"枚举类型","title":"枚举类型","index":"7"},{"id":"注解类型","title":"注解类型","index":"8","children":[{"id":"标准注解","title":"标准注解","index":"8.1"},{"id":"标准元注解","title":"标准元注解","index":"8.2"},{"id":"定义注解","title":"定义注解","index":"8.3"}]}],"reward":true,"copyright":{"author":"slacr_","license":"<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" target=\"_blank\"><img src = \"/lib/cc-by-nc-sa.svg\">CC BY-NC-ND 4.0</a>","published":"May 9, 2023","updated":"May 9, 2023"},"reading_time":"5144 words in 34 min"}