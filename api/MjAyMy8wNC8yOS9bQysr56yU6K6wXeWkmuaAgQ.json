{"title":"[C++笔记]多态","date":"2023-04-29T00:00:00.000Z","date_formatted":{"ll":"Apr 29, 2023","L":"04/29/2023","MM-DD":"04-29"},"link":"2023/04/29/[C++笔记]多态","comments":true,"categories":["C++"],"updated":"2023-04-29T00:00:00.000Z","content":"<blockquote>\n<p>C++ 笔记</p>\n</blockquote>\n<h2 id=\"多态概述\">多态概述<a title=\"#多态概述\" href=\"#多态概述\"></a></h2>\n<p>多态是指同样的消息被不同类型的对象接收时导致不同的行为。<br>\n面向对象的多态性可以分为四类:重载多态、强制多态、包含多态和参数多态。前面两种统称为专用多态，而后面两种称为通用多态。<br>\n强制多态是指将一个变元的类型加以变化，以符合一个函数或者操作的要求.<br>\n包含多态是类族中定义于不同类中的同名成员函数的多态行为，主要是通过虚函数来实现。<br>\n参数多态与类模板相关联，在使用时必须赋予实际的类型才可以实例化。</p>\n<p>多态从实现的角度来讲可以划分为两类:编译时的多态和运行时的多态。前者是在编译的过程中确定了同名操作的具体操作对象，而后者则是在程序运行过程中才动态地确定操作所针对的具体对象。这种确定操作的具体对象的过程就是绑定 (binding) 。绑定是指计算机程序自身彼此关联的过程，也就是把一个标识符名和一个存储地址联系在一起的过程;用面向对象的术语讲，就是把一条消息和一个对象的方法相结合的过程。按照绑定进行的阶段的不同，可以分为两种不同的绑定方法:静态绑定和动态绑定.<br>\n绑定工作在编译连接阶段完成的情况称为静态绑定。其同名操作的具体对象能够在编译、连接阶段确定，通过静态绑定解决，比如重载、强剧和参数多态。<br>\n绑定工作在程序运行阶段完成的情况称为动态绑定, 在编译、连接过程中无法解决的绑定问题，包含多态操作对象的确定就是通过动态绑定完成的。</p>\n<h2 id=\"运算符重载\">运算符重载<a title=\"#运算符重载\" href=\"#运算符重载\"></a></h2>\n<p>运算符重载的实质就是函数重载。对已有的运算符赋予多重含义，使同一个运算符作用于不同类型的数据时导致不同的行为。</p>\n<p>运算符重载的规则:</p>\n<p>(1) c++ 中的运算符除了少数几个之外<code>. * :: ?</code>，全部可以重载，而且只能重载 c++ 中已经有的运算符。<br>\n(2) 重载之后运算符的优先级和结合性都不会改变。<br>\n(3) 运算符重载是针对新类型数据的实际需要，对原有运算符进行适当的改造。一般来讲，重载的功能应当与原有功能相类似，不能改变原运算符的操作对象个数，同时至少要有一个操作对象是自定义类型。<br>\n运算符的重载形式有两种，即重载为类的<code>非静态成员函数</code>和重载<code>为非成员函数</code>。</p>\n<p>当运算符重载为类的成员函数时，函数的参数个数比原来的操作数个数要少一个(后置&quot;++“，”–&quot;除外)<br>\n重载为非成员函数时，参数个数与原操作数个数相同。</p>\n<p>重载为类的成员函数时，第一个操作数会被作为函数调用的目的对象，因此无须出现在参数表中，函数体中可以直接访问第一个操作数的成员;而重载为非成员函数时，运算符的所有操作数必须显式通过参数传递。</p>\n<h3 id=\"重载成员函数\">重载成员函数<a title=\"#重载成员函数\" href=\"#重载成员函数\"></a></h3>\n<h4 id=\"重载双目运算符\">重载双目运算符<a title=\"#重载双目运算符\" href=\"#重载双目运算符\"></a></h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span>  <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y;</span><br><span class=\"line\">\t<span class=\"built_in\">Test</span>():<span class=\"built_in\">x</span>(<span class=\"number\">0</span>), <span class=\"built_in\">y</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">Test</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y)&#123;&#125;</span><br><span class=\"line\">\t<span class=\"type\">void</span> <span class=\"keyword\">operator</span>+(Test t) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;x += t.x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;y += t.y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 重载双目运算符, 第一个参数类的对象</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;[&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class=\"string\">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Test <span class=\"title\">t1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">\tt1 + <span class=\"built_in\">Test</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 相当于 t1.operator+(Test(2, 3))</span></span><br><span class=\"line\">\tt1.<span class=\"built_in\">display</span>();  <span class=\"comment\">// [3, 5]</span></span><br><span class=\"line\">\tt1.<span class=\"keyword\">operator</span>+(<span class=\"built_in\">Test</span>(<span class=\"number\">4</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">\tt1.<span class=\"built_in\">display</span>();\t<span class=\"comment\">// [7, 9]</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"重载单目运算符\">重载单目运算符<a title=\"#重载单目运算符\" href=\"#重载单目运算符\"></a></h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y;</span><br><span class=\"line\">\t<span class=\"built_in\">Test</span>() :<span class=\"built_in\">x</span>(<span class=\"number\">0</span>), <span class=\"built_in\">y</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">Test</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 重载前置++</span></span><br><span class=\"line\">\t<span class=\"type\">void</span> <span class=\"keyword\">operator</span>++() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;x++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;y++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 重载后置++</span></span><br><span class=\"line\">\t<span class=\"type\">void</span> <span class=\"keyword\">operator</span>++(<span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;x += <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;y += <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;[&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class=\"string\">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Test <span class=\"title\">t1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">\t++t1;\t\t\t</span><br><span class=\"line\">\tt1.<span class=\"built_in\">display</span>(); <span class=\"comment\">// [2, 3]</span></span><br><span class=\"line\">\tt1.<span class=\"keyword\">operator</span>++(); </span><br><span class=\"line\">\tt1.<span class=\"built_in\">display</span>();  <span class=\"comment\">// [3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tt1++;</span><br><span class=\"line\">\tt1.<span class=\"built_in\">display</span>();\t<span class=\"comment\">// [5, 6]</span></span><br><span class=\"line\">\tt1.<span class=\"keyword\">operator</span>++(<span class=\"number\">1</span>);  <span class=\"comment\">// 加个参数以区分后置, 参数仅起区分作用</span></span><br><span class=\"line\">\tt1.<span class=\"built_in\">display</span>();\t<span class=\"comment\">// [7, 8]</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重载非成员函数\">重载非成员函数<a title=\"#重载非成员函数\" href=\"#重载非成员函数\"></a></h3>\n<p>运算所需要的操作数都需要通过函数的形参表来传递，在形参表中形参从左到右的顺序就是运算符操作数的顺序。如果需要访问<br>\n运算符参数对象的私有成员，可以将该函数声明为类的友元函数。</p>\n<h4 id=\"重载单目运算符-1\">重载单目运算符<a title=\"#重载单目运算符-1\" href=\"#重载单目运算符-1\"></a></h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y;</span><br><span class=\"line\">\t<span class=\"built_in\">Test</span>() :<span class=\"built_in\">x</span>(<span class=\"number\">0</span>), <span class=\"built_in\">y</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">Test</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;[&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class=\"string\">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重载左++</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"keyword\">operator</span>++(Test&amp; t) &#123;</span><br><span class=\"line\">\tt.x++;</span><br><span class=\"line\">\tt.y++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重载右++</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"keyword\">operator</span>++(Test&amp; t, <span class=\"type\">int</span> ) &#123;</span><br><span class=\"line\">\tt.x += <span class=\"number\">2</span>;</span><br><span class=\"line\">\tt.y += <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Test <span class=\"title\">t1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">\t++t1;</span><br><span class=\"line\">\tt1.<span class=\"built_in\">display</span>();\t<span class=\"comment\">// [2, 3] </span></span><br><span class=\"line\">\tt1++;</span><br><span class=\"line\">\tt1.<span class=\"built_in\">display</span>();\t<span class=\"comment\">// [4, 5]</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"重载双目运算符-1\">重载双目运算符<a title=\"#重载双目运算符-1\" href=\"#重载双目运算符-1\"></a></h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">P</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> x, y;</span><br><span class=\"line\">\t<span class=\"built_in\">P</span>() : <span class=\"built_in\">x</span>(<span class=\"number\">0</span>), <span class=\"built_in\">y</span>(<span class=\"number\">0</span>)&#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">P</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; o, P p) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 重载&lt;&lt; , 由于 &lt;&lt; 左移运算符的第一个操作数只能是一个 ostream&amp; 类型, 故只能使用普通函数重载</span></span><br><span class=\"line\">\to &lt;&lt; <span class=\"string\">&quot;[&quot;</span> &lt;&lt; p.x &lt;&lt;  <span class=\"string\">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">P&amp; <span class=\"keyword\">operator</span>+ (P p1, P p2) &#123;</span><br><span class=\"line\">\t<span class=\"function\">P <span class=\"title\">p</span><span class=\"params\">(p1.x + p2.x, p1.y + p2.y)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">P</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">P</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"built_in\">P</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>) + <span class=\"built_in\">P</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>) + <span class=\"built_in\">P</span>(<span class=\"number\">3</span>, <span class=\"number\">3</span>) &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"虚函数\">虚函数<a title=\"#虚函数\" href=\"#虚函数\"></a></h2>\n<h3 id=\"虚函数的实现\">虚函数的实现<a title=\"#虚函数的实现\" href=\"#虚函数的实现\"></a></h3>\n<p>虚函数是<code>动态绑定</code>的基础。虚函数必须是非静态的成员函数。虚函数经过派生之后，在类族中就可以实现运行过程中的多态。</p>\n<p>根据赋值兼容规则，可以使用派生类的对象代替基类对象。如果用基类类型的指针指向派生类对象，就可以通过这个指针来访问该对象，问题是访问到的只是从基类继承来的同名成员。解决这一问题的办法是:如果需要通过基类的指针指向派生类的对象，并<br>\n访问某个与基类同名的成员，那么首先在基类中将这个同名函数说明为虚函数。这样，通过基类类型的指针，就可以便属于不同派生类的不同对象产生不同的行为，从而实现运行过程的多态。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">go</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Base&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 虚函数</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> test;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived_1</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;\t\t<span class=\"comment\">// 这里的virtual可加可不加, 不加编译器会自动判断</span></span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Derived_1&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived_2</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Derived_2&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">say</span><span class=\"params\">(Base* b)</span> </span>&#123;</span><br><span class=\"line\">\tb-&gt;<span class=\"built_in\">say</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tBase* b = <span class=\"keyword\">new</span> <span class=\"built_in\">Base</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">say</span>(b);\t\t\t\t<span class=\"comment\">// Base</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tDerived_1* d_1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Derived_1</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">say</span>(d_1);\t\t\t<span class=\"comment\">// Derived_1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tDerived_2* d_2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Derived_2</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">say</span>(d_2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tBase* base = d_1;</span><br><span class=\"line\">\tbase-&gt;<span class=\"built_in\">say</span>();\t\t\t<span class=\"comment\">// Derived_1</span></span><br><span class=\"line\">\tbase-&gt;Base::<span class=\"built_in\">say</span>();\t<span class=\"comment\">// Base   ,可以加作用域以限制调用类作用域下的函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304291532430.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304291532463.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<p>基类多了一个<code>虚函数表指针vfptr</code>, 指向一张<code>虚函数表vftable</code>, 子类继承了该虚函数后会根据函数覆盖(重写)的关系重新初始化其中的虚函数表和虚函数表指针. 虚函数表中记录了该类中每个虚函数正确指向的函数地址.</p>\n<p>此时再<code>当派生类指针/引用初始化基类指针/引用时(对象不行, 会发生调用基类复制构造, 对象切片转换得到一个基类对象)</code>, 基类指针任然只能访问派生类继承下来的基类部分, 但其中的vfptr和vbtable已经被改写, 从而可以实现基类指针/引用调用虚函数的动态绑定.</p>\n<p>只有虚函数是动态绑定的，如果派生类需要修改基类的行为(即重写与基类函数同名的函数) ，就应该在基类中将相应的函数声明为虚函数。而基类中声明的非虚函数，通常代表那些不希望被派生类改变的功能，也是不能实现多态的。一般不要重写继承而来的非虚函数(虽然语法对此没有强行限制) ，因为那会导致通过基类指针和派生类的指针或对象调用同名函数时，产生不同的结果，从而引起混乱。</p>\n<h3 id=\"虚析构函数\">虚析构函数<a title=\"#虚析构函数\" href=\"#虚析构函数\"></a></h3>\n<p>C++不能声明虚构造函数，但是可以声明虚析构函数。</p>\n<p>一个类的析构函数是虚函数，那么由它派生而来的所有子类的析构函数也是虚函数。析构函数设置为虚函数之后，在使用指针引用时可以动态绑定，实现运行时的多态，保证使用基类类型的指针就能够调用适当的析构函数针对不同的对象进行清理工作。</p>\n<p>如果有可能<code>通过基类指针调用派生类对象的析构函数</code> ，就需要让<code>基类的析构函数成为虚函数</code>，否则会产生不确定的后果。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Base</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Base::~<span class=\"built_in\">Base</span>() &#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Base destructor&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span>* item = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Derived</span>();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Derived::~<span class=\"built_in\">Derived</span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> item;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;Derived destructor&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tBase* b = <span class=\"keyword\">new</span> <span class=\"built_in\">Derived</span>();</span><br><span class=\"line\">\t<span class=\"comment\">// 派生类指针初始化基类指针</span></span><br><span class=\"line\">\t<span class=\"comment\">// delete b;\t没有声明基类虚析构时 Base destructor, 派生类内存泄漏</span></span><br><span class=\"line\">\t <span class=\"keyword\">delete</span> b;\t<span class=\"comment\">// 声明虚析构后, 调用派生类析构再基类析构, 内存正确释放</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"纯虚函数\">纯虚函数<a title=\"#纯虚函数\" href=\"#纯虚函数\"></a></h3>\n<p>纯虚函数是一个在基类中声明的虚函数，它在该基类中没有定义具体的操作内容，要求各派生类根据实际需要给出各自的定义。<br>\n声明为纯虚函数之后，基类中就可以不再给出函鼓的实现部分。纯虚函数的函数体由派生类给出。</p>\n<p>基类中仍然允许对纯虚函数给出实现，但即使给出实现，也<code>必须由派生类覆盖，否则无法实例化</code>。在基类中对纯虚函数定义的函数体的调用，必须通过&quot;基类名::函数名(参数表)&quot;的形式。如果将析构函数声明为纯虚函数，必须给出它的实现，因为派生类的析构函数体执行完后需要调用基类的纯虚函数。</p>\n<p><code>纯虚函数不同于函数体为空的虚函数</code>:纯虚函数根本就没有函数体，而空的虚函数的函数体为空;前者所在的类是抽象类，不能直接进行实例化，而后者所在的类是可以实例化的。它们共同的特点是都可以派生出新的类，然后在新类中给出虚函数新的实现，而且这种新的实现可以具有多态特征。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Base::say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;base&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;derived&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tDerived d;</span><br><span class=\"line\">\td.<span class=\"built_in\">say</span>();\t\t<span class=\"comment\">// base</span></span><br><span class=\"line\">\td.Base::<span class=\"built_in\">say</span>();\t<span class=\"comment\">// derived</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"抽象类\">抽象类<a title=\"#抽象类\" href=\"#抽象类\"></a></h3>\n<p><code>带有纯虚函数的类是抽象类</code>。抽象类的主要作用是通过它为一个类族建立一个公共的接口，使它们能够更有效地发挥多态特性。抽象类声明了一个类族派生类的共同接口，而接口的完整实现，即纯虚函数的函数体，要由派生类自己定义。</p>\n<p>抽象类派生出新的类之后，如果派生类给出所有纯虚函数的函数实现，这个派生类就可以定义自己的对象，因而不再是抽象类;反之，如果派生类没有给出全部纯虚函数的实现，这时的派生类仍然是个抽象类。</p>\n<p><code>抽象类不能实例化</code>，即不能定义一个抽象类的对象，但是可以<code>定义一个抽象类的指针和引用</code>。通过指针或引用，就可以指向并访问派生类的对象，进而访问派生类的成员，这种访问是具有多态特征的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showCapability</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Farmer</span> : <span class=\"keyword\">public</span> Person &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tstring seed;</span><br><span class=\"line\">\t<span class=\"built_in\">Farmer</span>(string seed) : <span class=\"built_in\">seed</span>(seed)&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showCapability</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;I plant &quot;</span> &lt;&lt; seed &lt;&lt; <span class=\"string\">&quot; on my land&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Programmer</span> : <span class=\"keyword\">public</span> Person &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tstring lang;</span><br><span class=\"line\">\t<span class=\"built_in\">Programmer</span>(string lang) : <span class=\"built_in\">lang</span> (lang)&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showCapability</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;I write &quot;</span> &lt;&lt; lang &lt;&lt; <span class=\"string\">&quot; earning living&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tPerson* p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tp = <span class=\"keyword\">new</span> <span class=\"built_in\">Farmer</span>(<span class=\"string\">&quot;carrots&quot;</span>);  </span><br><span class=\"line\">\tp-&gt;<span class=\"built_in\">showCapability</span>();</span><br><span class=\"line\">\tp = <span class=\"keyword\">new</span> <span class=\"built_in\">Programmer</span>(<span class=\"string\">&quot;C++&quot;</span>);\t</span><br><span class=\"line\">\tp-&gt;<span class=\"built_in\">showCapability</span>();\t<span class=\"comment\">// I write C++ earning living</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304291932196.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"多态类型与非多态类型\">多态类型与非多态类型<a title=\"#多态类型与非多态类型\" href=\"#多态类型与非多态类型\"></a></h3>\n<p>c++ 的类类型分为两类一一多态类型和非多态类型。多态类型是指有虚函数的类类型，非多态类型是指所有的其他类型.</p>\n<p>基类的指针可以指向派生类的对象。如果该基类是多态类型，那么通过该指针调用基类的虚函数时，实际执行的操作是由派生类决定的。从这个意义上讲，派生类只是继承了基类的接口，但不必继承基类中虚函数的实现，对基类虚函数的调用可以反映派生类的特殊性。</p>\n<p>设计多态类型的一个重要原则是，把多态类型的析构函数设定为虚函数。</p>\n<p>对非多态类的公有继承，应当慎重，而且一般没有太大必要。</p>\n<h3 id=\"dynamic_cast\">dynamic_cast<a title=\"#dynamic_cast\" href=\"#dynamic_cast\"></a></h3>\n<p>dynamic_cast 是与 static_cast. const_cast , reinterpret_cast 并列的 种类型转换操作符之一。它可以将<code>基类的指针显式转换为派生类的指针</code>，或将基类的引用显式转换为派生类的引用。与 static_cast 不同的是，它执行的不是无条件的转换，它在转换前会检查指针(或引用)所指向对象的实际类型是否与转换的目的类型兼容，如果兼容转换才会发生，才能得到派生类的指针(或引用). 否则:</p>\n<ul>\n<li>如果执行的是指针类型的转换，会得到空指针。</li>\n<li>如果执行的是引用类型的转换，会抛出异常<br>\n另外，转换前类型必须是指向多态类型的指针，或多态类型的引用，而不能是指向非多态类型的指针或非多态类型的引用，这是因为 c++ <code>只为多态类型在运行时保存用于运行时类型识别的信息</code>。这从另一个方面说明了非多态类型为什么不宜被公有继承。</li>\n</ul>\n<p>当原始类型为多态类型的指针时，目的类型除了是派生类指针外，还可以是void 指针，例如 dynamic_cast&lt; void *&gt;(p)。这时所执行的实际操作是，先将 指针转换为它所指向的对象的实际类型的指针，再将其转换为 void 指针。换句话说，就是得到所指向对象的首地址(请注意，在多继承存在的情况下，基类指针存储的地址未必是对象的首地址)。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Base&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Derived&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tDerived* pd1 = <span class=\"built_in\">dynamic_cast</span>&lt;Derived*&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">Base</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pd1 != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\tpd1-&gt;<span class=\"built_in\">say</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Base指针直接转换成Derived指针 , 失败</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tBase* b = <span class=\"keyword\">new</span> <span class=\"built_in\">Derived</span>();</span><br><span class=\"line\">\tDerived* pd2 = <span class=\"built_in\">dynamic_cast</span>&lt;Derived*&gt;(b);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pd2 != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\tpd2-&gt;<span class=\"built_in\">say</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Base指针用Derived初始化, 再转成derived成功</span></span><br><span class=\"line\">\t<span class=\"comment\">// 只有实际类型与目的类型兼容, 转换才能发生, 比如转换成实际类型或子类型</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"typeid\">typeid<a title=\"#typeid\" href=\"#typeid\"></a></h3>\n<p><code>typeid</code> C++ 的一个<code>关键字</code>，用它可以获得一个类型的相关信息。</p>\n<p>通过 typeid 得到的是一个 type_info 类型的常引用。 type_info c++ 标准库中的一个类，专用于在运行时表示类型信息，它定义在 typeinfo 头文件中。</p>\n<p>如果 typeid 所作用于的表达式具有多态类型，那么这个表达式会被求值，用 typeid得到的是用于描述表达式求值结果的运行时类型(动态类型)的 type_info 对象的常引用。而如果表达式具有非多态类型，那么用 typeid 得到的是表达式的静态类型，由于这个静态类型在编译时就能确定，这时表达式不会被求值。因此，虽然 typeid 可以作用于任何类型的表达式，但只有它作用于多态类型的表达式时，进行的才是运行时类型识别，否则只是简单的静态类型信息的获取。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Base</span>()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(Base* b)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> type_info&amp; info_1 = <span class=\"built_in\">typeid</span>(b);</span><br><span class=\"line\">\t<span class=\"type\">const</span> type_info&amp; info_2 = <span class=\"built_in\">typeid</span>(*b);</span><br><span class=\"line\">\tcout &lt;&lt; info_1.<span class=\"built_in\">name</span>() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; info_2.<span class=\"built_in\">name</span>() &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (info_2 == <span class=\"built_in\">typeid</span>(Base)) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Base Class&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Non Base Class&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tBase b;</span><br><span class=\"line\">\t<span class=\"built_in\">fun</span>(&amp;b);</span><br><span class=\"line\">\tDerived d;</span><br><span class=\"line\">\t<span class=\"built_in\">fun</span>(&amp;d);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指针b不是动态类型, 故得到结果相同.</span></span><br><span class=\"line\"><span class=\"comment\">// *b对象是动态类型, typeid(*b)得到具体类型</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/Typora/202304292146612.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"虚函数动态绑定的实现原理\">虚函数动态绑定的实现原理<a title=\"#虚函数动态绑定的实现原理\" href=\"#虚函数动态绑定的实现原理\"></a></h3>\n<p>每个类各有一个虚表，虚表的内容是由编译器安排的。派生类的虚表中，基类声明的虚函数对应的指针放在前面，派生类新增的虚函数的对应指针放在后面，这样一个虚函数的指针在基类虚表和派生类虚表中具有相同的位置。每个多态类型的对象中都有一个指向当前类型的虚表的指针，该指针在构造函数中被赋值。当通过基类的指针或引用调用一个虚函数时，就可以通过虚表指针找到该对象的虚表，进而找到存放该虚函数的指针的虚表条目。将该条目中存放的指针读出后，就可获得应当被调用的函数的人口地址，然后调用该虚函数，虚函数的动态绑定就是这样完成的。</p>\n<p>执行一个类的构造函数时，首先被执行的是基类的构造函数，因此构造一个派生类的对象时，该对象的虚表指针首先会被指向基类的虚表。只有当基类构造函数执行完后，虚表指针才会被指向派生类的虚表，这就是基类构造函数调用虚函数时不会调用派生类的虚函数的原因。</p>\n<p>在多继承时，情况会更加复杂，因为每个基类都有各自的虚函数，每个基类也会有各自的虚表，这样继承了多个基类的派生类需要多个虚表(或一个虚表分为多段，每个基类的虚表指针指向其中一段的首地址)。</p>\n<p>事实上，一个类的虚表中存放的不只是虚函数的指针，用于支持运行时类型识别的对象的运行时类型信息也需要通过虚表来访问。只有多态类型有虚表，因此只有多态类型支持运行时类型识别。</p>\n<p><strong>参考</strong></p>\n<ol>\n<li>《C++语言程序设计（第4版）》 IBSN 9787302227984</li>\n<li><a href=\"https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5\" target=\"_blank\">C++参考手册</a></li>\n<li><a href=\"https://learn.microsoft.com/zh-cn/cpp/standard-library/iomanip?view=msvc-170\" target=\"_blank\">Microsoft C++文档</a></li>\n</ol>\n","prev":{"title":"[Java]Lab","link":"2023/05/01/[Java]Lab"},"next":{"title":"[C++笔记]群体类和群体数据的组织一","link":"2023/04/29/[C++笔记]群体类和群体数据的组织一"},"plink":"https://s1acr.github.io/2023/04/29/[C++笔记]多态/","toc":[{"id":"多态概述","title":"多态概述","index":"1"},{"id":"运算符重载","title":"运算符重载","index":"2","children":[{"id":"重载成员函数","title":"重载成员函数","index":"2.1","children":[{"id":"重载双目运算符","title":"重载双目运算符","index":"2.1.1"},{"id":"重载单目运算符","title":"重载单目运算符","index":"2.1.2"}]},{"id":"重载非成员函数","title":"重载非成员函数","index":"2.2","children":[{"id":"重载单目运算符-1","title":"重载单目运算符","index":"2.2.1"},{"id":"重载双目运算符-1","title":"重载双目运算符","index":"2.2.2"}]}]},{"id":"虚函数","title":"虚函数","index":"3","children":[{"id":"虚函数的实现","title":"虚函数的实现","index":"3.1"},{"id":"虚析构函数","title":"虚析构函数","index":"3.2"},{"id":"纯虚函数","title":"纯虚函数","index":"3.3"},{"id":"抽象类","title":"抽象类","index":"3.4"},{"id":"多态类型与非多态类型","title":"多态类型与非多态类型","index":"3.5"},{"id":"dynamic_cast","title":"dynamic_cast","index":"3.6"},{"id":"typeid","title":"typeid","index":"3.7"},{"id":"虚函数动态绑定的实现原理","title":"虚函数动态绑定的实现原理","index":"3.8"}]}],"reward":true,"copyright":{"author":"slacr_","license":"<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" target=\"_blank\"><img src = \"/lib/cc-by-nc-sa.svg\">CC BY-NC-ND 4.0</a>","published":"April 29, 2023","updated":"April 29, 2023"},"reading_time":"5159 words in 34 min"}