{"title":"[数据库]设计","date":"2023-06-03T00:00:00.000Z","date_formatted":{"ll":"Jun 3, 2023","L":"06/03/2023","MM-DD":"06-03"},"link":"2023/06/03/[数据库]设计","comments":true,"categories":["数据库"],"updated":"2023-06-03T00:00:00.000Z","content":"<h2 id=\"关系数据理论\">关系数据理论<a title=\"#关系数据理论\" href=\"#关系数据理论\"></a></h2>\n<div class=\"φbu φbx\">\n<details>\n<summary><strong><code>问题提出</code></strong></summary>\n<ul>\n<li>一个<code>关系模式</code>应当是一个 5 元组 R(U,D,DOM,F)</li>\n<li>当且仅当 U 上的一个关系 r 满足 F 时，r 称为关系模式 R&lt;U,F&gt;的一个关系。</li>\n<li>作为一个二维表，关系要符合一个最基本的条件：<code>每一个分量必须是不可分的数据项</code>。满足了这个条件的关系模式就属于<code>第一范式(1NF)</code>。</li>\n<details>\n<summary><strong><code>数据依赖</code></strong></summary>\n<ul>\n<li><code>数据依赖是一个关系内部属性与属性之间的一种约束关系</code>。这种约束关系是通过属性间值的相等与否体现出来的数据间相关联系。它是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。</li>\n<li>有许多种类型的数据依赖，其中最重要的是<code>函数依赖(Functional Dependency,FD)</code>和<code>多值依赖(Multi-Valued Dependency,MVD)</code>。</li>\n<details>\n<summary><strong><code>函数依赖</code></strong></summary>\n<ul>\n<li>函数依赖类似于数学中的函数 y=f(x),自变量 x 确定之后，相应的函数值 y 也就唯一地确定了.</li>\n<li>类似的有 Sname=f(Sno),Sdept=f(Sno),即 Sno 函数决定 Sname,Sno 函数决定 Sdept,或者说 Sname 和 Sdept 函数依赖于 Sno,记作<code>Sno→Sname,Sno→Sdept</code>。</li>\n<li>如 F={Sno→Sdept,Sdept→Mname,(Sno,Cno)→Grade}<br>\n<img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306031717559.png\" alt=\"\" loading=\"lazy\"></li>\n<li>这仅仅符合第一范式的关系模式存在以下问题: 数据冗余, 更新异常(update anomalies), 插入异常(insertion anomalies), 删除异常(deletion anomalies)</li>\n</details>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div><div class=\"φbu φbx\">\n<details>\n<summary><strong><code>规范化</code></strong></summary>\n<ul>\n<li>按属性间依赖情况来区分关系规范化程度为第一范式、第二范式、第三范式和第四范式等；然后将具有不合适性质的关系转换为更合适的形式。</li>\n<details>\n<summary><strong><code>函数依赖</code></strong></summary>\n<ul>\n<li>设 R(U)是属性集 U 上的关系模式，X,Y 是 U 的子集。若对于 R(U)的任意一个可能的关系 r,r 中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不等，则称 X 函数确定 Y 或 Y 函数依赖于 X,记作 X→Y。</li>\n<li>函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。</li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306032030242.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></li>\n</details>\n</li>\n<details>\n<summary><strong><code>码</code></strong></summary>\n<ul>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306032045940.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></li>\n</details>\n</li>\n<details>\n<summary><strong><code>范式(normal form)</code></strong></summary>\n<ul>\n<li><code>关系数据库中的关系</code>是要满足一定要求的，<code>满足不同程度要求的为不同范式</code>。满足最低要求的叫第一范式，简称1NF;在第一范式中满足进一步要求的为第二范式，其余以此类推。</li>\n<li>有关范式理论的研究主要是<code>E.E.Codd</code>做的工作。1971—1972年Codd系统地提出了1NF、2NF、3NF的概念，讨论了规范化的问题。1974年，Codd和Boyce共同提出了一个新范式，即BCNF。1976年Fagin提出了4NF。后来又有研究人员提出了5NF。</li>\n<li>范式这个概念理解成<code>符合某一种级别的关系模式的集合</code>，即R为第几范式就可以写成R∈xNF。</li>\n<li>一个低一级范式的关系模式通过<code>模式分解(schema decomposition)</code>可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<code>规范化(normalization)</code>。</li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306032051634.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></li>\n</details>\n</li>\n<details>\n<summary><strong><code>2NF</code></strong></summary>\n<ul>\n<li>若R∈1NF,且<code>每一个非主属性完全函数依赖于任何一个候选码</code>，则R∈2NF。</li>\n<li>一个关系模式R不属于2NF,就会产生以下几个问题：插入异常, 删除异常, 修改复杂, 存储冗余度大.</li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306032058126.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></li>\n</details>\n</li>\n<details>\n<summary><strong><code>3NF</code></strong></summary>\n<ul>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306032102759.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></li>\n<li>{就是说再满足2NF的基础上不能存在传递依赖, 比如某一关系的属性组A-B-C, A-&gt;B, B-&gt;C, 则A-传递-&gt;C, 解决方法就是拆成两个关系 A-B, B-C就满足了3NF}</li>\n</details>\n</li>\n<details>\n<summary><strong><code>BCNF</code></strong></summary>\n<ul>\n<li><code>BCNF(Boyce Codd Normal Form)</code>是由Boyce与Codd提出的，比上述的3NF又进了一步，通常认为BCNF是修正的第三范式，有时也称为扩充的第三范式。<br>\n<img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306032117733.png\" alt=\"\" loading=\"lazy\"></li>\n<li>3NF和BCNF是在函数依赖的条件下对模式分解所能达到的分离程度的测度。一个模式中的关系模式如果都属于BCNF,那么在函数依赖范畴内它已实现了彻底的分离，已消除了插入和删除的异常。3NF的“不彻底”性表现在可能存在主属性对码的部分依赖和传递依赖。</li>\n</details>\n</li>\n<details>\n<summary><strong><code>多值依赖</code></strong></summary>\n<ul>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306032154605.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></li>\n<li>{也就是说, 若B多值依赖于A , A-&gt;-&gt;B, 那么给定一个A=a, 就能确定一组B的值 {b1, b2…}, 并且这组值的确定仅仅跟A有关, 与其他属性无关}</li>\n<details>\n<summary><strong><code>多值依赖的性质</code></strong></summary>\n<ul>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306032150562.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></li>\n</details>\n</li>\n</ul>\n</li>\n<details>\n<summary><strong><code>4NF</code></strong></summary>\n<ul>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306032152134.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></li>\n<li>4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</li>\n</details>\n</li>\n<details>\n<summary><strong><code>5NF</code></strong></summary>\n<ul>\n<li>数据依赖中除函数依赖和多值依赖之外，还有其他数据依赖。例如有一种连接依赖。函数依赖是多值依赖的一种特殊情况，而多值依赖实际上又是连接依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可由语义直接导出，而是在关系的连接运算时才反映出来。存在连接依赖的关系模式仍可能遇到数据冗余及插入、修改、删除异常等问题。如果消除了属于4NF的关系模式中存在的连接依赖，则可以进一步达到5NF的关系模式。</li>\n</details>\n</li>\n<details>\n<summary><strong><code>规范化思想</code></strong></summary>\n<ul>\n<li>规范化的基本思想是逐步消除数据依赖中不合适的部分，使模式中的各关系模式达到某种程度的&quot;分离&quot;, 即“一事一地”的模式设计原则。让一个关系描述一个概念、一个实体或者实体间的一种联系。若多于一个概念就把它“分离”出去。因此所谓规范化实质上是<code>概念的单一化</code>。</li>\n<li>关系模式的规范化过程是通过对关系模式的分解来实现的，即<code>把低一级的关系模式分解为若干个高一级的关系模式</code>。这种分解不是唯一的。</li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306032202011.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306032125773.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></li>\n</details>\n</li>\n</ul>\n</li>\n</ul>\n</div><h2 id=\"数据库设计\">数据库设计<a title=\"#数据库设计\" href=\"#数据库设计\"></a></h2>\n<div class=\"φbu φbx\">\n<details>\n<summary><strong><code>基础</code></strong></summary>\n<ul>\n<li>数据库设计是指对于一个给定的应用环境，构造(设计)优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</li>\n<li>“三分技术，七分管理，十二分基础数据” 是数据库设计的特点之一。</li>\n<li>数据库设计应该和应用系统设计相结合。整个设计过程中要把数据库结构设计和对数据的处理设计密切结合起来。这是数据库设计的特点之二。<br>\n<img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041436902.png\" alt=\"\" loading=\"lazy\"></li>\n<li>各种数据库设计方法。例如，新奥尔良(New Orleans)方法、基于E-R模型的设计方法、3NF(第三范式)的设计方法、面向对象的数据库设计方法、统一建模语言(Unified Model Language,UML)方法等。</li>\n<details>\n<summary><strong><code>数据库设计基本步骤</code></strong></summary>\n<ul>\n<li><code>需求分析</code></li>\n<li><code>概念结构设计</code></li>\n<li><code>逻辑结构设计</code></li>\n<li><code>物理结构设计</code></li>\n<li><code>数据库实施</code></li>\n<details>\n<summary><code>数据库运行和维护</code></summary>\n<ul>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041439359.png\" alt=\"\" loading=\"lazy\"><br>\n<img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041442128.png\" alt=\"\" loading=\"lazy\"><br>\n<img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041444951.png\" alt=\"\" loading=\"lazy\"></li>\n</details>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div><div class=\"φbu φbx\">\n<details>\n<summary><strong><code>需求分析</code></strong></summary>\n<ul>\n<li>需求分析的任务是通过详细调查现实世界要处理的对象(组织、部门、企业等),充分了解原系统(手工系统或计算机系统)的工作概况，明确用户的各种需求，然后在此基础上确定新系统的功能。<br>\n<img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041449872.png\" alt=\"\" loading=\"lazy\"></li>\n<details>\n<summary><strong><code>数据字典</code></strong></summary>\n<ul>\n<li>数据字典是进行详细的数据收集和数据分析所获得的主要成果。它是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善的。</li>\n<li>数据字典通常包括<code>数据项、数据结构、数据流、数据存储和处理过程</code>几部分。其中数据项是数据的最小组成单位，若干个数据项可以组成一个数据结构。数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。</li>\n</details>\n</li>\n</ul>\n</li>\n</ul>\n</div><div class=\"φbu φbx\">\n<details>\n<summary><strong><code>概念结构设计</code></strong></summary>\n<ul>\n<li>将需求分析得到的<code>用户需求抽象为信息结构</code>(即概念模型)的过程就是概念结构设计。</li>\n<details>\n<summary><strong><code>E-R模型</code></strong></summary>\n<ul>\n<li>P.P.S.Chen提出的E-R模型是用E-R图来描述现实世界的概念模型.</li>\n<li><strong><code>实体之间的联系</code></strong></li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041458331.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041501108.png\" alt=\"\" loading=\"lazy\" class=\"φbp\"></li>\n<li>N个实体型之间的联系度为N,也称为N元联系。</li>\n</details>\n</li>\n<details>\n<summary><strong><code>E-R图</code></strong></summary>\n<ul>\n<li>E-R图提供了表示实体型、属性和联系的方法。</li>\n<li>实体型用矩形表示，矩形框内写明实体名。</li>\n<li>属性用椭圆形表示，并用无向边将其与相应的实体型连接起来。</li>\n<li>联系用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型(1:1、1:n或m:n)。<br>\n<img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041506766.png\" alt=\"\" loading=\"lazy\"></li>\n</details>\n</li>\n<details>\n<summary><strong><code>扩展的E-R模型</code></strong></summary>\n<ul>\n<details>\n<summary><strong><code>ISA联系</code></strong></summary>\n<ul>\n<li>遇到某些实体型是某个实体型的子类型。例如，研究生和本科生是学生的子类型，学生是父类型。这种父类-子类联系称为ISA联系，表示“is a”的语义. ISA联系用三角形来表示。</li>\n<li>ISA联系一个重要的性质是子类继承了父类的所有属性，描述了对一个实体型中实体的一种分类方法.</li>\n<details>\n<summary><code>分类属性</code></summary>\n<ul>\n<li>根据分类属性的值把父实体型中的实体分派到子实体型中<br>\n<img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041513447.png\" alt=\"\" loading=\"lazy\"></li>\n</details>\n</li>\n<details>\n<summary><code>不相交约束与可重叠约束</code></summary>\n<ul>\n<li>不相交约束描述父类中的一个实体不能同时属于多个子类中的实体集，即一个父类中的实体最多属于一个子类实体集，用ISA联系三角形符号内加一个叉号“X”来表示。如果父类中的一个实体能同时属于多个子类中的实体集，则称为可重叠约束，子类符号中没有叉号表示是可重叠的。<br>\n<img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041521971.png\" alt=\"\" loading=\"lazy\"></li>\n</details>\n</li>\n<details>\n<summary><code>Part-of联系 </code></summary>\n<ul>\n<li>Part-of联系即部分联系，它表明某个实体型是另外一个实体型的一部分。例如汽车和轮子两个实体型，轮子实体是汽车实体的一部分，即Part-of汽车实体。Part-of联系可以分为两种情况，一种是整体实体如果被破坏，部分实体仍然可以独立存在，称为<code>非独占</code>的Part-of联系. 非独占的Part-of联系可以通过基数约束来表达。<br>\n<img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041526631.png\" alt=\"\" loading=\"lazy\"><br>\n汽车队轮子的基数约束是0…1,这样的约束表示非强制参与联系, 轮子对汽车的约束 4…4, 强制参与联系.</li>\n</details>\n</li>\n<li>与非独占联系相反，还有一种Part-of联系是<code>独占</code>联系。即整体实体如果被破坏，部分实体不能存在，在E-R图中用<code>弱实体类型和识别联系</code>来表示独占联系。如果<code>一个实体型的存在依赖于其他实体型的存在</code>，则<code>这个实体型叫做弱实体型</code>，否则叫做<code>强实体型</code>。</li>\n<li>在E-R图中用双矩形表示弱实体型，用双菱形表示识别联系。<br>\n<img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041532199.png\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<details>\n<summary><strong><code>E-R图的集成</code></strong></summary>\n<ul>\n<li>经常采用的策略是自顶向下地进行需求分析，然后再自底向上地设计概念结构。即首先设计各子系统的分E-R图，然后将它们集成起来，得到全局E-R图。<br>\n<img src=\"https://cdn.jsdelivr.net/gh/s1acr/PicGoLib@main/2023-6/202306041541081.png\" alt=\"\" loading=\"lazy\"></li>\n</details>\n</li>\n</ul>\n</li>\n</ul>\n</div><div class=\"φbu φbx\">\n<details>\n<summary><strong><code>逻辑结构设计</code></strong></summary>\n<ul>\n<li>概念结构是独立于任何一种数据模型的信息结构，逻辑结构设计的任务就是把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。</li>\n<li>一般一个实体型转换为一个关系模式</li>\n</details>\n</li>\n</ul>\n</div><div class=\"φbu φbx\">\n<details>\n<summary><strong><code>物理结构设计</code></strong></summary>\n<ul>\n<li>为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程.</li>\n<li><strong><code>关系模式存取方法选择</code></strong></li>\n<li>存取方法是快速存取数据库中数据的技术。数据库管理系统一般提供多种存取方法。常用的存取方法为<code>索引方法和聚簇(clustering)方法</code>。B+树索引和hash索引是数据库中经典的存取方法，使用最普遍。</li>\n</details>\n</li>\n</ul>\n</div><hr>\n<p><strong>参考</strong></p>\n<ol>\n<li>数据库系统概论/王珊 第五版</li>\n</ol>\n","prev":{"title":"[VScode]leetcode调试刷题","link":"2023/06/03/[VScode]leetcode调试刷题"},"next":{"title":"[VScode]配置C_C++开发环境","link":"2023/06/01/[VScode]配置C_C++开发环境"},"plink":"https://s1acr.github.io/2023/06/03/[数据库]设计/","toc":[{"id":"关系数据理论","title":"关系数据理论","index":"1"},{"id":"数据库设计","title":"数据库设计","index":"2"}],"reward":true,"copyright":{"author":"slacr_","license":"<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" target=\"_blank\"><img src = \"/lib/cc-by-nc-sa.svg\">CC BY-NC-ND 4.0</a>","published":"June 3, 2023","updated":"June 3, 2023"},"reading_time":"3510 words in 23 min"}